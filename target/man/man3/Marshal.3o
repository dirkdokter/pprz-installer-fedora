.TH "Marshal" 3 2011-12-01 OCamldoc "OCaml library"
.SH NAME
Marshal \- Marshaling of data structures.
.SH Module
Module   Marshal
.SH Documentation
.sp
Module
.BI "Marshal"
 : 
.B sig  end

.sp
Marshaling of data structures\&.
.sp
This module provides functions to encode arbitrary data structures
as sequences of bytes, which can then be written on a file or
sent over a pipe or network connection\&.  The bytes can then
be read back later, possibly in another process, and decoded back
into a data structure\&. The format for the byte sequences
is compatible across all machines for a given version of Objective Caml\&.
.sp
Warning: marshaling is currently not type\-safe\&. The type
of marshaled data is not transmitted along the value of the data,
making it impossible to check that the data read back possesses the
type expected by the context\&. In particular, the result type of
the 
.B Marshal\&.from_*
functions is given as 
.B \&'a
, but this is
misleading: the returned Caml value does not possess type 
.B \&'a
for all 
.B \&'a
; it has one, unique type which cannot be determined
at compile\-type\&.  The programmer should explicitly give the expected
type of the returned value, using the following syntax:
.sp
\-
.B (Marshal\&.from_channel chan : type)
\&.
Anything can happen at run\-time if the object in the file does not
belong to the given type\&.

The representation of marshaled values is not human\-readable,
and uses bytes that are not printable characters\&. Therefore,
input and output channels used in conjunction with 
.B Marshal\&.to_channel
and 
.B Marshal\&.from_channel
must be opened in binary mode, using e\&.g\&.
.B open_out_bin
or 
.B open_in_bin
; channels opened in text mode will
cause unmarshaling errors on platforms where text channels behave
differently than binary channels, e\&.g\&. Windows\&.
.sp

.sp

.sp
.sp
.I type extern_flags 
=
 | No_sharing  (* Don\&'t preserve sharing *)
 | Closures  (* Send function closures *)
 
.sp
The flags to the 
.B Marshal\&.to_*
functions below\&.
.sp

.sp

.I val to_channel 
: 
.B Pervasives.out_channel -> 'a -> extern_flags list -> unit
.sp

.B Marshal\&.to_channel chan v flags
writes the representation
of 
.B v
on channel 
.B chan
\&. The 
.B flags
argument is a
possibly empty list of flags that governs the marshaling
behavior with respect to sharing and functional values\&.
.sp
If 
.B flags
does not contain 
.B Marshal\&.No_sharing
, circularities
and sharing inside the value 
.B v
are detected and preserved
in the sequence of bytes produced\&. In particular, this
guarantees that marshaling always terminates\&. Sharing
between values marshaled by successive calls to
.B Marshal\&.to_channel
is not detected, though\&.
If 
.B flags
contains 
.B Marshal\&.No_sharing
, sharing is ignored\&.
This results in faster marshaling if 
.B v
contains no shared
substructures, but may cause slower marshaling and larger
byte representations if 
.B v
actually contains sharing,
or even non\-termination if 
.B v
contains cycles\&.
.sp
If 
.B flags
does not contain 
.B Marshal\&.Closures
,
marshaling fails when it encounters a functional value
inside 
.B v
: only ``pure\&'\&' data structures, containing neither
functions nor objects, can safely be transmitted between
different programs\&. If 
.B flags
contains 
.B Marshal\&.Closures
,
functional values will be marshaled as a position in the code
of the program\&. In this case, the output of marshaling can
only be read back in processes that run exactly the same program,
with exactly the same compiled code\&. (This is checked
at un\-marshaling time, using an MD5 digest of the code
transmitted along with the code position\&.)
.sp

.sp

.I val to_string 
: 
.B 'a -> extern_flags list -> string
.sp

.B Marshal\&.to_string v flags
returns a string containing
the representation of 
.B v
as a sequence of bytes\&.
The 
.B flags
argument has the same meaning as for
.B Marshal\&.to_channel
\&.
.sp

.sp

.I val to_buffer 
: 
.B string -> int -> int -> 'a -> extern_flags list -> int
.sp

.B Marshal\&.to_buffer buff ofs len v flags
marshals the value 
.B v
,
storing its byte representation in the string 
.B buff
,
starting at character number 
.B ofs
, and writing at most
.B len
characters\&.  It returns the number of characters
actually written to the string\&. If the byte representation
of 
.B v
does not fit in 
.B len
characters, the exception 
.B Failure
is raised\&.
.sp

.sp

.I val from_channel 
: 
.B Pervasives.in_channel -> 'a
.sp

.B Marshal\&.from_channel chan
reads from channel 
.B chan
the
byte representation of a structured value, as produced by
one of the 
.B Marshal\&.to_*
functions, and reconstructs and
returns the corresponding value\&.
.sp

.sp

.I val from_string 
: 
.B string -> int -> 'a
.sp

.B Marshal\&.from_string buff ofs
unmarshals a structured value
like 
.B Marshal\&.from_channel
does, except that the byte
representation is not read from a channel, but taken from
the string 
.B buff
, starting at position 
.B ofs
\&.
.sp

.sp

.I val header_size 
: 
.B int
.sp
The bytes representing a marshaled value are composed of
a fixed\-size header and a variable\-sized data part,
whose size can be determined from the header\&.
.B Marshal\&.header_size
is the size, in characters, of the header\&.
.B Marshal\&.data_size
.B  buff ofs
is the size, in characters,
of the data part, assuming a valid header is stored in
.B buff
starting at position 
.B ofs
\&.
Finally, 
.B Marshal\&.total_size
.B  buff ofs
is the total size,
in characters, of the marshaled value\&.
Both 
.B Marshal\&.data_size
and 
.B Marshal\&.total_size
raise 
.B Failure
if 
.B buff
, 
.B ofs
does not contain a valid header\&.
.sp
To read the byte representation of a marshaled value into
a string buffer, the program needs to read first
.B Marshal\&.header_size
characters into the buffer,
then determine the length of the remainder of the
representation using 
.B Marshal\&.data_size
,
make sure the buffer is large enough to hold the remaining
data, then read it, and finally call 
.B Marshal\&.from_string
to unmarshal the value\&.
.sp

.sp

.I val data_size 
: 
.B string -> int -> int
.sp
See 
.B Marshal\&.header_size
\&.
.sp

.sp

.I val total_size 
: 
.B string -> int -> int
.sp
See 
.B Marshal\&.header_size
\&.
.sp

.sp

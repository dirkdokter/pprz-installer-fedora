<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Rpc_xti_client.html">
<link rel="next" href="Shell.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Unixqueue_mt" rel="Chapter" href="Unixqueue_mt.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netstring_mt" rel="Chapter" href="Netstring_mt.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_mt" rel="Chapter" href="Shell_mt.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html"><link title="Common exceptions" rel="Section" href="#1_Commonexceptions">
<link title="Environments" rel="Section" href="#1_Environments">
<link title="Commands" rel="Section" href="#1_Commands">
<link title="Processes" rel="Section" href="#1_Processes">
<link title="Foreign event loops" rel="Section" href="#1_Foreigneventloops">
<link title="Jobs" rel="Section" href="#1_Jobs">
<link title="Removed functions" rel="Section" href="#1_Removedfunctions">
<title>Ocamlnet 2 Reference Manual : Shell_sys</title>
</head>
<body>
<div class="navbar"><a href="Rpc_xti_client.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Shell.html">Next</a>
</div>
<center><h1>Module <a href="type_Shell_sys.html">Shell_sys</a></h1></center>
<br>
<pre><span class="keyword">module</span> Shell_sys: <code class="code">sig</code> <a href="Shell_sys.html">..</a> <code class="code">end</code></pre>Calls external programs, creates pipelines, etc. (full interface)<br>
<hr width="100%">
<br>
This module is <b>not thread-safe</b> because of undefined behaviour
 of some signal related functions in multi-threaded programs. This
 problem cannot be easily fixed, as the necessary multi-threading
 primitives are not available in O'Caml. (Maybe there is a solution
 for bytecode threads...)
<p>

 Nevertheless, <code class="code">shell</code> often seems to work in a multi-threaded environment.
 However, strange things can happen when two threads start new processes
 at the same time, because they overwrite the global signal mask. As
 a minimum precaution you should ensure that only one thread uses <code class="code">shell</code>
 at any time. Anyway, you have been warned.<br>
<br>
<a name="1_Commonexceptions"></a>
<h1>Common exceptions</h1><br>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONFatal_error"></a>Fatal_error <span class="keyword">of</span> <code class="type">exn</code></pre>
<div class="info">
An error is fatal if it is not possible to recover from it in a
 predictable manner. In this case, many function wrap such exceptions
 <code class="code">x</code> into <code class="code">Fatal_error x</code>.<br>
</div>
<br>
<a name="1_Environments"></a>
<h1>Environments</h1><br>
<pre><span class="keyword">type</span> <a name="TYPEenvironment"></a><code class="type"></code>environment </pre>
<div class="info">
The abstract type of a process environment<br>
</div>

<pre><span class="keyword">val</span> <a name="VALcreate_env"></a>create_env : <code class="type">unit -> <a href="Shell_sys.html#TYPEenvironment">environment</a></code></pre><div class="info">
Creates an empty environment<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcurrent_env"></a>current_env : <code class="type">unit -> <a href="Shell_sys.html#TYPEenvironment">environment</a></code></pre><div class="info">
Returns the environment of the current process as abstract environment
 value<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcopy_env"></a>copy_env : <code class="type"><a href="Shell_sys.html#TYPEenvironment">environment</a> -> <a href="Shell_sys.html#TYPEenvironment">environment</a></code></pre><div class="info">
Copies an environment<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_env"></a>set_env : <code class="type"><a href="Shell_sys.html#TYPEenvironment">environment</a> -> string array -> unit</code></pre><div class="info">
Sets the contents of the environment to the passed string array<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_env"></a>get_env : <code class="type"><a href="Shell_sys.html#TYPEenvironment">environment</a> -> string array</code></pre><div class="info">
Gets the contents of the environment as string array<br>
</div>
<pre><span class="keyword">val</span> <a name="VALiter_env"></a>iter_env : <code class="type">f:(string -> unit) -> <a href="Shell_sys.html#TYPEenvironment">environment</a> -> unit</code></pre><div class="info">
Iterates over the strings of the environment, and calls
 <code class="code">f s</code> for every string <code class="code">s</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_env_var"></a>set_env_var : <code class="type"><a href="Shell_sys.html#TYPEenvironment">environment</a> -> string -> string -> unit</code></pre><div class="info">
<code class="code">set_env_var env varname varval</code>: Sets the value of the variable
 <code class="code">varname</code> in the environment <code class="code">env</code> to <code class="code">varval</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_env_var"></a>get_env_var : <code class="type"><a href="Shell_sys.html#TYPEenvironment">environment</a> -> string -> string</code></pre><div class="info">
Returns the value of the variable in the environment<br>
</div>
<pre><span class="keyword">val</span> <a name="VALiter_env_vars"></a>iter_env_vars : <code class="type">f:(string -> string -> unit) -> <a href="Shell_sys.html#TYPEenvironment">environment</a> -> unit</code></pre><div class="info">
Iterates over the variables of the environment, and calls
 <code class="code">f name value</code> for every variable with <code class="code">name</code> and <code class="code">value</code>.<br>
</div>
<br>
<a name="1_Commands"></a>
<h1>Commands</h1><br>
<pre><span class="keyword">type</span> <a name="TYPEcommand"></a><code class="type"></code>command </pre>
<div class="info">
A command describes how to start a new process<br>
</div>

<pre><span class="keyword">val</span> <a name="VALcommand"></a>command : <code class="type">?cmdname:string -><br>       ?arguments:string array -><br>       ?chdir:string -><br>       ?environment:<a href="Shell_sys.html#TYPEenvironment">environment</a> -><br>       ?descriptors:Unix.file_descr list -><br>       ?assignments:(Unix.file_descr * Unix.file_descr) list -><br>       filename:string -> unit -> <a href="Shell_sys.html#TYPEcommand">command</a></code></pre><div class="info">
Creates a command from the passed arguments:
<p>

<br>
</div>
<div class="param_info"><code class="code">cmdname</code> : The name of the command passed in <code class="code">argv[0]</code>. By
   default, this argument is derived from <code class="code">filename</code>.</div>
<div class="param_info"><code class="code">arguments</code> : The arguments of the command (starting with the
   first real argument, skipping <code class="code">cmdname</code>). By default <code class="code"> [] </code>.</div>
<div class="param_info"><code class="code">chdir</code> : Before the command is executed it is changed to
   this directory.</div>
<div class="param_info"><code class="code">environment</code> : The environment of the command. By default, the
   current environment</div>
<div class="param_info"><code class="code">descriptors</code> : The list of file descriptors to share with the
   current process. In the subprocess only those descriptors remain open
   that are either mentioned in <code class="code">descriptors</code>, or that are the final target
   of assignments. By default, <code class="code"> [stdin; stdout; stderr] </code>.
<p>

 Note that only the <b>final targets</b> of assignments remain open in the
 subprocess (unless they are also listed in <code class="code">descriptors</code>). If there
 are cascaded assignments like <code class="code"> (fd1, fd2); (fd2, fd3) </code> the intermediate
 descriptors like <code class="code">fd2</code> are not considered as final targets; only <code class="code">fd3</code>
 would be a final target in this example.</div>
<div class="param_info"><code class="code">assignments</code> : A list of descriptor pairs <code class="code"> (fd_from,fd_to) </code>.
   The descriptor <code class="code">fd_from</code> in the current process will be assigned
   to <code class="code">fd_to</code> in the subprocess started for the command. 
   The list of assignments is executed sequentially, so
   later assignments must take the effect of previous assignments
   into account. For example, to make stderr of the subprocess write 
   to stdout of the parent process, pass <code class="code"> [(stdout; stderr)] </code>. <ul>
<li>By default, there are no assignments.</li>
</ul>
</div>
<div class="param_info"><code class="code">filename</code> : The name of the executable to start. The executable
   file is not searched, use <a href="Shell_sys.html#VALlookup_executable"><code class="code">Shell_sys.lookup_executable</code></a> for this
   purpose.</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONExecutable_not_found"></a>Executable_not_found <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info">
Raised when an executable file cannot be found; the argument is the
  search name<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlookup_executable"></a>lookup_executable : <code class="type">?path:string list -> string -> string</code></pre><div class="info">
Searches an executable file. If the passed search name contains a
 slash, it is expected that this name is already the path name of the
 executable. If the search name does not contain a slash character,
 it is searched in the directories enumerated by the search path.
<p>

<br>
</div>
<div class="param_info"><code class="code">path</code> : The search path. By default, the contents of the
   variable PATH of the current environment, split by ':', are
   used</div>
<pre><span class="keyword">val</span> <a name="VALget_cmdname"></a>get_cmdname : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> string</code></pre><div class="info">
Returns the name of the command<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_arguments"></a>get_arguments : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> string array</code></pre><div class="info">
Returns the argument array of the command (skipping the command name)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_chdir"></a>get_chdir : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> string option</code></pre><div class="info">
Returns the <code class="code">chdir</code> parameter of the command<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_environment"></a>get_environment : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> <a href="Shell_sys.html#TYPEenvironment">environment</a></code></pre><div class="info">
Returns the designated environment of the command<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_descriptors"></a>get_descriptors : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> Unix.file_descr list</code></pre><div class="info">
Returns the list of active descriptors<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_assignments"></a>get_assignments : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> (Unix.file_descr * Unix.file_descr) list</code></pre><div class="info">
Returns the list of assignments <code class="code"> (fd_from,fd_to) </code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_filename"></a>get_filename : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> string</code></pre><div class="info">
Returns the file name of the executable<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_cmdname"></a>set_cmdname : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> string -> unit</code></pre><div class="info">
Sets the command name<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_arguments"></a>set_arguments : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> string array -> unit</code></pre><div class="info">
Sets the argument array<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_chdir"></a>set_chdir : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> string option -> unit</code></pre><div class="info">
Sets the <code class="code">chdir</code> parameter of the command<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_environment"></a>set_environment : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> <a href="Shell_sys.html#TYPEenvironment">environment</a> -> unit</code></pre><div class="info">
Sets the environment<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_descriptors"></a>set_descriptors : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> Unix.file_descr list -> unit</code></pre><div class="info">
Sets the list of active descriptors<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_assignments"></a>set_assignments : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> (Unix.file_descr * Unix.file_descr) list -> unit</code></pre><div class="info">
Sets the list of assignments <code class="code"> (fd_from,fd_to) </code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_filename"></a>set_filename : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> string -> unit</code></pre><div class="info">
Sets the file name of the executable to start<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcopy_command"></a>copy_command : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> <a href="Shell_sys.html#TYPEcommand">command</a></code></pre><div class="info">
Returns a duplicate of the command description<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_executable"></a>is_executable : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> bool</code></pre><div class="info">
Returns <code class="code">true</code> if there is an executable file for the command, and
 it is permitted to run this file (as stated by the file permissions).
<p>

 <code class="code">false</code> means that the command can definitely not be executed. However,
 even if the function returns <code class="code">true</code> there may be still reasons that
 execution will fail.<br>
</div>
<br>
<a name="1_Processes"></a>
<h1>Processes</h1><br>
<pre><span class="keyword">type</span> <a name="TYPEprocess"></a><code class="type"></code>process </pre>
<div class="info">
A process is the running instance of a command (a Unix process)<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEgroup_action"></a><code class="type"></code>group_action = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">New_bg_group</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Start process in new background process group</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">New_fg_group</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Start process in new foreground process group</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Join_group</span> <span class="keyword">of</span> <code class="type">int</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Started process joins this existing process group</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Current_group</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Started process remains in the current group</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Determines in which process group the new process will run<br>
</div>

<pre><span class="keyword">val</span> <a name="VALrun"></a>run : <code class="type">?group:<a href="Shell_sys.html#TYPEgroup_action">group_action</a> -><br>       ?pipe_assignments:(Unix.file_descr * Unix.file_descr) list -><br>       <a href="Shell_sys.html#TYPEcommand">command</a> -> <a href="Shell_sys.html#TYPEprocess">process</a></code></pre><div class="info">
Executes the command concurrently with the current process. The function
 does not wait until the process terminates; it returns immediately after
 the <code class="code">exec</code> system call has been successfully performed; errors that
 occur until <code class="code">exec</code> are caught and reported as exception (even errors
 in the fresh subprocess).
<p>

 On error, one can assume that the process state has been cleaned up:
 any forked child process has terminated; any modifications of the global
 process state has been restored. 
<p>

 File descriptor assignments: First, the assignments in <code class="code">pipe_assignments</code>
 are performed, then the assignments contained in the command. The
 <code class="code">pipe_assignments</code> are interpreted as parallel assignment, not
 as sequential assignment.
<p>

 Note: For users without very special needs, it is recommended to run
 jobs instead of processes. See below for the job API.
<p>

<br>
</div>
<div class="param_info"><code class="code">group</code> : Determines in which process group the new process will
   run. By default <code class="code">Current_group</code>.</div>
<div class="param_info"><code class="code">pipe_assignments</code> : A list of descriptor pairs <code class="code">(fd_from,fd_to)</code>.
   The descriptor <code class="code">fd_from</code> in the current process will be assigned
   to <code class="code">fd_to</code> in the started subprocess. In order to
   take effect, <code class="code">fd_to</code> must also be passed in the <code class="code">descriptors</code>
   property of the started command.
   Furthermore, <code class="code">fd_from</code> may or may not be member of <code class="code">descriptors</code>;
   in the first case it will remain open, in the latter case it will
   be closed. The list of assignments is executed in parallel. For
   example, to swap the roles of stdout and stderr, pass the list
   <code class="code"> [(stdout,stderr); (stderr,stdout)] </code>.</div>
<pre><span class="keyword">val</span> <a name="VALprocess_id"></a>process_id : <code class="type"><a href="Shell_sys.html#TYPEprocess">process</a> -> int</code></pre><div class="info">
Returns the process ID of the process<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstatus"></a>status : <code class="type"><a href="Shell_sys.html#TYPEprocess">process</a> -> Unix.process_status</code></pre><div class="info">
Reports the status as determined by <code class="code">wait</code> (below): If the process 
 has terminated, the status of the process is returned.
 If the process is still running, <code class="code">Not_found</code> will be raised.
<p>

 Note: This function does <b>not</b> call <code class="code">Unix.waitpid</code> to get the status
 and to release the process ID. This is done by <code class="code">wait</code> below.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcommand_of_process"></a>command_of_process : <code class="type"><a href="Shell_sys.html#TYPEprocess">process</a> -> <a href="Shell_sys.html#TYPEcommand">command</a></code></pre><div class="info">
Returns the command that is now running as the process<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEprocess_event"></a><code class="type"></code>process_event = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">File_read</span> <span class="keyword">of</span> <code class="type">Unix.file_descr</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Data can be read from the fd</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">File_write</span> <span class="keyword">of</span> <code class="type">Unix.file_descr</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Data can be written to the fd</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">File_except</span> <span class="keyword">of</span> <code class="type">Unix.file_descr</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >OOB data can be read from the fd</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Process_event</span> <span class="keyword">of</span> <code class="type"><a href="Shell_sys.html#TYPEprocess">process</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The process has changed its status</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Signal</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >A signal happened</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Events used by <code class="code">wait</code><br>
</div>

<pre><span class="keyword">val</span> <a name="VALwait"></a>wait : <code class="type">?wnohang:bool -><br>       ?wuntraced:bool -><br>       ?restart:bool -><br>       ?check_interval:float -><br>       ?read:Unix.file_descr list -><br>       ?write:Unix.file_descr list -><br>       ?except:Unix.file_descr list -><br>       <a href="Shell_sys.html#TYPEprocess">process</a> list -> <a href="Shell_sys.html#TYPEprocess_event">process_event</a> list</code></pre><div class="info">
Watches the given list of processes and the file descriptors <code class="code">read</code>, 
  <code class="code">write</code>, and <code class="code">except</code>, and waits until events for these resources
  have happened, and reports these. It is allowed that the list of
  processes includes stopped and terminated processes.
<p>

 The function returns immediately with [] if it is no longer possible
 that any event can happen.
<p>

 The passed file descriptors must be open.
<p>

 The function reports events under these conditions:<ul>
<li>A process of the list terminates, either regularly, or because of
   a signal. This is recorded as <code class="code">Process_event</code>.</li>
<li>A process of the list stops, and <code class="code">wuntraced = true</code>. This is also
   recorded as <code class="code">Process_event</code>.</li>
<li>A file descriptor of the <code class="code">read</code> list delivers data. This is a
   <code class="code">File_read</code> event.</li>
<li>A file descriptor of the <code class="code">write</code> list accepts data. This is a
   <code class="code">File_write</code> event.</li>
<li>A file descriptor of the <code class="code">except</code> list delivers data. This is a
   <code class="code">File_except</code> event.</li>
</ul>

 Notes:<ul>
<li>The list of processes may contain terminated processes (that no longer
   exist) as long as the process status has already been recorded by a
   previous <code class="code">wait</code> invocation.</li>
<li>If <code class="code">wait</code> does not restart automatically on a signal, the function
   will raise <code class="code">Unix.Unix_error(Unix.EINTR,_,_)</code> when the signal condition
   is caught.</li>
<li>If a process causes both process and descriptor events at the same time, 
   it is not specified which events are reported first.</li>
<li>Only every <code class="code">check_interval</code> seconds it is checked whether there are
   process events. File descriptor events are reported without delay.</li>
</ul>

 It is suggested to install a signal handler for SIGCHLD to improve
 the responsiveness for process events. It is sufficient to install
 an empty handler for this effect.
<p>

<br>
</div>
<div class="param_info"><code class="code">wnohang</code> : If <code class="code">true</code>, it is immediately checked whether file or
   process events have happend, and if so, the event list is returned.
   When there are no events to report, the empty list is immediately
   returned. Default: <code class="code">false</code></div>
<div class="param_info"><code class="code">wuntraced</code> : Whether to report events about stopped processes.
   Default: <code class="code">false</code></div>
<div class="param_info"><code class="code">restart</code> : Whether to restart the event loop when a signal
   interrupts the loop. If <code class="code">true</code>, Unix errors of the type EINTR
   cannot happen any longer. Default: <code class="code">false</code></div>
<div class="param_info"><code class="code">check_interval</code> : How frequently the processes are checked for
   events (in seconds). In addition to this, the processes are also
   checked when a signal happens. Default: 0.1</div>
<div class="param_info"><code class="code">read</code> : The file descriptors to check for read events</div>
<div class="param_info"><code class="code">write</code> : The file descriptors to check for write events</div>
<div class="param_info"><code class="code">except</code> : The file descriptors to check for out-of-band events</div>
<pre><span class="keyword">val</span> <a name="VALcall"></a>call : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> <a href="Shell_sys.html#TYPEprocess">process</a></code></pre><div class="info">
Executes the command and waits until the process terminates
 (synchronous execution a la <code class="code">system</code>, but no intermediate shell).
 <code class="code">status</code> is guaranteed to return WEXITED or WSIGNALED.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALkill"></a>kill : <code class="type">?signal:int -> <a href="Shell_sys.html#TYPEprocess">process</a> -> unit</code></pre><div class="info">
Sends a signal to the passed process.
<p>

<br>
</div>
<div class="param_info"><code class="code">signal</code> : The signal to send, by default SIGTERM</div>
<br>
<a name="1_Foreigneventloops"></a>
<h1>Foreign event loops</h1><br>
<br>
The type <code class="code">system_handler</code> can be used to watch the progress of
  jobs from a foreign event loop instead of <code class="code">wait</code>. This interface
  is needed for the integration into the Unixqueue framework.<br>
<br><code><span class="keyword">type</span> <a name="TYPEsystem_handler"></a><code class="type"></code>system_handler = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>sys_register&nbsp;: <code class="type">?wuntraced:bool -><br>       ?check_interval:float -><br>       ?read:Unix.file_descr list -><br>       ?write:Unix.file_descr list -><br>       ?except:Unix.file_descr list -><br>       <a href="Shell_sys.html#TYPEprocess">process</a> list -> (<a href="Shell_sys.html#TYPEprocess_event">process_event</a> list -> unit) -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Register an event handler</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>sys_wait&nbsp;: <code class="type">unit -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Start the event loop</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
There are two record components:
<p>

 <code class="code">sys_register</code>: By calling this function a callback function for the 
   specified events is registered. The meaning of the arguments is the
   same as for <code class="code">wait</code>, except of the last argument which is the callback
   function of type <code class="code">process_event list -&gt; unit</code>. Instead of returning
   the events like <code class="code">wait</code>, <code class="code">sys_register</code> calls this function back
   to deliver the events.
<p>

 <code class="code">sys_wait</code>: By calling this function the event loop is started, and
   events are delivered to the registered callback. If exceptions are
   raised in the callback function these will not be caught, so the 
   caller of <code class="code">sys_wait</code> will get them. It must be possible to restart
   <code class="code">sys_wait</code> in this case.
<p>

   The callback function can change the list of interesting events by
   calling <code class="code">sys_register</code> again.
<p>

   If effectively no events are interesting (<code class="code">sys_register</code> is called without
   file descriptors and no running process) the callback function is called
   with an empty <code class="code">process_event list</code> once. If it does not register a new
   callback, the event loop will stop, and <code class="code">sys_wait</code> will return normally.<br>
</div>

<br>
<a name="1_Jobs"></a>
<h1>Jobs</h1><br>
<br>
A <code class="code">job</code> is the description of how to run several commands which are
 linked by pipelines (or which are just a logical unit). A <code class="code">job_instance</code>
 is the running instance of a job.
<p>

 Jobs are implemented on a higher layer than commands; the
 following means of the operating system are used by job
 invocations:<ul>
<li>Normally a <code class="code">job_instance</code> corresponds to a Unix process group. In
   this case the last added command will result in the process group
   leader.</li>
<li>Controlling the execution of jobs requires that signal
   handlers are set in many cases (see <code class="code">install_job_handlers</code>)</li>
<li>The processes of jobs are often interconnected by pipelines
   (see <code class="code">add_pipeline</code>).</li>
<li>It is possible to handle pipelines between the current process and
   processes of the job (see <code class="code">add_producer</code> and <code class="code">add_consumer</code>)</li>
</ul>
<br>
<br>
<b>Important:</b>
<p>

 In order to run jobs efficiently (without busy waiting) and properly
 it is strongly recommended to install the signal handlers using
 <code class="code">install_job_handlers</code><br>
<pre><span class="keyword">type</span> <a name="TYPEjob"></a><code class="type"></code>job </pre>

<pre><span class="keyword">type</span> <a name="TYPEjob_instance"></a><code class="type"></code>job_instance </pre>

<pre><span class="keyword">val</span> <a name="VALnew_job"></a>new_job : <code class="type">unit -> <a href="Shell_sys.html#TYPEjob">job</a></code></pre><div class="info">
Creates a new job descriptor. Initially the job is empty, but you can
 fill it with commands (<code class="code">add_command</code>), pipelines (<code class="code">add_pipeline</code>), 
 consumers (<code class="code">add_consumer</code>) and producers (<code class="code">add_producer</code>).
 When the job is set up, you can start it (<code class="code">run_job</code>/<code class="code">finish_job</code> or
 <code class="code">call_job</code>).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALadd_command"></a>add_command : <code class="type"><a href="Shell_sys.html#TYPEcommand">command</a> -> <a href="Shell_sys.html#TYPEjob">job</a> -> unit</code></pre><div class="info">
Adds a command to a job. 
<p>

 Note that you cannot add the same command twice; however you can
 add a copy of a command already belonging to the job.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALadd_pipeline"></a>add_pipeline : <code class="type">?bidirectional:bool -><br>       ?src_descr:Unix.file_descr -><br>       ?dest_descr:Unix.file_descr -><br>       src:<a href="Shell_sys.html#TYPEcommand">command</a> -> dest:<a href="Shell_sys.html#TYPEcommand">command</a> -> <a href="Shell_sys.html#TYPEjob">job</a> -> unit</code></pre><div class="info">
Adds a pipeline which redirects the output of the command <code class="code">src</code> to the
 input of the command <code class="code">dest</code>.
<p>

<br>
</div>
<div class="param_info"><code class="code">bidirectional</code> : if <code class="code">false</code> (default), a classical pipe is created
    to connect the file descriptors. This normally restricts the data
    flow to one direction. If <code class="code">true</code>, a socketpair is created which is
    roughly a bidirectional pipe. In this case, data flow in both
    directions is possible.</div>
<div class="param_info"><code class="code">src_descr</code> : determines the file descriptor of the source command
    which is redirected. This is by default <code class="code">stdout</code>.</div>
<div class="param_info"><code class="code">dest_descr</code> : determines the file descriptor of the destination
    command to which the data stream is sent. This is by default <code class="code">stdin</code>.</div>
<pre><span class="keyword">val</span> <a name="VALadd_producer"></a>add_producer : <code class="type">?descr:Unix.file_descr -><br>       producer:(Unix.file_descr -> bool) -><br>       <a href="Shell_sys.html#TYPEcommand">command</a> -> <a href="Shell_sys.html#TYPEjob">job</a> -> unit</code></pre><div class="info">
Adds a producer to the job. A producer transfers data to the
 subprocess realizing the passed command. To do so, a pipe is created
 between the file descriptor <code class="code">descr</code> of the subprocess and another
 descriptor <code class="code">descr'</code> which is open in the current process. The
 function <code class="code">producer</code> is called when data can be written into the
 pipe. The argument of <code class="code">producer</code> is the writing end of the pipe
 <code class="code">descr'</code>. This file descriptor is in non-blocking mode. The
 function <code class="code">producer</code> must close <code class="code">descr'</code> when all data are
 transferred. The return value of <code class="code">producer</code> indicates whether
 the descriptor is still open.
<p>

<br>
</div>
<div class="param_info"><code class="code">descr</code> : The descriptor of the subprocess to which the reading
    end of the pipe is dup'ed. By default <code class="code">stdin</code>.</div>
<pre><span class="keyword">val</span> <a name="VALfrom_string"></a>from_string : <code class="type">?pos:int -><br>       ?len:int -> ?epipe:(unit -> unit) -> string -> Unix.file_descr -> bool</code></pre><div class="info">
<code class="code">from_string ?pos ?len ?epipe s</code> returns a function which can be
 used as <code class="code">producer</code> argument for <code class="code">add_producer</code>. The data transferred
 to the subprocess is taken from the string <code class="code">s</code>. After these data
 are sent, the pipeline is closed.
<p>

<br>
</div>
<div class="param_info"><code class="code">pos</code> : The position in <code class="code">s</code> where the data slice to transfer begins.
    By default <code class="code">0</code>.</div>
<div class="param_info"><code class="code">len</code> : The length of the data slice to transfer. By default,
    all bytes from the start position <code class="code">pos</code> to the end of the 
    string are taken.</div>
<div class="param_info"><code class="code">epipe</code> : This function is called when the pipeline breaks
    (EPIPE). Default: the empty function. EPIPE exceptions are
    always caught, and implicitly handled by closing the pipeline.</div>
<pre><span class="keyword">val</span> <a name="VALfrom_stream"></a>from_stream : <code class="type">?epipe:(unit -> unit) -> string Stream.t -> Unix.file_descr -> bool</code></pre><div class="info">
<code class="code">from_stream ?epipe s</code> returns a function which can be
 used as <code class="code">producer</code> argument for <code class="code">add_producer</code>. The data transferred
 to the subprocess is taken from the string stream <code class="code">s</code>. After these data
 are sent, the pipeline is closed.
<p>

<br>
</div>
<div class="param_info"><code class="code">epipe</code> : This function is called when the pipeline breaks
    (EPIPE). Default: the empty function. EPIPE exceptions are
    always caught, and implicitly handled by closing the pipeline.</div>
<pre><span class="keyword">val</span> <a name="VALadd_consumer"></a>add_consumer : <code class="type">?descr:Unix.file_descr -><br>       consumer:(Unix.file_descr -> bool) -><br>       <a href="Shell_sys.html#TYPEcommand">command</a> -> <a href="Shell_sys.html#TYPEjob">job</a> -> unit</code></pre><div class="info">
Adds a consumer to the job. A consumer transfers data from the
 subprocess realizing the passed command to the current process. 
 To do so, a pipe is created between the file descriptor <code class="code">descr</code>
 of the subprocess and another descriptor <code class="code">descr'</code> which is open
 in the current process. The function <code class="code">consumer</code> is called when 
 data can be read from the pipe. The argument of <code class="code">consumer</code> is 
 reading end of the pipe <code class="code">descr'</code>. This file descriptor is in
 non-blocking mode. The function <code class="code">consumer</code> must close <code class="code">descr'</code> 
 after EOF is detected. The return value of <code class="code">consumer</code> indicates whether
 the descriptor is still open.
<p>

<br>
</div>
<div class="param_info"><code class="code">descr</code> : The descriptor of the subprocess to which the writing
    end of the pipe is dup'ed. By default <code class="code">stdout</code>.</div>
<pre><span class="keyword">val</span> <a name="VALto_buffer"></a>to_buffer : <code class="type">Buffer.t -> Unix.file_descr -> bool</code></pre><div class="info">
<code class="code">to_buffer b</code> returns a function which can be
 used as <code class="code">consumer</code> argument for <code class="code">add_consumer</code>. The data received
 from the subprocess is added to the buffer <code class="code">b</code>.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEgroup_mode"></a><code class="type"></code>group_mode = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Same_as_caller</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The job runs in the same process group as the current process</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Foreground</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The job runs in a new foreground process group</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Background</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The job runs in a new background process group</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Specifies how the job instance is related to process groups<br>
</div>

<pre><span class="keyword">val</span> <a name="VALrun_job"></a>run_job : <code class="type">?mode:<a href="Shell_sys.html#TYPEgroup_mode">group_mode</a> -><br>       ?forward_signals:bool -> <a href="Shell_sys.html#TYPEjob">job</a> -> <a href="Shell_sys.html#TYPEjob_instance">job_instance</a></code></pre><div class="info">
Invokes the commands of the job such that they run concurrently
 with the main process.
<p>

 The function returns a <code class="code">job_instance</code>, i.e. a value recording which
 processes are started, and how they are related. Furthermore, the
 function has the side effect of adding the
 job to the global list of current jobs.
<p>

 The <code class="code">mode</code> argument specifies whether a new Unix process group is
 created for the job instance. A process group has the advantage that
 it is possible to send signals to all processes of the group at
 once. For example, one can terminate a group by sending SIGTERM
 to it: All member processes get the signal. Usually, these are not only
 the subprocesses initially created, but also further processes 
 started by the initial members.
<p>

 So if it is necessary to send signals to the processes of the job,
 it will be advantegous to run it in a new process group. However,
 this also means that signals sent to the current process group
 are not automatically forwarded to the created process group. For
 example, if the current process group is terminated, the job
 will continue running, because it is member of a different process
 group. One has to explicitly catch and forward signals to avoid
 wild-running jobs.
<p>

 The moral of the story is that one should only create new process
 groups when it is necessary (e.g. the user must be able to stop
 an action at any time). Furthermore, signal forwarding must be
 configured.
<p>

 The Unix shell also allows the programmer to specify process group
 handling to a certain extent. Normally, commands are executed in the
 same process group as the caller. The syntax "command &amp;" forces that
 the command is run in a new background process group. There is another
 situation when new process groups are created: when a new <b>interactive</b> 
 shell is started the commands are run in new foreground process groups
 (so the keyboard signals like CTRL-C work).
<p>

<br>
</div>
<div class="param_info"><code class="code">mode</code> : Specifies the process group handling. By default, the
   job is executed in the same process group as the current process
   (<code class="code">Same_as_caller</code>). The value <code class="code">Background</code> causes that a new
   background process group is started. The value <code class="code">Foreground</code> causes
   that a new foreground process group is started. For the latter,
   it is required that there is a controlling terminal (i.e. it
   does not work for daemons). Any existing foreground process group
   (there is at most one) is put into the background, but this is
   not restored when the job is over (the caller must do this).
   Foreground process groups should be avoided unless you are
   writing an interactive shell interpreter.</div>
<div class="param_info"><code class="code">forward_signals</code> : If <code class="code">true</code>, the default, keyboard signals
   (SIGINT, SIGQUIT) delivered to the current process are forwarded to 
   the job. This has only a meaning if the job is running as 
   background process group. Furthermore, it is required that
   <code class="code">install_job_handlers</code> has been called to enable signal 
   forwarding.
<p>

 The function returns normally if at least one process could be started.
 If no process was startable (i.e. the first command was not startable), 
 an exception is raised. If one or more processes could be started but
 not all, <code class="code">job_status</code> will return <code class="code">Job_partially_running</code>. The caller 
 should then discard the job and any intermediate result that might
 already have been produced by the partial job.
<p>

 When all processes could be started and no other exceptional condition
 happened, the function sets <code class="code">job_status</code> to <code class="code">Job_running</code>.</div>
<pre><span class="keyword">val</span> <a name="VALregister_job"></a>register_job : <code class="type"><a href="Shell_sys.html#TYPEsystem_handler">system_handler</a> -> <a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> unit</code></pre><div class="info">
Registers the job at the passed <code class="code">system_handler</code>. This is not necessary
 if you directly call <code class="code">finish_job</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfinish_job"></a>finish_job : <code class="type">?sys:<a href="Shell_sys.html#TYPEsystem_handler">system_handler</a> -> <a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> unit</code></pre><div class="info">
Waits until all of the processes of the job have terminated.
 The function handles all producer/consumer events and calls the
 producer/consumer functions as necessary.
<p>

 Exceptions raised by the producer/consumer functions are not caught.
 In this case, <code class="code">finish_job</code> is restartable.
<p>

 The <code class="code">sys</code> argument determines the system_handler (<code class="code">standard_system_handler</code>
 by default). The job instance is registered at the system handler,
 and it is waited until the job finishes. Roughly, <code class="code">finish_job</code>
 is equivalent to
 <pre><code class="code">   register_job sys jobinst;
   sys.sys_wait()
 </code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALcall_job"></a>call_job : <code class="type">?mode:<a href="Shell_sys.html#TYPEgroup_mode">group_mode</a> -><br>       ?forward_signals:bool -><br>       ?onerror:(<a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> unit) -><br>       <a href="Shell_sys.html#TYPEjob">job</a> -> <a href="Shell_sys.html#TYPEjob_instance">job_instance</a></code></pre><div class="info">
Starts the job (see <code class="code">run_job</code>) and waits until it finishes (see
 <code class="code">finish_job</code>); i.e. <code class="code">call_job = run_job + finish_job</code>.
 The function returns normally if all processes can be started; you can
 examine <code class="code">job_status</code> of the result to get the information whether all
 processes returned the exit code 0.
<p>

<br>
</div>
<div class="param_info"><code class="code">mode</code> : See <code class="code">run_job</code></div>
<div class="param_info"><code class="code">forward_signals</code> : See <code class="code">run_job</code></div>
<div class="param_info"><code class="code">onerror</code> : If not all of the processes can be started, the
    function passed by <code class="code">onerror</code> is invoked. By default, this
    function calls <code class="code">abandon_job</code> to stop the already running
    processes. After the <code class="code">onerror</code> function has returned, the original 
    exception is raised again. Fatal error conditions are not caught.</div>
<pre><span class="keyword">val</span> <a name="VALprocesses"></a>processes : <code class="type"><a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> <a href="Shell_sys.html#TYPEprocess">process</a> list</code></pre><div class="info">
Returns the processes that have actually been started for this job
 by <code class="code">run_job</code>; note that the corresponding Unix process group
 may have additional processes (e.g. indirectly started processes).<br>
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONNo_Unix_process_group"></a>No_Unix_process_group</pre>
<div class="info">
Raised by functions referring to Unix process groups when the
 job has not been started in its own process group.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprocess_group_leader"></a>process_group_leader : <code class="type"><a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> <a href="Shell_sys.html#TYPEprocess">process</a></code></pre><div class="info">
Returns the process group leader process.
 This function is not available for jobs in the mode <code class="code">Same_as_caller</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprocess_group_id"></a>process_group_id : <code class="type"><a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> int</code></pre><div class="info">
Returns the Unix ID of the process group as number &gt; 1.
 This function is not available for jobs in the mode <code class="code">Same_as_caller</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprocess_group_expects_signals"></a>process_group_expects_signals : <code class="type"><a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> bool</code></pre><div class="info">
<code class="code">true</code> iff the group has <code class="code">mode=Background</code> and <code class="code">forward_signals</code>.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEjob_status"></a><code class="type"></code>job_status = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Job_running</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >All commands could be started, and at least
 one process is still running</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Job_partially_running</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Not all commands could be started, and at least
 one process is still running</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Job_ok</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >all processes terminated with exit code 0</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Job_error</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >all processes terminated but some abnormally</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Job_abandoned</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >the job has been abandoned (see <code class="code">abandon_job</code>)</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Indicates the status of the job<br>
</div>

<pre><span class="keyword">val</span> <a name="VALjob_status"></a>job_status : <code class="type"><a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> <a href="Shell_sys.html#TYPEjob_status">job_status</a></code></pre><div class="info">
Returns the status. The status may only change after <code class="code">finish_job</code>
 has been called:
<p>
<ul>
<li>after <code class="code">run_job</code>: status is <code class="code">Job_running</code> or <code class="code">Job_partially_running</code></li>
<li>after <code class="code">finish_job</code>: if returning normally: status is <code class="code">Job_ok</code> or 
   <code class="code">Job_error</code>. After an exception happened the other states are possible,
   too</li>
</ul>
<br>
</div>
<pre><span class="keyword">val</span> <a name="VALkill_process_group"></a>kill_process_group : <code class="type">?signal:int -> <a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> unit</code></pre><div class="info">
Kills the process group if it is still (at least partially) running.
 This operation is not available if the mode is <code class="code">Same_as_caller</code>
 (exception <code class="code">No_Unix_process_group</code>).
<p>

 Note 1: In the Unix terminology, "killing a job" only means to send
 a signal to the job. So the job may continue running, or it may
 terminate; in general we do not know this. Because of this, the job
 will still have an entry in the job list.
<p>

 Note 2: Because sub-sub-processes are also killed, this function may send
 the signal to more processes than kill_processes (below). On the other
 hand, it is possible that sub-processes change their group ID such that
 it is also possible that this function sends the signal to fewer processes
 than kill_processes.
<p>

<br>
</div>
<div class="param_info"><code class="code">signal</code> : The signal number to send (O'Caml signal numbers as
    used by the <code class="code">Sys</code> module). Default is <code class="code">Sys.sigterm</code>.</div>
<pre><span class="keyword">val</span> <a name="VALkill_processes"></a>kill_processes : <code class="type">?signal:int -> <a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> unit</code></pre><div class="info">
Kills the individual processes of the job which are still running.
<p>

<br>
</div>
<div class="param_info"><code class="code">signal</code> : The signal number to send (O'Caml signal numbers as
    used by the <code class="code">Sys</code> module). Default is <code class="code">Sys.sigterm</code>.</div>
<pre><span class="keyword">val</span> <a name="VALabandon_job"></a>abandon_job : <code class="type">?signal:int -> <a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> unit</code></pre><div class="info">
Tries to get rid of a running job. If the mode is <code class="code">Same_as_caller</code>, the
 signal is sent to the processes individually. If the mode is
 <code class="code">Foreground</code> or <code class="code">Background</code>, the signal is sent to the process group 
 corresponding to the job.
<p>

 This function removes the job from the job list; i.e. it is no longer
 watched. Because of some magic spells it is guaranteed that the job dies
 immediately without becoming a zombie (provided you have a SIGCHLD
 handler).
<p>

<br>
</div>
<div class="param_info"><code class="code">signal</code> : The signal number to send (O'Caml signal numbers as
    used by the <code class="code">Sys</code> module). Default is <code class="code">Sys.sigterm</code>.</div>
<pre><span class="keyword">val</span> <a name="VALiter_job_instances"></a>iter_job_instances : <code class="type">f:(<a href="Shell_sys.html#TYPEjob_instance">job_instance</a> -> unit) -> unit</code></pre><div class="info">
Iterates over the jobs in the list of active jobs and calls <code class="code">f</code> for every
 <code class="code">job_instance</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwatch_for_zombies"></a>watch_for_zombies : <code class="type">unit -> unit</code></pre><div class="info">
Iterates over the jobs in the list of abandoned jobs, and removes
 zombie processes.<br>
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONAlready_installed"></a>Already_installed</pre>
<div class="info">
Raised when the job handlers are already installed<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconfigure_job_handlers"></a>configure_job_handlers : <code class="type">?catch_sigint:bool -><br>       ?catch_sigquit:bool -><br>       ?catch_sigterm:bool -><br>       ?catch_sighup:bool -><br>       ?catch_sigchld:bool -> ?set_sigpipe:bool -> ?at_exit:bool -> unit -> unit</code></pre><div class="info">
Configures signal and at_exit handlers for jobs:<ul>
<li>The keyboard signals SIGINT and SIGQUIT are forwarded to all jobs
   which are running in the background (and thus are not
   automatically notified) and want to get such signals (<code class="code">forward_signals</code>).
   After the signals have been forwarded, the previous signal action
   is performed.</li>
<li>The signals SIGTERM and SIGHUP are (if the handler is installed) 
   forwarded to all dependent processes (regardless whether they are
   running in their own Unix process group or not, and regardless of
   <code class="code">forward_signals</code>).
   After the signals have been forwarded, the previous signal action
   is performed.</li>
<li>The <code class="code">at_exit</code> handler sends a SIGTERM to all dependent processes, too.</li>
<li>the SIGCHLD handler calls <code class="code">watch_for_zombies</code>.
   After this function is called, the previous signal action
   is performed; however if the previous action was <code class="code">Signal_ignore</code>
   this is incorrectly interpreted as empty action (zombies are not
   avoided)</li>
<li>The handler for SIGPIPE does nothing; note that a previous action
   is overwritten (the parameter is called <code class="code">set_sigpipe</code> to stress this)</li>
</ul>

 Dependent processes are:<ul>
<li>For jobs with mode = <code class="code">Foreground</code> or <code class="code">Background</code>: the processes
   of the corresponding Unix process group</li>
<li>For jobs with mode = <code class="code">Same_as_caller</code>: the actually started
   children processes</li>
</ul>

 Note that if an uncaught exception leads to program termination,
 this situation will not be detected; any running jobs will
 not be terminated (sorry, this cannot be fixed).
<p>

 This function sets only which handlers will be installed when
 <code class="code">install_job_handlers</code> (below) is invoked.
 The function fails if the handlers are already installed.
<p>

 KNOWN BUGS: At least for O'Caml 3.00, the handlers do not call the old
 signal handlers after their own work has been done; this is due to an
 error in Sys.signal.
<p>

<br>
</div>
<div class="param_info"><code class="code">catch_sigint</code> : whether to install a SIGINT handler (default: <code class="code">true</code>)</div>
<div class="param_info"><code class="code">catch_sigquit</code> : whether to install a SIGQUIT handler (default: <code class="code">true</code>)</div>
<div class="param_info"><code class="code">catch_sigterm</code> : whether to install a SIGTERM handler (default: <code class="code">true</code>)</div>
<div class="param_info"><code class="code">catch_sighup</code> : whether to install a SIGHUP handler (default: <code class="code">true</code>)</div>
<div class="param_info"><code class="code">catch_sigchld</code> : whether to install a SIGCHLD handler (default: <code class="code">true</code>)</div>
<div class="param_info"><code class="code">set_sigpipe</code> : whether to set a SIGPIPE handler (default: <code class="code">true</code>)</div>
<div class="param_info"><code class="code">at_exit</code> : whether to set the <code class="code">at_exit</code> handler (default: <code class="code">true</code>)</div>
<pre><span class="keyword">val</span> <a name="VALinstall_job_handlers"></a>install_job_handlers : <code class="type">unit -> unit</code></pre><div class="info">
Installs handlers as configured before.
 Raises <code class="code">Already_installed</code> if the handlers are already installed.<br>
</div>
<br>
<a name="1_Removedfunctions"></a>
<h1>Removed functions</h1><br>
<br>
The functions <code class="code">add_rd_polling</code> and <code class="code">add_wr_polling</code> have been removed.
 They were added prior to the merge with the equeue library. Use a 
 Unixqueue now, which is much more powerful.<br>
</body></html>
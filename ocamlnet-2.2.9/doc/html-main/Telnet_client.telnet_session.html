<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Telnet_client.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Unixqueue_mt" rel="Chapter" href="Unixqueue_mt.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netstring_mt" rel="Chapter" href="Netstring_mt.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_mt" rel="Chapter" href="Shell_mt.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html"><title>Ocamlnet 2 Reference Manual : Telnet_client.telnet_session</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="Telnet_client.html">Up</a>
&nbsp;</div>
<center><h1>Class <a href="type_Telnet_client.telnet_session.html">Telnet_client.telnet_session</a></h1></center>
<br>
<pre><span class="keyword">class</span> <a name="TYPEtelnet_session"></a>telnet_session : <code class="type"></code><code class="code">object</code> <a href="Telnet_client.telnet_session.html">..</a> <code class="code">end</code></pre>A telnet session<br>
<hr width="100%">
<a name="2_Overwiew"></a>
<h2>Overwiew</h2>
<p>

 The <code class="code">telnet_session</code> object has two queues, one for arriving data,
 one for data to send.
 Once the session object is attached to an event system, it connects
 to the remote peer, and processes the queues. Input is appended to
 the input queue; output found on the output queue is sent to the
 other side.
 If input arrives, a callback function is invoked.
 You may close the output side of the socket by putting <code class="code">Telnet_eof</code>
 onto the output queue.
 Once the EOF marker has been received, a <code class="code">Telnet_eof</code> is appended to
 the input queue, and the connection is closed (completely). The
 session object detaches from the event system automatically in this
 case.
<p>

 <b>Hints</b>
<p>

 Set an input handler as callback function in the session object.
 The input handler is called when new input data have been arrived.
 It should inspect the input queue, process the queue as much as
 possible, and it should remove the processed items from the queue.
 While processing, it may add new items to the output queue. 
<p>

 If you are not within the callback function and add items to the
 output queue, the session object will not detect that there are
 new items to send - unless you invoke the <code class="code">update</code> method.
<p>

 If you want option negotiation, it is the simplest way to use
 the special option negotiation methods. Configure the options
 as you want (invoking <code class="code">enable</code>, <code class="code">disable</code> etc), but do not forget
 to modify the way input is processed. Every <code class="code">Telnet_will</code>, <code class="code">_wont</code>,
 <code class="code">_do</code>, and <code class="code">_dont</code> command must be passed to <code class="code">process_option_command</code>.<pre><span class="keyword">method</span> <a name="METHODset_connection"></a>set_connection : <code class="type"><a href="Telnet_client.html#TYPEtelnet_connector">telnet_connector</a> -> unit</code></pre><div class="info">
Sets the host name and the port of the remote server to contact.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODset_event_system"></a>set_event_system : <code class="type"><a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> unit</code></pre><div class="info">
Sets the event system to use. By default, a private event system
 is used.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODset_callback"></a>set_callback : <code class="type">(bool -> unit) -> unit</code></pre><div class="info">
Sets the callback function. This function is called after new
 commands have been put onto the input queue. 
 The argument passed to the callback function indicates whether
 a 'Synch' sequence was received from the remote side or not.
<p>

 <b>Note Synch:</b> If the client sees a data mark command it will assume
 that it is actually a Synch sequence. The client automatically
 discards any <code class="code">Telnet_data</code> commands from the input queue (but not
 <code class="code">Telnet_data</code>s inside subnegotiations). The data mark command
 itself remains on the queue.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODset_exception_handler"></a>set_exception_handler : <code class="type">(exn -> unit) -> unit</code></pre><div class="info">
Sets the exception handler. Every known error condition is
 caught and passed to the exception handler.
 The exception handler can do whatever it wants to do. If it
 raises again an exception, the new exception is always propagated
 up to the caller (whoever this is). Often the caller is the
 event system scheduler (i.e. <code class="code">Unixqueue.run</code>); see the documention
 there.
<p>

 If you do not set the exception handler, a default handler is
 active. It first resets the session (see method <code class="code">reset</code>), and
 then wraps the exception into the <code class="code">Telnet_protocol</code> exception,
 and raises this exception again.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODoutput_queue"></a>output_queue : <code class="type"><a href="Telnet_client.html#TYPEtelnet_command">telnet_command</a> Queue.t</code></pre><div class="info">
The queue of commands to send to the remote side. If you add new
 commands to this queue, do not forget to invoke the <code class="code">update</code>
 method which indicates to the event system that new data to
 send is available.
 After commands have been sent, they are removed from the queue.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODinput_queue"></a>input_queue : <code class="type"><a href="Telnet_client.html#TYPEtelnet_command">telnet_command</a> Queue.t</code></pre><div class="info">
The queue of commands received from the remote side. This class
 only adds commands to the queue (and invokes the callback 
 function). The user of this class is responsible for removing
 commands from the queue which have been processed.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODget_options"></a>get_options : <code class="type"><a href="Telnet_client.html#TYPEtelnet_options">telnet_options</a></code></pre><div class="info">
Get the configuration options.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODset_options"></a>set_options : <code class="type"><a href="Telnet_client.html#TYPEtelnet_options">telnet_options</a> -> unit</code></pre><div class="info">
Set the configuration options.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODreset"></a>reset : <code class="type">unit -> unit</code></pre><div class="info">
Closes the connection immediately and empties all queues.
 All negotiated options are reset, too.<br>
</div>
<a name="2_Telnetoptions"></a>
<h2>Telnet options</h2>
<p>

 The following methods deal with Telnet protocol options. These
 are negotiated between local and remote side by the Will, Won't,
 Do and Don't commands. 
<p>

 The "local" options describe the modification of the behaviour
 of the local side; the "remote" options describe the modifications
 of the remote side. Both set of options are independent.
 This object may track the set of accepted and rejected options
 if the following methods are used; but this works only if
 the <code class="code">Telnet_will</code>, <code class="code">_wont</code>, <code class="code">_do</code>, and <code class="code">_dont</code> commands received from
 the remote side are processed by <code class="code">process_option_command</code>. So
 you need to invoke this method for the mentioned commands in
 your command interpretation loop.
<p>

 The idea is: If you <b>enable</b> an option, it is possible to
 switch it on. If the remote side requests the option to be enabled,
 the request will be acknowledged. If the remote side does not
 request the option, it remains off.
<p>

 You can also actively demand an option (<code class="code">offer_local_option</code>,
 <code class="code">request_remote_option</code>); this is of course only possible if
 the option is already enabled. In this case the client tries
 actively to switch it on.
<p>

 You can also <b>disable</b> an option. If the option is on, the
 client actively rejects the option; following the Telnet protocol
 this is always possible (rejections cannot be rejected).
<p>

 The <code class="code">reset</code> methods are somewhat dangerous. They simply reset
 the internal state of the client, but do not negotiate. This
 possibility was added to allow the Timing Mark option to send
 again timing marks even if the previous timing marks have
 already been accepted. After <code class="code">reset</code>, the client thinks the
 option was never negotiated; but nothing is done to tell
 the remote side about this.
<p>

 <code class="code">option_negotiation_is_over</code>: true if no option negotiation is
 pending (i.e. nothing has still to be acknowledged).<pre><span class="keyword">method</span> <a name="METHODenable_local_option"></a>enable_local_option : <code class="type"><a href="Telnet_client.html#TYPEtelnet_negotiated_option">telnet_negotiated_option</a> -> unit</code></pre><pre><span class="keyword">method</span> <a name="METHODenable_remote_option"></a>enable_remote_option : <code class="type"><a href="Telnet_client.html#TYPEtelnet_negotiated_option">telnet_negotiated_option</a> -> unit</code></pre><pre><span class="keyword">method</span> <a name="METHODdisable_local_option"></a>disable_local_option : <code class="type"><a href="Telnet_client.html#TYPEtelnet_negotiated_option">telnet_negotiated_option</a> -> unit</code></pre><pre><span class="keyword">method</span> <a name="METHODdisable_remote_option"></a>disable_remote_option : <code class="type"><a href="Telnet_client.html#TYPEtelnet_negotiated_option">telnet_negotiated_option</a> -> unit</code></pre><pre><span class="keyword">method</span> <a name="METHODoffer_local_option"></a>offer_local_option : <code class="type"><a href="Telnet_client.html#TYPEtelnet_negotiated_option">telnet_negotiated_option</a> -> unit</code></pre><pre><span class="keyword">method</span> <a name="METHODrequest_remote_option"></a>request_remote_option : <code class="type"><a href="Telnet_client.html#TYPEtelnet_negotiated_option">telnet_negotiated_option</a> -> unit</code></pre><pre><span class="keyword">method</span> <a name="METHODreset_local_option"></a>reset_local_option : <code class="type"><a href="Telnet_client.html#TYPEtelnet_negotiated_option">telnet_negotiated_option</a> -> unit</code></pre><pre><span class="keyword">method</span> <a name="METHODreset_remote_option"></a>reset_remote_option : <code class="type"><a href="Telnet_client.html#TYPEtelnet_negotiated_option">telnet_negotiated_option</a> -> unit</code></pre><pre><span class="keyword">method</span> <a name="METHODget_local_option"></a>get_local_option : <code class="type"><a href="Telnet_client.html#TYPEtelnet_negotiated_option">telnet_negotiated_option</a> -> <a href="Telnet_client.html#TYPEtelnet_option_state">telnet_option_state</a></code></pre><pre><span class="keyword">method</span> <a name="METHODget_remote_option"></a>get_remote_option : <code class="type"><a href="Telnet_client.html#TYPEtelnet_negotiated_option">telnet_negotiated_option</a> -> <a href="Telnet_client.html#TYPEtelnet_option_state">telnet_option_state</a></code></pre><pre><span class="keyword">method</span> <a name="METHODoption_negotiation_is_over"></a>option_negotiation_is_over : <code class="type">bool</code></pre><pre><span class="keyword">method</span> <a name="METHODprocess_option_command"></a>process_option_command : <code class="type"><a href="Telnet_client.html#TYPEtelnet_command">telnet_command</a> -> unit</code></pre><pre><span class="keyword">method</span> <a name="METHODfetch_subnegotiation"></a>fetch_subnegotiation : <code class="type">string option</code></pre><div class="info">
This method should be called as follows:
 If you find a <code class="code">Telnet_sb</code> at the beginning of the input queue,
 remove this command <code class="code">Queue.take</code>, and invoke <code class="code">fetch_subnegotiation</code>.
 This method scans the queue and looks for the associated 
 <code class="code">Telnet_se</code> command. If it does not find it, <code class="code">None</code> is returned.
 If <code class="code">Telnet_se</code> is found, the parameter enclosed by the two commands
 is returned as <code class="code">Some s</code> where <code class="code">s</code> is the parameter string. Furthermore,
 in the latter case the data items and the closing <code class="code">Telnet_se</code> are
 removed from the queue.<br>
</div>
<a name="2_Runningthesession"></a>
<h2>Running the session</h2><pre><span class="keyword">method</span> <a name="METHODattach"></a>attach : <code class="type">unit -> unit</code></pre><div class="info">
Attach to the event system. After being attached, the client
 is ready to work.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODrun"></a>run : <code class="type">unit -> unit</code></pre><div class="info">
Run the event system<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODupdate"></a>update : <code class="type">unit -> unit</code></pre><div class="info">
If there are commands in the output queue, the event system is
 signaled that this client wants to do network I/O.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODsend_synch"></a>send_synch : <code class="type"><a href="Telnet_client.html#TYPEtelnet_command">telnet_command</a> list -> unit</code></pre><div class="info">
At the next output oppurtunity, a Synch sequence is sent to
 the remote peer. This means that the passed commands, extended
 by an additional Data Mark command, are sent to the peer as
 urgent data.
<p>

 Sending a Synch sequence has higher priority than the output
 queue; processing of the output queue is deferred until the
 Synch sequence has been completely sent.<br>
</div>
</body></html>
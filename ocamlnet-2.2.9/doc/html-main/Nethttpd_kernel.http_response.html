<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Nethttpd_kernel.http_protocol_config.html">
<link rel="Up" href="Nethttpd_kernel.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Unixqueue_mt" rel="Chapter" href="Unixqueue_mt.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netstring_mt" rel="Chapter" href="Netstring_mt.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_mt" rel="Chapter" href="Shell_mt.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html"><title>Ocamlnet 2 Reference Manual : Nethttpd_kernel.http_response</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="Nethttpd_kernel.html">Up</a>
&nbsp;<a href="Nethttpd_kernel.http_protocol_config.html">Next</a>
</div>
<center><h1>Class type <a href="type_Nethttpd_kernel.http_response.html">Nethttpd_kernel.http_response</a></h1></center>
<br>
<pre><span class="keyword">class type</span> <a name="TYPEhttp_response"></a>http_response = <code class="code">object</code> <a href="Nethttpd_kernel.http_response.html">..</a> <code class="code">end</code></pre>Encapsultation of the HTTP response for a single request<br>
<hr width="100%">
<a name="2_Representstheactionofsendingtheresponse"></a>
<h2>Represents the action of sending the response</h2>
<p>

 This class has an internal
 queue of response tokens that are not yet processed. One can easily add
 new tokens to the end of the queue (<code class="code">send</code>). 
<p>

 The class is responsible for determining the transfer encoding:<ul>
<li>When the HTTP version is 1.0, the encoding is always "identity", and the
   connection will be closed after the response.</li>
<li>When the HTTP version is 1.1, and there is a Content-length header,
   the encoding will be selected as "identity". It is checked whether the
   body has really this length. If too short, it is suggested to close
   the connection. If too long, the extra part of the message is silently
   dropped.</li>
<li>When the HTTP version is 1.1, and there is no Content-length header,
   the encoding will be selected as "chunked".</li>
</ul>

 Currently, the <code class="code">TE</code> request header is not taken into account. The trailer
 is always empty.
<p>

 The following headers are set (or removed) by this class:<ul>
<li><code class="code">Transfer-Encoding</code></li>
<li><code class="code">Trailer</code></li>
<li><code class="code">Date</code></li>
<li><code class="code">Connection</code></li>
<li><code class="code">Upgrade</code></li>
<li><code class="code">Server</code> (it is appended to this field)</li>
</ul>

 Responses for HEAD requests have the special behaviour that the body is silently
 dropped. The calculation of header fields is not affected by this. This means
 that HEAD can be easily implemented by doing the same as for GET.
<p>

 Responses for other requests that must not include a body must set
 <code class="code">Content-Length</code> to 0.<a name="2_Thesemethodscanbecalledbythecontentprovider"></a>
<h2>These methods can be called by the content provider:</h2><pre><span class="keyword">method</span> <a name="METHODstate"></a>state : <code class="type"><a href="Nethttpd_kernel.html#TYPEresp_state">resp_state</a></code></pre><div class="info">
Reports the state. The initial state is <code class="code">`Inhibited</code><br>
</div>
<pre><span class="keyword">method</span> <a name="METHODbidirectional_phase"></a>bidirectional_phase : <code class="type">bool</code></pre><div class="info">
The bidrectional phase starts after "100 Continue" has been sent to the
 client, and stops when the response body begins. The bidirectional phase
 is special for the calculation of timeout values (input determines the timeout
 although the response has started).<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODsend"></a>send : <code class="type"><a href="Nethttpd_kernel.html#TYPEresp_token">resp_token</a> -> unit</code></pre><div class="info">
Add token to the end of the send queue<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODsend_queue_empty"></a>send_queue_empty : <code class="type">bool</code></pre><div class="info">
Return whether the send queue is empty. When the state is <code class="code">`Inhibited</code>, this
 method fakes an empty queue.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODprotocol"></a>protocol : <code class="type"><a href="Nethttp.html#TYPEprotocol">Nethttp.protocol</a></code></pre><div class="info">
The HTTP version of the response. This is currently always HTTP/1.1, but maybe
 we need to fake lower versions for buggy clients. Let's see what comes.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODclose_connection"></a>close_connection : <code class="type">bool</code></pre><div class="info">
Returns whether the connection should be closed after this response.
 This flag should be evaluated when the <code class="code">`Resp_end</code> front token has been
 reached.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODtransfer_encoding"></a>transfer_encoding : <code class="type"><a href="Nethttpd_kernel.html#TYPEtransfer_coding">transfer_coding</a></code></pre><div class="info">
Returns the selected transfer encoding. This is valid after the header
 has been passed to this object with <code class="code">send</code>.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODfront_token"></a>front_token : <code class="type"><a href="Nethttpd_kernel.html#TYPEfront_token">front_token</a></code></pre><div class="info">
The first token of the queue, represented as <code class="code">data_chunk</code>. Raises 
 <code class="code">Send_queue_empty</code> when there is currently no front token, or the state
 is <code class="code">`Inhibited</code>.
 If there is a front token, it will never have length 0.
<p>

 Note that <code class="code">Unix_error</code> exceptions can be raised when <code class="code">`Resp_action</code>
 tokens are processed.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODset_callback"></a>set_callback : <code class="type">(unit -> unit) -> unit</code></pre><div class="info">
The function will be called when either <code class="code">set_state</code> changes the state,
 or when the send queue becomes empty. Note that the callback must never
 fail, it is called in situations that make it hard to recover from errors.<br>
</div>
<a name="2_ThesemethodsmustonlybecalledbytheHTTPprotocolprocessor"></a>
<h2>These methods must only be called by the HTTP protocol processor:</h2><pre><span class="keyword">method</span> <a name="METHODset_state"></a>set_state : <code class="type"><a href="Nethttpd_kernel.html#TYPEresp_state">resp_state</a> -> unit</code></pre><div class="info">
Sets the state<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODadvance"></a>advance : <code class="type">int -> unit</code></pre><div class="info">
Tell this object that <code class="code">n</code> bytes of the front token could be really
 sent using <code class="code">Unix.write</code>. If this means that the whole front token
 has been sent, the next token is pulled from the queue and is made
 the new front token. Otherwise, the data chunk representing the
 front token is modified such that the position is advanced by
 <code class="code">n</code>, and the length is reduced by <code class="code">n</code>.<br>
</div>
</body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Rpc_transport.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Unixqueue_mt" rel="Chapter" href="Unixqueue_mt.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netstring_mt" rel="Chapter" href="Netstring_mt.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_mt" rel="Chapter" href="Shell_mt.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html"><title>Ocamlnet 2 Reference Manual : Rpc_transport.rpc_multiplex_controller</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="Rpc_transport.html">Up</a>
&nbsp;</div>
<center><h1>Class type <a href="type_Rpc_transport.rpc_multiplex_controller.html">Rpc_transport.rpc_multiplex_controller</a></h1></center>
<br>
<pre><span class="keyword">class type</span> <a name="TYPErpc_multiplex_controller"></a>rpc_multiplex_controller = <code class="code">object</code> <a href="Rpc_transport.rpc_multiplex_controller.html">..</a> <code class="code">end</code></pre><hr width="100%">
<pre><span class="keyword">method</span> <a name="METHODalive"></a>alive : <code class="type">bool</code></pre><div class="info">
If the controller is alive, the socket is not yet completely down.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODevent_system"></a>event_system : <code class="type"><a href="Unixqueue.event_system.html">Unixqueue.event_system</a></code></pre><div class="info">
Returns the event system<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODgetsockname"></a>getsockname : <code class="type"><a href="Rpc_transport.html#TYPEsockaddr">sockaddr</a></code></pre><div class="info">
The address of this socket<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODgetpeername"></a>getpeername : <code class="type"><a href="Rpc_transport.html#TYPEsockaddr">sockaddr</a></code></pre><div class="info">
The address of the peer's socket. Only available if the socket
 is connected. (Fails otherwise.)<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODprotocol"></a>protocol : <code class="type"><a href="Rpc.html#TYPEprotocol">Rpc.protocol</a></code></pre><div class="info">
The protocol encapsulation<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODpeer_user_name"></a>peer_user_name : <code class="type">string option</code></pre><div class="info">
If the transport mechanism provides a way to authenticate the
 peer, it can return the name here.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODreading"></a>reading : <code class="type">bool</code></pre><div class="info">
True iff there is a reader<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODread_eof"></a>read_eof : <code class="type">bool</code></pre><div class="info">
Whether the EOF marker has been read<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODstart_reading"></a>start_reading : <code class="type">?peek:(unit -> unit) -><br>       ?before_record:(int -> <a href="Rpc_transport.html#TYPEsockaddr">sockaddr</a> -> unit) -><br>       when_done:((<a href="Rpc_packer.html#TYPEpacked_value">Rpc_packer.packed_value</a> * <a href="Rpc_transport.html#TYPEsockaddr">sockaddr</a>)<br>                  <a href="Rpc_transport.html#TYPEresult_eof">result_eof</a> -> unit) -><br>       unit -> unit</code></pre><div class="info">
Start reading from the connection. When a whole message has been
 received, the <code class="code">when_done</code> callback is invoked. 
<p>

 This starts one-time read job only, i.e. it is not restarted
 after <code class="code">when_done</code> has been invoked.
<p>

 It is an error to start reading several times.
<p>

 <code class="code">peek</code>: This function is called immediately before a data chunk is
 read from the underlying data connection.
<p>

 <code class="code">before_record</code>: If passed, this function is called back whenever
 a record of data is started. The integer is the estimated size of the
 message in bytes. It is guaranteed that the function is
 invoked at least once before <code class="code">when_done</code>.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODskip_message"></a>skip_message : <code class="type">unit -> unit</code></pre><div class="info">
Skips the current/next received message, i.e. the <code class="code">when_done</code> callback
 will not be invoked for it.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODwriting"></a>writing : <code class="type">bool</code></pre><div class="info">
True iff there is a writer<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODstart_writing"></a>start_writing : <code class="type">when_done:(unit <a href="Rpc_transport.html#TYPEresult">result</a> -> unit) -><br>       <a href="Rpc_packer.html#TYPEpacked_value">Rpc_packer.packed_value</a> -> <a href="Rpc_transport.html#TYPEsockaddr">sockaddr</a> -> unit</code></pre><div class="info">
Starts writing the message. Invoked <code class="code">when_done</code> when it is written,
 or an error condition is reached.
<p>

 This starts one-time write job only, i.e. it is not restarted
 after <code class="code">when_done</code> has been invoked.
<p>

 It is an error to start writing several times.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODcancel_rd_polling"></a>cancel_rd_polling : <code class="type">unit -> unit</code></pre><div class="info">
Cancels polling for the next input message. This method must not be
 called from the <code class="code">before_record</code> callback function. Polling can be
 resumed by calling <code class="code">start_reading</code> again.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODabort_rw"></a>abort_rw : <code class="type">unit -> unit</code></pre><div class="info">
Aborts the current reader and/or writer forever. Note that there is no
 clean way of resuming reading and/or writing. The readers/writers
 are not notified about cancellation.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODstart_shutting_down"></a>start_shutting_down : <code class="type">when_done:(unit <a href="Rpc_transport.html#TYPEresult">result</a> -> unit) -> unit -> unit</code></pre><div class="info">
Start shutting down the connection. After going through the shutdown
 procedure, the <code class="code">when_done</code> callback is invoked reporting the success
 or failure.
<p>

 The underlying file descriptor (if any) is not closed. A shutdown
 is only a protocol handshake. After a shutdown,<code class="code">read_eof</code>
 is true. Call <code class="code">inactivate</code> to close the descriptor.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODcancel_shutting_down"></a>cancel_shutting_down : <code class="type">unit -> unit</code></pre><div class="info">
Cancels the shutdown procedure. After that, the state of the 
 connection is undefined. The <code class="code">when_done</code> callback is invoked with
 the <code class="code">`Cancelled</code>.
<p>

 It is no error if no shutdown is in progress.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODset_timeout"></a>set_timeout : <code class="type">notify:(unit -> unit) -> float -> unit</code></pre><div class="info">
If there is no read or write activity for the passed number of
 seconds, the <code class="code">notify</code> callback is invoked.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODinactivate"></a>inactivate : <code class="type">unit -> unit</code></pre><div class="info">
Inactivates the connection immediately, and releases any resources
 the controller is responsible for (e.g. closes file descriptors). 
 Note that this is more than
 cancelling all pending operations and shutting the connection down.
 However, the details of this method are implementation-defined.
 Callbacks are not invoked.<br>
</div>
</body></html>
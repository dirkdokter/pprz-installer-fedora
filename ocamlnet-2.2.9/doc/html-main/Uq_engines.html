<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Unixqueue.html">
<link rel="next" href="Uq_socks5.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Unixqueue_mt" rel="Chapter" href="Unixqueue_mt.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netstring_mt" rel="Chapter" href="Netstring_mt.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_mt" rel="Chapter" href="Shell_mt.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html"><link title="Exceptions" rel="Section" href="#1_Exceptions">
<link title="Engine definition" rel="Section" href="#1_Enginedefinition">
<link title="Generic functions and classes" rel="Section" href="#1_Genericfunctionsandclasses">
<link title="Fundamental engines" rel="Section" href="#1_Fundamentalengines">
<link title="Transfer engines" rel="Section" href="#1_Transferengines">
<link title="Socket engines" rel="Section" href="#1_Socketengines">
<link title="Multiplex Controllers" rel="Section" href="#1_MultiplexControllers">
<title>Ocamlnet 2 Reference Manual : Uq_engines</title>
</head>
<body>
<div class="navbar"><a href="Unixqueue.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Uq_socks5.html">Next</a>
</div>
<center><h1>Module <a href="type_Uq_engines.html">Uq_engines</a></h1></center>
<br>
<pre><span class="keyword">module</span> Uq_engines: <code class="code">sig</code> <a href="Uq_engines.html">..</a> <code class="code">end</code></pre>An <b>engine</b> performs a certain task in an autonomous way. Engines
 are attached to a <a href="Unixqueue.event_system.html"><code class="code">Unixqueue.event_system</code></a>, and do their task by
 generating events for resources of the operating system, and 
 by handling such events. Engines are in one of four states: They
 may be still <b>working</b>, they may be <b>done</b>, they may be
 <b>aborted</b>, or they may be in an <b>error</b> state. The three latter
 states a called <b>final states</b>, because they indicate that the
 engine has stopped operation.
<p>

 It is possible to ask an engine to notify another object when it
 changes its state. For simplicity, notification is done by invoking
 a callback function, and not by issuing notification events.<br>
<hr width="100%">
<br>
<b>THREAD SAFETY</b>
<p>

 Unclear.<br>
<br>
<a name="1_Exceptions"></a>
<h1>Exceptions</h1><br>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONClosed_channel"></a>Closed_channel</pre>
<div class="info">
Raised when a method of a closed channel object is called (only channel
 methods count).
<p>

 This exception should be regarded as equivalent to
 <code class="code">Netchannels.Closed_channel</code>, but it is not the same exception.<br>
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONBroken_communication"></a>Broken_communication</pre>
<div class="info">
Engines indicate this error when they cannot continue because the
 other endpoint of communication signals an error.
<p>

 This exception is not raised, but used as argument of the <code class="code">`Error</code>
 state.<br>
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONWatchdog_timeout"></a>Watchdog_timeout</pre>
<div class="info">
Used by the watchdog engine to indicate a timeout. 
<p>

 This exception is not raised, but used as argument of the <code class="code">`Error</code>
 state.<br>
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONAddressing_method_not_supported"></a>Addressing_method_not_supported</pre>
<div class="info">
Raised by <code class="code">client_socket_connector</code> and <code class="code">server_socket_acceptor</code> to
 indicate that the passed address is not supported by the class.<br>
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONCancelled"></a>Cancelled</pre>
<div class="info">
The callback function of a <code class="code">multiplex_controller</code> is invoked with this
 exception if the operation is cancelled.<br>
</div>
<br>
<a name="1_Enginedefinition"></a>
<h1>Engine definition</h1><br>
<pre><span class="keyword">type</span> <a name="TYPEengine_state"></a><code class="type">'a</code> engine_state = <code class="type">[ `Aborted | `Done of 'a | `Error of exn | `Working of int ]</code> </pre>
<div class="info">
The type of states with result values of type <code class="code">'t</code>:<ul>
<li><code class="code">`Working n</code>: The engine is working. The number <code class="code">n</code> counts the number
   of events that have been processed.</li>
<li><code class="code">`Done arg</code>: The engine has completed its task without errors. 
   The argument <code class="code">arg</code> is the result value of the engine</li>
<li><code class="code">`Error exn</code>: The engine has aborted because of an error. The
   argument <code class="code">exn</code> describes the error as an exception.</li>
<li><code class="code">`Aborted</code>: The engine has aborted because the <code class="code">abort</code> method
   was called</li>
</ul>
<br>
</div>

<pre><span class="keyword">class type</span> <a name="TYPEengine"></a><code class="type">['a]</code> <a href="Uq_engines.engine.html">engine</a> = <code class="code">object</code> <a href="Uq_engines.engine.html">..</a> <code class="code">end</code></pre><div class="info">
This class type defines the interface an engine must support.
</div>
<br>
<a name="1_Genericfunctionsandclasses"></a>
<h1>Generic functions and classes</h1><br>
<pre><span class="keyword">val</span> <a name="VALwhen_state"></a>when_state : <code class="type">?is_done:('a -> unit) -><br>       ?is_error:(exn -> unit) -><br>       ?is_aborted:(unit -> unit) -> 'a #<a href="Uq_engines.engine.html">engine</a> -> unit</code></pre><div class="info">
Watches the state of the argument engine, and arranges that one of
 the functions is called when a final state is reached. After the
 function has been called, the engine is no longer watched.
<p>

<br>
</div>
<div class="param_info"><code class="code">is_done</code> : The state transitions to <code class="code">`Done</code>. The argument of
   <code class="code">is_done</code> is the argument of the <code class="code">`Done</code> state.</div>
<div class="param_info"><code class="code">is_error</code> : The state transitions to <code class="code">`Error</code>. The argument of
   <code class="code">is_error</code> is the argument of the <code class="code">`Error</code> state.</div>
<div class="param_info"><code class="code">is_aborted</code> : The state transitions to <code class="code">`Aborted</code>.</div>
<pre><span class="keyword">class</span> <a name="TYPEmap_engine"></a><code class="type">[['a, 'b]]</code> <a href="Uq_engines.map_engine.html">map_engine</a> : <code class="type">map_done:('a -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a>) -> ?map_error:exn -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> ?map_aborted:unit -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> 'a #<a href="Uq_engines.engine.html">engine</a> -> </code><code class="type">['b]</code> <code class="type"><a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
The <code class="code">map_engine</code> observes the argument engine, and when the
 state changes to <code class="code">`Done</code>, <code class="code">`Error</code>, or <code class="code">`Aborted</code>, the corresponding
 mapping function is called, and the resulting state becomes the state
 of the mapped engine.
</div>
<pre><span class="keyword">class</span> <a name="TYPEepsilon_engine"></a><code class="type">['a]</code> <a href="Uq_engines.epsilon_engine.html">epsilon_engine</a> : <code class="type">'a <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
This engine transitions from its initial state <code class="code">`Working 0</code> in one
 step to the passed constant state.
</div>
<pre><span class="keyword">class</span> <a name="TYPEseq_engine"></a><code class="type">[['a, 'b]]</code> <a href="Uq_engines.seq_engine.html">seq_engine</a> : <code class="type">'a #<a href="Uq_engines.engine.html">engine</a> -> ('a -> 'b #<a href="Uq_engines.engine.html">engine</a>) -> </code><code class="type">['b]</code> <code class="type"><a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
This engine runs two engines in sequential order.
</div>
<pre><span class="keyword">class</span> <a name="TYPEsync_engine"></a><code class="type">[['a, 'b]]</code> <a href="Uq_engines.sync_engine.html">sync_engine</a> : <code class="type">'a #<a href="Uq_engines.engine.html">engine</a> -> 'b #<a href="Uq_engines.engine.html">engine</a> -> </code><code class="type">[('a * 'b)]</code> <code class="type"><a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
This engine runs two engines in parallel, and waits until both
 are <code class="code">`Done</code> (synchronization).
</div>
<br>
<a name="1_Fundamentalengines"></a>
<h1>Fundamental engines</h1><br>
<pre><span class="keyword">class</span> <a name="TYPEpoll_engine"></a><a href="Uq_engines.poll_engine.html">poll_engine</a> : <code class="type">?extra_match:exn -> bool -> (<a href="Unixqueue.html#TYPEoperation">Unixqueue.operation</a> * float) list -> <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> </code><code class="code">object</code> <a href="Uq_engines.poll_engine.html">..</a> <code class="code">end</code></pre><div class="info">
This engine waits until one of the passed operations can be 
 carried out, or until one of the operations times out.
</div>
<pre><span class="keyword">class</span> <a name="TYPEpoll_process_engine"></a><a href="Uq_engines.poll_process_engine.html">poll_process_engine</a> : <code class="type">?period:float -> pid:int -> <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> </code><code class="type">[Unix.process_status]</code> <code class="type"><a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
This engine waits until the process with the ID <code class="code">pid</code> terminates.
</div>
<pre><span class="keyword">class</span> <a name="TYPEwatchdog"></a><a href="Uq_engines.watchdog.html">watchdog</a> : <code class="type">float -> 'a #<a href="Uq_engines.engine.html">engine</a> -> </code><code class="type">[unit]</code> <code class="type"><a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
A watchdog engine checks whether the argument engine makes
 progress, and if there is no progress for the passed number of
 seconds, the engine is aborted, and the watchdog state changes
 to <code class="code">`Error Watchdog_timeout</code>.
</div>
<pre><span class="keyword">class</span> <a name="TYPEengine_mixin"></a><code class="type">['a]</code> <a href="Uq_engines.engine_mixin.html">engine_mixin</a> : <code class="type">'a <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> </code><code class="code">object</code> <a href="Uq_engines.engine_mixin.html">..</a> <code class="code">end</code></pre><div class="info">
A useful class fragment that implements <code class="code">state</code> and 
 <code class="code">request_notification</code>.
</div>
<br>
<a name="1_Transferengines"></a>
<h1>Transfer engines</h1><br>
<br>
Transfer engines copy data between file descriptors.<br>
<pre><span class="keyword">class type</span> <a name="TYPEasync_out_channel"></a><a href="Uq_engines.async_out_channel.html">async_out_channel</a> = <code class="code">object</code> <a href="Uq_engines.async_out_channel.html">..</a> <code class="code">end</code></pre><div class="info">
An asynchrounous output channel provides methods to output data to
 a stream descriptor.
</div>
<pre><span class="keyword">class type</span> <a name="TYPEasync_in_channel"></a><a href="Uq_engines.async_in_channel.html">async_in_channel</a> = <code class="code">object</code> <a href="Uq_engines.async_in_channel.html">..</a> <code class="code">end</code></pre><div class="info">
An asynchrounous input channel provides methods to input data from
 a stream descriptor.
</div>
<pre><span class="keyword">class</span> <a name="TYPEreceiver"></a><a href="Uq_engines.receiver.html">receiver</a> : <code class="type">src:Unix.file_descr -> dst:#<a href="Uq_engines.async_out_channel.html">async_out_channel</a> -> ?close_src:bool -> ?close_dst:bool -> <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> </code><code class="type">[unit]</code> <code class="type"><a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
This engine copies all data from the <code class="code">src</code> file descriptor to the
 <code class="code">dst</code> output channel.
</div>
<pre><span class="keyword">class</span> <a name="TYPEsender"></a><a href="Uq_engines.sender.html">sender</a> : <code class="type">src:#<a href="Uq_engines.async_in_channel.html">async_in_channel</a> -> dst:Unix.file_descr -> ?close_src:bool -> ?close_dst:bool -> <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> </code><code class="type">[unit]</code> <code class="type"><a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
This engine copies all data from the <code class="code">src</code> input channel to the
 <code class="code">dst</code> file descriptor.
</div>
<pre><span class="keyword">class type</span> <a name="TYPEasync_out_channel_engine"></a><a href="Uq_engines.async_out_channel_engine.html">async_out_channel_engine</a> = <code class="code">object</code> <a href="Uq_engines.async_out_channel_engine.html">..</a> <code class="code">end</code></pre><div class="info">
Combination of engine + async_out_channel
</div>
<pre><span class="keyword">class type</span> <a name="TYPEasync_in_channel_engine"></a><a href="Uq_engines.async_in_channel_engine.html">async_in_channel_engine</a> = <code class="code">object</code> <a href="Uq_engines.async_in_channel_engine.html">..</a> <code class="code">end</code></pre><div class="info">
Combination of engine + async_in_channel
</div>
<pre><span class="keyword">class</span> <a name="TYPEoutput_async_descr"></a><a href="Uq_engines.output_async_descr.html">output_async_descr</a> : <code class="type">dst:Unix.file_descr -> ?buffer_size:int -> ?close_dst:bool -> <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> </code><code class="type"><a href="Uq_engines.async_out_channel_engine.html">async_out_channel_engine</a></code></pre><div class="info">
This engine implements an <code class="code">async_out_channel</code> for the output
 descriptor <code class="code">dst</code>.
</div>
<pre><span class="keyword">class</span> <a name="TYPEinput_async_descr"></a><a href="Uq_engines.input_async_descr.html">input_async_descr</a> : <code class="type">src:Unix.file_descr -> ?buffer_size:int -> ?close_src:bool -> <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> </code><code class="type"><a href="Uq_engines.async_in_channel_engine.html">async_in_channel_engine</a></code></pre><div class="info">
The corresponding class for asynchronous input channels.
</div>
<pre><span class="keyword">type</span> <a name="TYPEcopy_task"></a><code class="type"></code>copy_task = <code class="type">[ `Bidirectional of Unix.file_descr * Unix.file_descr<br>       | `Tridirectional of Unix.file_descr * Unix.file_descr * Unix.file_descr<br>       | `Uni_socket of Unix.file_descr * Unix.file_descr<br>       | `Unidirectional of Unix.file_descr * Unix.file_descr ]</code> </pre>
<div class="info">
Specifies the task the <code class="code">copier</code> class has to do:
<p>
<ul>
<li><code class="code">`Unidirectional(src,dst)</code>: Data from <code class="code">src</code> are copied to <code class="code">dst</code>.
   EOF of <code class="code">src</code> causes that both descriptors are closed.</li>
<li><code class="code">`Uni_socket(src,dst)</code>: Data from <code class="code">src</code> are copied to <code class="code">dst</code>.
   EOF of <code class="code">src</code> causes that <code class="code">dst</code> is shut down for sending; all descriptors
   remain open. It is required that <code class="code">dst</code> is a socket.</li>
<li><code class="code">`Bidirectional(bi1,bi2)</code>: Data from <code class="code">bi1</code> are copied to <code class="code">bi2</code>,
   and data from <code class="code">bi2</code> are copied to <code class="code">bi1</code>. EOF of one descriptor
   causes that the other descriptor is shut down for sending.
   When both descriptors are at EOF, both are closed.
   It is required that <code class="code">bi1</code> and <code class="code">bi2</code> are sockets.</li>
<li><code class="code">`Tridirectional(bi,dst,src)</code>: Data from <code class="code">bi</code> are copied to <code class="code">dst</code>,
   and data from <code class="code">src</code> are copied to <code class="code">bi</code> (i.e. a bidirectional
   descriptor is split up into two unidirectional descriptors). 
   EOF of <code class="code">bi</code> causes that <code class="code">dst</code> is closed. EOF of <code class="code">src</code> causes
   that <code class="code">bi</code> is shut down for sending. EOF in both directions 
   causes that all descriptors are closed. It is required that
   <code class="code">bi</code> is a socket.</li>
</ul>
<br>
</div>

<pre><span class="keyword">class</span> <a name="TYPEcopier"></a><a href="Uq_engines.copier.html">copier</a> : <code class="type"><a href="Uq_engines.html#TYPEcopy_task">copy_task</a> -> <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> </code><code class="type">[unit]</code> <code class="type"><a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
This engine copies data between file descriptors as specified by
 the <code class="code">copy_task</code> argument.
</div>
<br>
<a name="1_Socketengines"></a>
<h1>Socket engines</h1><br>
<pre><span class="keyword">type</span> <a name="TYPEsockspec"></a><code class="type"></code>sockspec = <code class="type">[ `Sock_inet of Unix.socket_type * Unix.inet_addr * int<br>       | `Sock_inet_byname of Unix.socket_type * string * int<br>       | `Sock_unix of Unix.socket_type * string ]</code> </pre>
<div class="info">
Extended names for socket addresses. Currently, these naming schemes
 are supported:<ul>
<li><code class="code">`Sock_unix(stype,path)</code>: Names the Unix domain socket at <code class="code">path</code>.
   The socket type <code class="code">stype</code> is an auxiliary piece of information, but
   not a distinguishing part of the name. <code class="code">path = ""</code> refers to 
   anonymous sockets. Otherwise, the <code class="code">path</code> must be an absolute path name.</li>
<li><code class="code">`Sock_inet(stype,addr,port)</code>: Names the Internet socket of type
   <code class="code">stype</code> bound to the IP address <code class="code">addr</code> and the <code class="code">port</code>.
   If <code class="code">stype = Unix.SOCK_STREAM</code>, a TCP socket is meant, and if 
   <code class="code">stype = Unix.SOCK_DGRAM</code>, a UDP socket is meant. It is allowed
   that <code class="code">addr = Unix.inet_addr_any</code>. If <code class="code">port = 0</code>, the name is to
   be considered as incomplete.</li>
<li><code class="code">`Sock_inet_byname(stype,name,port)</code>: Names the Internet socket of
   type <code class="code">stype</code> bound to the IP address corresponding to the 
   <code class="code">name</code>, and bound to the <code class="code">port</code>. It is unspecified which naming
   service is used to resolve <code class="code">name</code> to an IP address, and how it is
   used. If the <code class="code">name</code> cannot be resolved, no socket is meant; this
   is usually an error. <code class="code">stype</code> is interpreted as for <code class="code">`Sock_inet</code>.
   If <code class="code">port = 0</code>, the name is to be considered as incomplete.</li>
</ul>

 It is currently not possible to name IP sockets that are bound to
 several IP addresses but not all IP addresses of the host.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEconnect_address"></a><code class="type"></code>connect_address = <code class="type">[ `Command of string * (int -> <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> unit)<br>       | `Socket of <a href="Uq_engines.html#TYPEsockspec">sockspec</a> * <a href="Uq_engines.html#TYPEconnect_options">connect_options</a> ]</code> </pre>
<div class="info">
Specifies the service to connect to:
<p>

 <ul>
<li><code class="code">`Socket(addr,opts)</code>: Connect to the passed socket address</li>
<li><code class="code">`Command(cmd,handler)</code>: The <code class="code">cmd</code> is started with the shell, 
   and <code class="code">stdin</code> and <code class="code">stdout</code> are used to transfer data to the
   process and from the process, respectively. Only <code class="code">SOCK_STREAM</code>
   type is supported. Note that the passed file descriptors are
   normal pipes, not sockets (so the descriptors can be individually
   closed).
<p>

   There is not any kind of error detection, so the command should
   be failsafe. <code class="code">stderr</code> of the command is connected with <code class="code">stderr</code> of
   the caller process.
<p>

   No provisions are taken to wait for the process; this is the
   task of the caller. After the process has been started, the
   <code class="code">handler</code> is invoked with the process ID and the event system
   to give the caller a chance to arrange that the process will be
   waited for.</li>
</ul>
<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEconnect_options"></a><code class="type"></code>connect_options = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>conn_bind&nbsp;: <code class="type"><a href="Uq_engines.html#TYPEsockspec">sockspec</a> option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Bind the connecting socket to this address (same family as the
 connected socket required). <code class="code">None</code>: Use an anonymous port.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}


<pre><span class="keyword">val</span> <a name="VALdefault_connect_options"></a>default_connect_options : <code class="type"><a href="Uq_engines.html#TYPEconnect_options">connect_options</a></code></pre><div class="info">
Returns the default options<br>
</div>
<pre><span class="keyword">type</span> <a name="TYPEconnect_status"></a><code class="type"></code>connect_status = <code class="type">[ `Command of Unix.file_descr * int<br>       | `Socket of Unix.file_descr * <a href="Uq_engines.html#TYPEsockspec">sockspec</a> ]</code> </pre>
<div class="info">
This type corresponds with <a href="Uq_engines.html#TYPEconnect_address"><code class="code">Uq_engines.connect_address</code></a>: An engine
 connecting with an address `X will return a status of `X.
<p>
<ul>
<li><code class="code">`Socket(fd,addr)</code>: <code class="code">fd</code> is the client socket connected with the
   service. <code class="code">addr</code> is the socket address of the client that must be
   used by the server to reach the client.</li>
<li><code class="code">`Command(fd, pid)</code>: <code class="code">fd</code> is the Unix domain socket connected with
   the running command. <code class="code">pid</code> is the process ID.</li>
</ul>
<br>
</div>

<pre><span class="keyword">val</span> <a name="VALclient_socket"></a>client_socket : <code class="type"><a href="Uq_engines.html#TYPEconnect_status">connect_status</a> -> Unix.file_descr</code></pre><div class="info">
Returns the client socket contained in the <code class="code">connect_status</code><br>
</div>
<pre><span class="keyword">type</span> <a name="TYPElisten_address"></a><code class="type"></code>listen_address = <code class="type">[ `Socket of <a href="Uq_engines.html#TYPEsockspec">sockspec</a> * <a href="Uq_engines.html#TYPElisten_options">listen_options</a> ]</code> </pre>
<div class="info">
Specifies the resource to listen on:
<p>
<ul>
<li><code class="code">`Socket(addr,opts)</code>: It is listened on a socket with address <code class="code">addr</code></li>
</ul>
<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPElisten_options"></a><code class="type"></code>listen_options = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>lstn_backlog&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The length of the queue of not yet accepted
 connections.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>lstn_reuseaddr&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Whether to allow that the address can be
 immediately reused after the previous listener
 has its socket shut down</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}


<pre><span class="keyword">val</span> <a name="VALdefault_listen_options"></a>default_listen_options : <code class="type"><a href="Uq_engines.html#TYPElisten_options">listen_options</a></code></pre><div class="info">
Returns the default options<br>
</div>
<pre><span class="keyword">class type</span> <a name="TYPEclient_socket_connector"></a><a href="Uq_engines.client_socket_connector.html">client_socket_connector</a> = <code class="code">object</code> <a href="Uq_engines.client_socket_connector.html">..</a> <code class="code">end</code></pre><div class="info">
This class type provides engines to connect to a service.
</div>
<pre><span class="keyword">class type</span> <a name="TYPEserver_socket_acceptor"></a><a href="Uq_engines.server_socket_acceptor.html">server_socket_acceptor</a> = <code class="code">object</code> <a href="Uq_engines.server_socket_acceptor.html">..</a> <code class="code">end</code></pre><div class="info">
This class type is for service providers that listen for connections.
</div>
<pre><span class="keyword">class</span> <a name="TYPEdirect_socket_acceptor"></a><a href="Uq_engines.direct_socket_acceptor.html">direct_socket_acceptor</a> : <code class="type">Unix.file_descr -> <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> </code><code class="type"><a href="Uq_engines.server_socket_acceptor.html">server_socket_acceptor</a></code></pre><div class="info">
An implementation of <code class="code">server_socket_acceptor</code> for sockets
</div>
<pre><span class="keyword">class type</span> <a name="TYPEserver_socket_listener"></a><a href="Uq_engines.server_socket_listener.html">server_socket_listener</a> = <code class="code">object</code> <a href="Uq_engines.server_socket_listener.html">..</a> <code class="code">end</code></pre><div class="info">
This class type represents factories for service providers
</div>
<pre><span class="keyword">val</span> <a name="VALconnector"></a>connector : <code class="type">?proxy:#<a href="Uq_engines.client_socket_connector.html">client_socket_connector</a> -><br>       <a href="Uq_engines.html#TYPEconnect_address">connect_address</a> -><br>       <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> <a href="Uq_engines.html#TYPEconnect_status">connect_status</a> <a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
This engine connects to a socket as specified by the <code class="code">connect_address</code>,
 optionally using the <code class="code">proxy</code>, and changes to the state
 <code class="code">`Done(status)</code> when the connection is established.
<p>

 If the <code class="code">proxy</code> does not support the <code class="code">connect_address</code>, the class 
 will raise <code class="code">Addressing_method_not_supported</code>.
<p>

 The descriptor <code class="code">fd</code> (part of the <code class="code">connect_status</code>) is in non-blocking mode,
 and the close-on-exec flag is set.
 It is the task of the caller to close this descriptor.
<p>

 The engine attaches automatically to the event system, and detaches
 when it is possible to do so. This depends on the type of the
 connection method. For direct socket connections, the engine can
 often detach immediately when the conection is established. For proxy
 connections it is required that the engine
 copies data to and from the file descriptor. In this case, the
 engine detaches when the file descriptor is closed.
<p>

 It is possible that name service queries block execution.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlistener"></a>listener : <code class="type">?proxy:#<a href="Uq_engines.server_socket_listener.html">server_socket_listener</a> -><br>       <a href="Uq_engines.html#TYPElisten_address">listen_address</a> -><br>       <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> <a href="Uq_engines.server_socket_acceptor.html">server_socket_acceptor</a> <a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
This engine creates a server socket listening on the <code class="code">listen_address</code>.
 If passed, the <code class="code">proxy</code> is used to create the server socket.
<p>

 On success, the engine goes to state <code class="code">`Done acc</code>, where <code class="code">acc</code> is
 the acceptor object (see above). The acceptor object can be used
 to accept incoming connections.<br>
</div>
<pre><span class="keyword">type</span> <a name="TYPEdatagram_type"></a><code class="type"></code>datagram_type = <code class="type">[ `Inet6_udp | `Inet_udp | `Unix_dgram ]</code> </pre>
<div class="info">
- <code class="code">`Unix_dgram</code>: Datagrams over Unix domain sockets<ul>
<li><code class="code">`Inet_udp</code>:   Internet v4 UDP protocol</li>
<li><code class="code">`Inet6_udp</code>:   Internet v6 UDP protocol</li>
</ul>
<br>
</div>

<pre><span class="keyword">class type</span> <a name="TYPEwrapped_datagram_socket"></a><a href="Uq_engines.wrapped_datagram_socket.html">wrapped_datagram_socket</a> = <code class="code">object</code> <a href="Uq_engines.wrapped_datagram_socket.html">..</a> <code class="code">end</code></pre><div class="info">
A <code class="code">wrapped_datagram_socket</code> allows datagrams to be sent via proxies.
</div>
<pre><span class="keyword">class type</span> <a name="TYPEdatagram_socket_provider"></a><a href="Uq_engines.datagram_socket_provider.html">datagram_socket_provider</a> = <code class="code">object</code> <a href="Uq_engines.datagram_socket_provider.html">..</a> <code class="code">end</code></pre><div class="info">
This is a factory for <code class="code">wrapped_datagram_socket</code> objects.
</div>
<pre><span class="keyword">val</span> <a name="VALdatagram_provider"></a>datagram_provider : <code class="type">?proxy:#<a href="Uq_engines.datagram_socket_provider.html">datagram_socket_provider</a> -><br>       <a href="Uq_engines.html#TYPEdatagram_type">datagram_type</a> -><br>       <a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -><br>       <a href="Uq_engines.wrapped_datagram_socket.html">wrapped_datagram_socket</a> <a href="Uq_engines.engine.html">engine</a></code></pre><div class="info">
This engine creates a datagram socket as demanded by the <code class="code">datagram_type</code>,
 optionally using <code class="code">proxy</code> for sending and receiving datagrams.
<p>

 The socket is unconnected.
<p>

 The socket is in non-blocking mode, and the close-on-exec flag is 
 set.<br>
</div>
<br>
<a name="1_MultiplexControllers"></a>
<h1>Multiplex Controllers</h1><br>
<pre><span class="keyword">class type</span> <a name="TYPEmultiplex_controller"></a><a href="Uq_engines.multiplex_controller.html">multiplex_controller</a> = <code class="code">object</code> <a href="Uq_engines.multiplex_controller.html">..</a> <code class="code">end</code></pre><div class="info">
A <code class="code">multiplex_controller</code> is a quite low-level device to abstract
 bidirectional socket connections.
</div>
<pre><span class="keyword">val</span> <a name="VALcreate_multiplex_controller_for_connected_socket"></a>create_multiplex_controller_for_connected_socket : <code class="type">?close_inactive_descr:bool -><br>       ?supports_half_open_connection:bool -><br>       Unix.file_descr -><br>       <a href="Unixqueue.unix_event_system.html">Unixqueue.unix_event_system</a> -> <a href="Uq_engines.multiplex_controller.html">multiplex_controller</a></code></pre><div class="info">
Creates a multiplex controller for a bidirectional socket (e.g.
 a TCP socket). It is essential that the socket is in connected state.
<p>

 Note that the file descriptor is not closed when the attached engines
 are terminated. One can call <code class="code">inactivate</code> manually to do that.
<p>

 <code class="code">close_inactive_descr</code>: Whether <code class="code">inactivate</code> closes the descriptor.
 True by default.
<p>

 <code class="code">supports_half_open_connection</code>: This implementation does not know
 how to find out whether the socket supports half-open connections.
 You can simply set this boolean because of this. Defaults to <code class="code">false</code>.
 You can set it to <code class="code">true</code> for TCP connections and for Unix-domain
 connections with stream semantics.<br>
</div>
<pre><span class="keyword">class type</span> <a name="TYPEdatagram_multiplex_controller"></a><a href="Uq_engines.datagram_multiplex_controller.html">datagram_multiplex_controller</a> = <code class="code">object</code> <a href="Uq_engines.datagram_multiplex_controller.html">..</a> <code class="code">end</code></pre><div class="info">
Additional methods for unconnected datagram handling
</div>
<pre><span class="keyword">val</span> <a name="VALcreate_multiplex_controller_for_datagram_socket"></a>create_multiplex_controller_for_datagram_socket : <code class="type">?close_inactive_descr:bool -><br>       Unix.file_descr -><br>       <a href="Unixqueue.unix_event_system.html">Unixqueue.unix_event_system</a> -> <a href="Uq_engines.datagram_multiplex_controller.html">datagram_multiplex_controller</a></code></pre><div class="info">
Creates a multiplex controller for datagram sockets (e.g. UDP socket).
<p>

 Note that the file descriptor is not closed when the attached engines
 are terminated. One can call <code class="code">inactivate</code> manually to do that.
<p>

 <code class="code">close_inactive_descr</code>: Whether <code class="code">inactivate</code> closes the descriptor.
 True by default.<br>
</div>
<pre><span class="keyword">type</span> <a name="TYPEonshutdown_out_spec"></a><code class="type"></code>onshutdown_out_spec = <code class="type">[ `Action of<br>           <a href="Uq_engines.async_out_channel_engine.html">async_out_channel_engine</a> -><br>           <a href="Uq_engines.multiplex_controller.html">multiplex_controller</a> -> unit <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> unit<br>       | `Ignore<br>       | `Initiate_shutdown ]</code> </pre>
<div class="info">
See class <code class="code">output_async_mplex</code> for explanations<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEonshutdown_in_spec"></a><code class="type"></code>onshutdown_in_spec = <code class="type">[ `Action of<br>           <a href="Uq_engines.async_in_channel_engine.html">async_in_channel_engine</a> -><br>           <a href="Uq_engines.multiplex_controller.html">multiplex_controller</a> -> unit <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> unit<br>       | `Ignore<br>       | `Initiate_shutdown ]</code> </pre>
<div class="info">
See class <code class="code">input_async_mplex</code> for explanations<br>
</div>

<pre><span class="keyword">class</span> <a name="TYPEoutput_async_mplex"></a><a href="Uq_engines.output_async_mplex.html">output_async_mplex</a> : <code class="type">?onclose:[ `Ignore | `Write_eof ] -> ?onshutdown:<a href="Uq_engines.html#TYPEonshutdown_out_spec">onshutdown_out_spec</a> -> ?buffer_size:int -> <a href="Uq_engines.multiplex_controller.html">multiplex_controller</a> -> </code><code class="type"><a href="Uq_engines.async_out_channel_engine.html">async_out_channel_engine</a></code></pre><div class="info">
Creates an asynchronous output channel writing to the multiplex
 controller (see also <code class="code">output_async_descr</code> for the corresponding
 class writing to a single descriptor).
</div>
<pre><span class="keyword">class</span> <a name="TYPEinput_async_mplex"></a><a href="Uq_engines.input_async_mplex.html">input_async_mplex</a> : <code class="type">?onshutdown:<a href="Uq_engines.html#TYPEonshutdown_in_spec">onshutdown_in_spec</a> -> ?buffer_size:int -> <a href="Uq_engines.multiplex_controller.html">multiplex_controller</a> -> </code><code class="type"><a href="Uq_engines.async_in_channel_engine.html">async_in_channel_engine</a></code></pre><div class="info">
Creates an asynchronous input channel reading from the multiplex
 controller.
</div>
</body></html>
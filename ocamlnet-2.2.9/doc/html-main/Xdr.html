<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Rtypes.html">
<link rel="next" href="Rpc.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Unixqueue_mt" rel="Chapter" href="Unixqueue_mt.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netstring_mt" rel="Chapter" href="Netstring_mt.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_mt" rel="Chapter" href="Shell_mt.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html"><title>Ocamlnet 2 Reference Manual : Xdr</title>
</head>
<body>
<div class="navbar"><a href="Rtypes.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Rpc.html">Next</a>
</div>
<center><h1>Module <a href="type_Xdr.html">Xdr</a></h1></center>
<br>
<pre><span class="keyword">module</span> Xdr: <code class="code">sig</code> <a href="Xdr.html">..</a> <code class="code">end</code></pre>External Data Representation<br>
<hr width="100%">
<br>
This module supports the "external data representation", or XDR
 for short. XDR is a means to pack structured values as strings and
 it serves to transport such values across character streams even
 between computers with different architectures.
<p>

 XDR values must be formed according to an XDR type. Such types are
 usually written in a notation that is close to the C notation of
 structured types. There are some important details where XDR is
 better than C:<ul>
<li>direct support for strings</li>
<li>arrays may have fixed or variable length</li>
<li>unions must have a discriminator</li>
<li>no pointers. The notation <code class="code">*t</code> is allowed, but means something
   different, namely "t option" in O'Caml notation.</li>
<li>recursive types are possible and behave like recursive types in
   O'Caml. For example,
   <pre><code class="code">     struct *list {
       int value;
       next list;
     }
   </code></pre>
   is a list of integer values and equivalent to
   <pre><code class="code">     type intlist = intlist_el option
      and intlist_el = { value : int; next : intlist }
   </code></pre></li>
</ul>

 See RFC 1014 for details about XDR.
<p>

 This module defines:<ul>
<li>XDR types</li>
<li>XDR type terms</li>
<li>XDR type systems</li>
<li>XDR type term systems</li>
</ul>

 In "type terms" you can see the components from which the type has been
 formed, while a "type" is an opaque representation that has been checked
 and for that some preprocessing has been done.
<p>

 A "type system" is a collection of several types that have names and that
 can refer to previously defined types (i.e. a sequence of "typedef"s).
 As with simple types, there is an extensive and an opaque representation.
<p>

 A typical way of using this module is to define an "XDR type term system"
 by simply writing an O'Caml expression. After that, this system is validated
 and you get the "type system". From now on, you can refer to the types
 defined in the system by name and get the corresponding "XDR types".
 Once you have an XDR type you can use it to pack or unpack an XDR value.<br>
<br>
Terms that describe possible XDR types:
<p>
<ul>
<li><code class="code">X_int</code>:                      integer (32 bit)</li>
<li><code class="code">X_uint</code>:                     unsigned integer</li>
<li><code class="code">X_hyper</code>:                    hyper (64 bit signed integer)</li>
<li><code class="code">X_uhyper</code>:                   unsigned hyper</li>
<li><code class="code">X_enum [x1,i1; ...]</code>:        <code class="code">enum { x1 = i1, ... }</code></li>
<li><code class="code">X_float</code>:                    float (32 bit fp number)</li>
<li><code class="code">X_double</code>:                   double (64 bit fp number)</li>
<li><code class="code">X_opaque_fixed n</code>:           <code class="code">opaque[n]</code></li>
<li><code class="code">X_opaque n</code>:                 <code class="code">opaque&lt;n&gt;</code></li>
<li><code class="code">X_string n</code>:                 <code class="code">string&lt;n&gt;</code></li>
<li><code class="code">X_array_fixed (t,n)</code>:        <code class="code">t[n]</code></li>
<li><code class="code">X_array (t,n)</code>:              <code class="code">t&lt;n&gt;</code></li>
<li><code class="code">X_struct [x1,t1;...]</code>:       <code class="code">struct { t1 x1; ...}</code></li>
<li><code class="code">X_union_over_int
     ([n1,t1;...], None)</code>:       <code class="code">union switch(int) {case n1: t1; ...}</code></li>
<li><code class="code">X_union_over_int
     ([n1,t1;...], Some t)</code>:     <code class="code">union switch(int) {case n1: t1; ...; default t}</code></li>
<li><code class="code">X_union_over_uint
     ([n1,t1;...], None)</code>:       <code class="code">union switch(unsigned int) {case n1: t1; ...}</code></li>
<li><code class="code">X_union_over_uint
     ([n1,t1;...], Some t)</code>:     <code class="code">union switch(unsigned int)
                                 {case n1: t1; ...; default t}</code></li>
<li><code class="code">X_union_over_enum
     (e, [n1,t1;...], None)</code>:    <code class="code">union switch(e) {case n1:t1; ...}</code>
                                 where e is an enumeration type</li>
<li><code class="code">X_union_over_enum
     (e, [n1,t1;...], Some t)</code>:  <code class="code">union switch(e) {case n1:t1; ...; default t}</code>
                                 where e is an enumeration type</li>
<li><code class="code">X_void</code>:                     void</li>
</ul>

 The <code class="code">X_type</code> constructor is only useful for types interpreted relative to
 a type system. Then it refers to a named type in this system.
<p>

 The <code class="code">X_param</code> constructor includes a reference to an arbitrary type
 which must only be given while packing or unpacking values.
 (A "lazy" type reference.)
<p>

 Example how to define a recursive type:
<p>

 <code class="code">X_rec ("a", X_array ( X_struct ["value", X_int; "next", X_refer "a"], 1))</code><br>
<br><code><span class="keyword">type</span> <a name="TYPExdr_type_term"></a><code class="type"></code>xdr_type_term = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_int</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_uint</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_hyper</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_uhyper</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_enum</span> <span class="keyword">of</span> <code class="type">(string * <a href="Rtypes.html#TYPEint4">Rtypes.int4</a>) list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_float</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_double</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_opaque_fixed</span> <span class="keyword">of</span> <code class="type"><a href="Rtypes.html#TYPEuint4">Rtypes.uint4</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_opaque</span> <span class="keyword">of</span> <code class="type"><a href="Rtypes.html#TYPEuint4">Rtypes.uint4</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_string</span> <span class="keyword">of</span> <code class="type"><a href="Rtypes.html#TYPEuint4">Rtypes.uint4</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_array_fixed</span> <span class="keyword">of</span> <code class="type"><a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a> * <a href="Rtypes.html#TYPEuint4">Rtypes.uint4</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_array</span> <span class="keyword">of</span> <code class="type"><a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a> * <a href="Rtypes.html#TYPEuint4">Rtypes.uint4</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_struct</span> <span class="keyword">of</span> <code class="type">(string * <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a>) list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_union_over_int</span> <span class="keyword">of</span> <code class="type">(<a href="Rtypes.html#TYPEint4">Rtypes.int4</a> * <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a>) list * <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a> option</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_union_over_uint</span> <span class="keyword">of</span> <code class="type">(<a href="Rtypes.html#TYPEuint4">Rtypes.uint4</a> * <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a>) list * <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a> option</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_union_over_enum</span> <span class="keyword">of</span> <code class="type"><a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a> * (string * <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a>) list<br>        * <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a> option</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_void</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_type</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_param</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_rec</span> <span class="keyword">of</span> <code class="type">(string * <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a>)</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">X_refer</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr></table>


<pre><span class="keyword">type</span> <a name="TYPExdr_type"></a><code class="type"></code>xdr_type </pre>
<div class="info">
This is the validated version of <code class="code">xdr_type_term</code>. Note that it does not
 contain <code class="code">X_type</code> constructors, i.e. is completely expanded.
 It is allowed that an <code class="code">xdr_type</code> contains <code class="code">X_param</code> constructors (parameters).
 The set of occurring parameters can be determined very quickly for an
 <code class="code">xdr_type</code>.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPExdr_type_term_system"></a><code class="type"></code>xdr_type_term_system = <code class="type">(string * <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a>) list</code> </pre>
<div class="info">
Bind names to types. In a correct system you can only refer to
 previously defined types, i.e. the type called <code class="code">n</code> must be defined
 in the list before it can be used via <code class="code">X_type n</code>.
 It is possible to use this module without the means of type
 systems, but often code is more readable if types are defined
 in an environment allowing bindings to names.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPExdr_type_system"></a><code class="type"></code>xdr_type_system </pre>
<div class="info">
A validated type system.<br>
</div>

<pre><span class="keyword">val</span> <a name="VALx_bool"></a>x_bool : <code class="type"><a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a></code></pre><div class="info">
Common abbreviation for boolean types. Has values <code class="code">xv_true</code> and <code class="code">xv_false</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALx_optional"></a>x_optional : <code class="type"><a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a> -> <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a></code></pre><div class="info">
Common abbreviation for optional types. Has values <code class="code">xv_none</code> and
 <code class="code">xv_some v</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALx_opaque_max"></a>x_opaque_max : <code class="type"><a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a></code></pre><div class="info">
Common abbreviation for opaque data of arbitrary length<br>
</div>
<pre><span class="keyword">val</span> <a name="VALx_string_max"></a>x_string_max : <code class="type"><a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a></code></pre><div class="info">
Common abbreviation for strings of arbitrary length<br>
</div>
<pre><span class="keyword">val</span> <a name="VALx_array_max"></a>x_array_max : <code class="type"><a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a> -> <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a></code></pre><div class="info">
Common abbreviation for arrays of arbitrary length<br>
</div>
<br>
Values possible for XDR types. This is straight-forward, except the
 "_fast" variants:<br>
<br><code><span class="keyword">type</span> <a name="TYPExdr_value"></a><code class="type"></code>xdr_value = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_int</span> <span class="keyword">of</span> <code class="type"><a href="Rtypes.html#TYPEint4">Rtypes.int4</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_uint</span> <span class="keyword">of</span> <code class="type"><a href="Rtypes.html#TYPEuint4">Rtypes.uint4</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_hyper</span> <span class="keyword">of</span> <code class="type"><a href="Rtypes.html#TYPEint8">Rtypes.int8</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_uhyper</span> <span class="keyword">of</span> <code class="type"><a href="Rtypes.html#TYPEuint8">Rtypes.uint8</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_enum</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_float</span> <span class="keyword">of</span> <code class="type"><a href="Rtypes.html#TYPEfp4">Rtypes.fp4</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_double</span> <span class="keyword">of</span> <code class="type"><a href="Rtypes.html#TYPEfp8">Rtypes.fp8</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_opaque</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_string</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_array</span> <span class="keyword">of</span> <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> array</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_struct</span> <span class="keyword">of</span> <code class="type">(string * <a href="Xdr.html#TYPExdr_value">xdr_value</a>) list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_union_over_int</span> <span class="keyword">of</span> <code class="type">(<a href="Rtypes.html#TYPEint4">Rtypes.int4</a> * <a href="Xdr.html#TYPExdr_value">xdr_value</a>)</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_union_over_uint</span> <span class="keyword">of</span> <code class="type">(<a href="Rtypes.html#TYPEuint4">Rtypes.uint4</a> * <a href="Xdr.html#TYPExdr_value">xdr_value</a>)</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_union_over_enum</span> <span class="keyword">of</span> <code class="type">(string * <a href="Xdr.html#TYPExdr_value">xdr_value</a>)</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_void</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_enum_fast</span> <span class="keyword">of</span> <code class="type">int</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The integer is the _position_ in the <code class="code">X_enum</code> list, sorted by
 enum values (ascending). For example, if we have
 <code class="code">X_enum [ "A", 4; "B", 2; "C", 6 ]</code>
 the element "B" has the position 0, because 2 is the lowest
 number</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_struct_fast</span> <span class="keyword">of</span> <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> array</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The array elements are in the same order as declared in <code class="code">X_struct</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">XV_union_over_enum_fast</span> <span class="keyword">of</span> <code class="type">(int * <a href="Xdr.html#TYPExdr_value">xdr_value</a>)</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The integer is the _position_ in the <code class="code">X_enum</code> list. "position"
 means the same as for <code class="code">XV_enum_fast</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>


<pre><span class="keyword">val</span> <a name="VALxv_true"></a>xv_true : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a></code></pre><pre><span class="keyword">val</span> <a name="VALxv_false"></a>xv_false : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a></code></pre><div class="info">
See <code class="code">x_bool</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALxv_none"></a>xv_none : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a></code></pre><pre><span class="keyword">val</span> <a name="VALxv_some"></a>xv_some : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Xdr.html#TYPExdr_value">xdr_value</a></code></pre><div class="info">
See <code class="code">x_optional</code><br>
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONDest_failure"></a>Dest_failure</pre>
<div class="info">
raised if the dest_* function are applied to non-matching xdr_value<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdest_xv_int"></a>dest_xv_int : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Rtypes.html#TYPEint4">Rtypes.int4</a></code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_uint"></a>dest_xv_uint : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Rtypes.html#TYPEuint4">Rtypes.uint4</a></code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_hyper"></a>dest_xv_hyper : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Rtypes.html#TYPEint8">Rtypes.int8</a></code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_uhyper"></a>dest_xv_uhyper : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Rtypes.html#TYPEuint8">Rtypes.uint8</a></code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_enum"></a>dest_xv_enum : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_enum_fast"></a>dest_xv_enum_fast : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_float"></a>dest_xv_float : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Rtypes.html#TYPEfp4">Rtypes.fp4</a></code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_double"></a>dest_xv_double : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Rtypes.html#TYPEfp8">Rtypes.fp8</a></code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_opaque"></a>dest_xv_opaque : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_string"></a>dest_xv_string : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_array"></a>dest_xv_array : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Xdr.html#TYPExdr_value">xdr_value</a> array</code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_struct"></a>dest_xv_struct : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> (string * <a href="Xdr.html#TYPExdr_value">xdr_value</a>) list</code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_struct_fast"></a>dest_xv_struct_fast : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Xdr.html#TYPExdr_value">xdr_value</a> array</code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_union_over_int"></a>dest_xv_union_over_int : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Rtypes.html#TYPEint4">Rtypes.int4</a> * <a href="Xdr.html#TYPExdr_value">xdr_value</a></code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_union_over_uint"></a>dest_xv_union_over_uint : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Rtypes.html#TYPEuint4">Rtypes.uint4</a> * <a href="Xdr.html#TYPExdr_value">xdr_value</a></code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_union_over_enum"></a>dest_xv_union_over_enum : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> string * <a href="Xdr.html#TYPExdr_value">xdr_value</a></code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_union_over_enum_fast"></a>dest_xv_union_over_enum_fast : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> int * <a href="Xdr.html#TYPExdr_value">xdr_value</a></code></pre><pre><span class="keyword">val</span> <a name="VALdest_xv_void"></a>dest_xv_void : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALmap_xv_enum_fast"></a>map_xv_enum_fast : <code class="type"><a href="Xdr.html#TYPExdr_type">xdr_type</a> -> <a href="Xdr.html#TYPExdr_value">xdr_value</a> -> int32</code></pre><div class="info">
Works for both <code class="code">XV_enum</code> and <code class="code">XV_enum_fast</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALmap_xv_struct_fast"></a>map_xv_struct_fast : <code class="type"><a href="Xdr.html#TYPExdr_type">xdr_type</a> -> <a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Xdr.html#TYPExdr_value">xdr_value</a> array</code></pre><div class="info">
Works for both <code class="code">XV_struct</code> and <code class="code">XV_struct_fast</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALmap_xv_union_over_enum_fast"></a>map_xv_union_over_enum_fast : <code class="type"><a href="Xdr.html#TYPExdr_type">xdr_type</a> -> <a href="Xdr.html#TYPExdr_value">xdr_value</a> -> int * int32 * <a href="Xdr.html#TYPExdr_value">xdr_value</a></code></pre><div class="info">
Works for both <code class="code">XV_union_over_enum</code> and <code class="code">XV_union_over_enum_fast</code>.
 Returns the triple <code class="code">(k,i,x)</code>:<ul>
<li><code class="code">k</code>: Position of the selected value in the <code class="code">T_enum</code> array</li>
<li><code class="code">i</code>: value of the enum</li>
<li><code class="code">x</code>: selected arm of the union</li>
</ul>
<br>
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONXdr_format"></a>Xdr_format <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info">
Format error found during unpacking a string<br>
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONXdr_format_message_too_long"></a>Xdr_format_message_too_long <span class="keyword">of</span> <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a></code></pre>
<div class="info">
The message is too long and cannot be packed into a string<br>
</div>
<br>
You must use these two functions to obtain validated types and
 type systems. They fail with "validate_xdr_type" resp.
 "validate_xdr_type_system" if the parameters are incorrect.<br>
<pre><span class="keyword">val</span> <a name="VALvalidate_xdr_type"></a>validate_xdr_type : <code class="type"><a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a> -> <a href="Xdr.html#TYPExdr_type">xdr_type</a></code></pre><pre><span class="keyword">val</span> <a name="VALvalidate_xdr_type_system"></a>validate_xdr_type_system : <code class="type"><a href="Xdr.html#TYPExdr_type_term_system">xdr_type_term_system</a> -> <a href="Xdr.html#TYPExdr_type_system">xdr_type_system</a></code></pre><br>
Get the unvalidated version back:
<p>
<ul>
<li>Note that <code class="code">X_type</code> constructions are always resolved</li>
</ul>
<br>
<pre><span class="keyword">val</span> <a name="VALxdr_type_term"></a>xdr_type_term : <code class="type"><a href="Xdr.html#TYPExdr_type">xdr_type</a> -> <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a></code></pre><pre><span class="keyword">val</span> <a name="VALxdr_type_term_system"></a>xdr_type_term_system : <code class="type"><a href="Xdr.html#TYPExdr_type_system">xdr_type_system</a> -> <a href="Xdr.html#TYPExdr_type_term_system">xdr_type_term_system</a></code></pre><br>
You can expand any type term relative to a (validated) type system.
 For example:
   <code class="code">expanded_xdr_type sys1 (X_type "xy")</code>
 extracts the type called "xy" defined in sys1.
 Expansion removes all X_type constructions in a type term.<br>
<pre><span class="keyword">val</span> <a name="VALexpanded_xdr_type"></a>expanded_xdr_type : <code class="type"><a href="Xdr.html#TYPExdr_type_system">xdr_type_system</a> -> <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a> -> <a href="Xdr.html#TYPExdr_type">xdr_type</a></code></pre><pre><span class="keyword">val</span> <a name="VALexpanded_xdr_type_term"></a>expanded_xdr_type_term : <code class="type"><a href="Xdr.html#TYPExdr_type_term_system">xdr_type_term_system</a> -> <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a> -> <a href="Xdr.html#TYPExdr_type_term">xdr_type_term</a></code></pre><pre><span class="keyword">val</span> <a name="VALare_compatible"></a>are_compatible : <code class="type"><a href="Xdr.html#TYPExdr_type">xdr_type</a> -> <a href="Xdr.html#TYPExdr_type">xdr_type</a> -> bool</code></pre><div class="info">
are_compatible: currently not implemented<br>
</div>
<br>
Is the value properly formed with respect to this type? The third
 argument of this function is a list of parameter instances. Note that
 all parameters must be instantiated to compare a value with a type
 and that the parameters instances are not allowed to have parameters
 themselves.<br>
<pre><span class="keyword">val</span> <a name="VALvalue_matches_type"></a>value_matches_type : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Xdr.html#TYPExdr_type">xdr_type</a> -> (string * <a href="Xdr.html#TYPExdr_type">xdr_type</a>) list -> bool</code></pre><br>
<code class="code">pack_xdr_value v t p print</code>: Serialize v into a string conforming to
   the XDR standard where v matches t. In p the parameter instances are
   given. All parameters must be given, the parameters must not contain
   parameters themselves. The fourth argument, print, is a function
   which is evaluated for the pieces of the resultant string. You can use
   pack_xdr_value_as_string to get the whole string at once.
<p>

 <code class="code">unpack_xdr_value s t p</code>: Unserialize a string to a value
   matching t. If this operation fails you get an Xdr_format
   exception explaining what the reason for the failure is.
   Mostly the cause for failures is that t isn't the type
   of the value.
   Note that there are some implementation restrictions limiting
   the number of elements in array, strings and opaque fields.
   If you get such an error this normally still means that
   the value is not of the expected type, because these limits
   have no practical meaning (they are still higher than the
   usable address space).<br>
<pre><span class="keyword">val</span> <a name="VALpack_xdr_value"></a>pack_xdr_value : <code class="type"><a href="Xdr.html#TYPExdr_value">xdr_value</a> -><br>       <a href="Xdr.html#TYPExdr_type">xdr_type</a> -> (string * <a href="Xdr.html#TYPExdr_type">xdr_type</a>) list -> (string -> unit) -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpack_xdr_value_as_string"></a>pack_xdr_value_as_string : <code class="type">?rm:bool -><br>       <a href="Xdr.html#TYPExdr_value">xdr_value</a> -> <a href="Xdr.html#TYPExdr_type">xdr_type</a> -> (string * <a href="Xdr.html#TYPExdr_type">xdr_type</a>) list -> string</code></pre><div class="info">
rm: If true, four null bytes are prepended to the string for the
     record mark<br>
</div>
<pre><span class="keyword">val</span> <a name="VALunpack_xdr_value"></a>unpack_xdr_value : <code class="type">?pos:int -><br>       ?len:int -><br>       ?fast:bool -><br>       ?prefix:bool -><br>       string -> <a href="Xdr.html#TYPExdr_type">xdr_type</a> -> (string * <a href="Xdr.html#TYPExdr_type">xdr_type</a>) list -> <a href="Xdr.html#TYPExdr_value">xdr_value</a></code></pre><pre><span class="keyword">val</span> <a name="VALunpack_xdr_value_l"></a>unpack_xdr_value_l : <code class="type">?pos:int -><br>       ?len:int -><br>       ?fast:bool -><br>       ?prefix:bool -><br>       string -> <a href="Xdr.html#TYPExdr_type">xdr_type</a> -> (string * <a href="Xdr.html#TYPExdr_type">xdr_type</a>) list -> <a href="Xdr.html#TYPExdr_value">xdr_value</a> * int</code></pre><div class="info">
<code class="code">fast</code>: whether to prefer the new "fast" values (default: false)
<p>

 <code class="code">prefix</code>: whether it is ok that the string is longer than the message
   (default: false)
<p>

 The variant <code class="code">unpack_xdr_value_l</code> returns not only the decoded value,
 but also the actual length in bytes.<br>
</div>
</body></html>
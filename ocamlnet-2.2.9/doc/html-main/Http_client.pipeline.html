<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Http_client.digest_auth_method.html">
<link rel="Up" href="Http_client.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Unixqueue_mt" rel="Chapter" href="Unixqueue_mt.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netstring_mt" rel="Chapter" href="Netstring_mt.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_mt" rel="Chapter" href="Shell_mt.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html"><title>Ocamlnet 2 Reference Manual : Http_client.pipeline</title>
</head>
<body>
<div class="navbar"><a href="Http_client.digest_auth_method.html">Previous</a>
&nbsp;<a href="Http_client.html">Up</a>
&nbsp;</div>
<center><h1>Class <a href="type_Http_client.pipeline.html">Http_client.pipeline</a></h1></center>
<br>
<pre><span class="keyword">class</span> <a name="TYPEpipeline"></a>pipeline : <code class="type"></code><code class="code">object</code> <a href="Http_client.pipeline.html">..</a> <code class="code">end</code></pre>A pipeline is a queue of HTTP calls to perform<br>
<hr width="100%">
<a name="2_A"></a>
<h2>A </h2><code class="code">pipeline</code> object is a FIFO queue of HTTP calls. It is called
 "pipeline" because it is processed asynchronously: Requests may be
 sent to the HTTP server independently of whether responses of the
 previous requests already arrived or not.
<p>

 Furthermore, a <code class="code">pipeline</code> object may keep connections to several
 servers at once. (More exactly, it has a FIFO queue for every
 server it is connected with.)
<p>

 The <code class="code">pipeline</code> object keeps track what is happening, so you need
 not to care about the details of communications. The API is
 simple: Create a <code class="code">pipeline</code> object, do some setup (add authentication
 methods; configure the proxy to use), add the requests, and 
 <code class="code">run</code> the pipeline. The rest is done automatically. To get the results,
 you can either memorize the requests you wanted to know yourself
 and ask every request object about the reply of the server; or
 you can specify that a callback function should be called once
 the request is processed (with positive or negative result).
 It is possible to add further requests to the pipeline from within
 these callback functions.
<p>

 If you want to have several pipelines, or some cooperation with
 other network services, you may specify a <code class="code">Unixqueue.event_system</code>.
 For example, to have two pipelines working concurrently:
<p>

 <pre><code class="code"> let ues = Unixqueue.create_unix_event_system() in
 let p1 = new pipeline in
 let p2 = new pipeline in
 p1 # set_event_system ues;
 p2 # set_event_system ues;
 Unixqueue.run ues             (* run p1 and p2 in parallel *)
 </code></pre>
<p>

 This works not only with pipelines, but with every network client
 or server which is compatible with the <code class="code">Unixqueue</code> design.<pre><span class="keyword">method</span> <a name="METHODevent_system"></a>event_system : <code class="type"><a href="Unixqueue.event_system.html">Unixqueue.event_system</a></code></pre><div class="info">
Returns the event system<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODset_event_system"></a>set_event_system : <code class="type"><a href="Unixqueue.event_system.html">Unixqueue.event_system</a> -> unit</code></pre><div class="info">
Sets the event system. Must be called before the first call
 is added<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODconnection_cache"></a>connection_cache : <code class="type"><a href="Http_client.html#TYPEconnection_cache">connection_cache</a></code></pre><div class="info">
The current connection cache. By default, a private
 restrictive cache is used.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODset_connection_cache"></a>set_connection_cache : <code class="type"><a href="Http_client.html#TYPEconnection_cache">connection_cache</a> -> unit</code></pre><div class="info">
Set the connection cache. This must happen before the first
 call is added.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODadd_authentication_method"></a>add_authentication_method : <code class="type"><a href="Http_client.basic_auth_method.html">basic_auth_method</a> -> unit</code></pre><div class="info">
adds an old-style authentication method<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODadd_auth_handler"></a>add_auth_handler : <code class="type"><a href="Http_client.auth_handler.html">auth_handler</a> -> unit</code></pre><div class="info">
adds a new-style authentication handler<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODset_proxy"></a>set_proxy : <code class="type">string -> int -> unit</code></pre><div class="info">
<code class="code">set_proxy name port</code>:
 sets that a proxy <code class="code">name</code> listening on <code class="code">port</code> is to be used<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODset_proxy_auth"></a>set_proxy_auth : <code class="type">string -> string -> unit</code></pre><div class="info">
sets user and password for the proxy. Only the "basic" 
 authentication method is implemented.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODavoid_proxy_for"></a>avoid_proxy_for : <code class="type">string list -> unit</code></pre><div class="info">
sets a list of host names or domain suffixes for which no proxy
 should be used. 
 e.g. <code class="code"> "localhost"; ".our.net" </code><br>
</div>
<pre><span class="keyword">method</span> <a name="METHODset_proxy_from_environment"></a>set_proxy_from_environment : <code class="type">unit -> unit</code></pre><div class="info">
Inspect the environment variables <code class="code">http_proxy</code> and <code class="code">no_proxy</code>
 and set the proxy options from them.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODreset"></a>reset : <code class="type">unit -> unit</code></pre><div class="info">
Empties the pipeline and inactivates any open connection.
 The currently active operation is interrupted, and every request
 with response is set to <code class="code">No_reply</code> (i.e. you get the exception
 <code class="code">No_reply</code> if you try to access the response).
 If there are callbacks for these requests, the callback
 functions are invoked.
 The queues of open requests and replies are cleared. All
 connections to all servers are inactivated.
<p>

 Inactivation means that open connections are given back
 to the connection cache for further reuse if the state
 of the connection allows this; otherwise the connections are
 closed.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODadd"></a>add : <code class="type"><a href="Http_client.http_call.html">http_call</a> -> unit</code></pre><div class="info">
Adds the call to the end of the pipeline. 
 One must not add calls that have already been served.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODadd_with_callback"></a>add_with_callback : <code class="type"><a href="Http_client.http_call.html">http_call</a> -> (<a href="Http_client.http_call.html">http_call</a> -> unit) -> unit</code></pre><div class="info">
Adds the call to the end of the pipeline.
<p>

 After the call has been processed, the callback function
 is called. This function is called for every call that
 leaves the pipeline, it does not matter whether processing
 was successful or not. Invoke <code class="code">status</code> on the message
 to get what happened; either some status information from the
 server is available (perhaps OK status), or an exception is
 indicated.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODrun"></a>run : <code class="type">unit -> unit</code></pre><div class="info">
Runs through the requests in the pipeline. If a request can be
 fulfilled, i.e. the server sends a response, the state of the
 request is set and the request is removed from the pipeline.
 If a request cannot be fulfilled (no response, bad response, 
 network error), the exception is stored in the <code class="code">http_call</code>
 object and will be raised once the state of the object is
 queried.
<p>

 Under certain conditions (serious network errors) <code class="code">run</code> does
 not catch the exception; it simply cleans its own state up
 (aborting the errorneous network connection). In this case,
 simply invoke <code class="code">run</code> again to continue.
 <code class="code">run</code> terminates normally if the pipeline becomes empty.
<p>

 The engine handles the following HTTP return codes itself:<ul>
<li>100: This is an intermediate return code </li>
<li>301: The redirection is followed if configured</li>
<li>302: The redirection is followed if configured</li>
<li>401: Content server authentication</li>
<li>407: Proxy server authentication</li>
</ul>

 All other return codes remain uninterpreted, it is up to the
 caller of this function to react on them.
<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODget_options"></a>get_options : <code class="type"><a href="Http_client.html#TYPEhttp_options">http_options</a></code></pre><pre><span class="keyword">method</span> <a name="METHODset_options"></a>set_options : <code class="type"><a href="Http_client.html#TYPEhttp_options">http_options</a> -> unit</code></pre><div class="info">
Get/Set the available options for the HTTP engine. 
 The new options will take into effect immediately.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODnumber_of_open_messages"></a>number_of_open_messages : <code class="type">int</code></pre><div class="info">
Returns the number of messages which are still in the pipeline.<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODnumber_of_open_connections"></a>number_of_open_connections : <code class="type">int</code></pre><div class="info">
Returns the number of connections which are open at the same time
 and currently being used by this object (i.e. connections 
 returned to the cache do not count)<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODconnections"></a>connections : <code class="type">(string * int * int) list</code></pre><div class="info">
Reports which connections exist: <code class="code"> (host, port, queue_length) </code><br>
</div>
<pre><span class="keyword">method</span> <a name="METHODcnt_new_connections"></a>cnt_new_connections : <code class="type">int</code></pre><div class="info">
Counts new connections (or better: attempts to establish connections)<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODcnt_timed_out_connections"></a>cnt_timed_out_connections : <code class="type">int</code></pre><div class="info">
Counts connections given up because of timeouts<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODcnt_crashed_connections"></a>cnt_crashed_connections : <code class="type">int</code></pre><div class="info">
Counts connections with network or protocol errors<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODcnt_server_eof_connections"></a>cnt_server_eof_connections : <code class="type">int</code></pre><div class="info">
Counts connections the server terminated with EOF<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODcnt_successful_connections"></a>cnt_successful_connections : <code class="type">int</code></pre><div class="info">
Counts connections closed because pipelines become empty<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODcnt_failed_connections"></a>cnt_failed_connections : <code class="type">int</code></pre><div class="info">
Counts totally failed connections (no more reconnects allowed)<br>
</div>
<pre><span class="keyword">method</span> <a name="METHODreset_counters"></a>reset_counters : <code class="type">unit -> unit</code></pre><a name="2_Notesoncounters"></a>
<h2>Notes on counters:</h2>
<p>
<ul>
<li><code class="code">cnt_new_connections</code>: Is increased when a new connection attempt
   is started (that may fail or timeout in the future). Reconnects
   do not count.</li>
<li><code class="code">cnt_timed_out_connections</code>: Is increased whenever an established
   connection times out. Usually, it is immediately reconnected.</li>
<li><code class="code">cnt_crashed_connections</code>: Is increased whenever an established
   connection crashes. Usually, it is immediately reconnected.</li>
<li><code class="code">cnt_failed_connections</code>: Is increased when a timed out or
   crashed connection exceeds the maximum number of errors, and it is
   not tried to reconnect.</li>
<li><code class="code">cnt_successful_connections</code>: Is increased when all HTTP calls
   have been replied.</li>
</ul>

 When the client has done all of its jobs, we have
<p>

 <pre><code class="code"> cnt_new_connections = cnt_failed_connections + cnt_successful_connections </code></pre>
</body></html>
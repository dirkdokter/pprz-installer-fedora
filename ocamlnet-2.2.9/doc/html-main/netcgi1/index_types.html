<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Netcgi_env" rel="Chapter" href="Netcgi_env.html">
<link title="Netcgi_types" rel="Chapter" href="Netcgi_types.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_jserv" rel="Chapter" href="Netcgi_jserv.html">
<link title="Netcgi_jserv_ajp12" rel="Chapter" href="Netcgi_jserv_ajp12.html">
<link title="Netcgi_jserv_app" rel="Chapter" href="Netcgi_jserv_app.html">
<link title="Netcgi_fcgi_10" rel="Chapter" href="Netcgi_fcgi_10.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html"><title>Ocamlnet 2 Reference Manual (netcgi1 add-on) : Index of types</title>
</head>
<body>
<center><h1>Index of types</h1></center>
<table>
<tr><td align="left"><br>A</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi.html#TYPEargument_processing">argument_processing</a> [<a href="Netcgi1_compat.Netcgi.html">Netcgi1_compat.Netcgi</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi.html#TYPEargument_processing">argument_processing</a> [<a href="Netcgi.html">Netcgi</a>]</td>
<td><div class="info">
How to process CGI arguments: <code class="code">`Memory</code>: Keep the value of the argument in memory, <code class="code">`File</code>: Store the value of the argument in an external file, <code class="code">`Automatic</code>: If the argument is structured and carries a file name,
   the value will be stored in a file; otherwise it is loaded into
   memory. (Note: The meaning of <code class="code">`Automatic</code> changed in OcamlNet 0.92.)
</div>
</td></tr>
<tr><td><a href="Netcgi_jserv.html#TYPEauth">auth</a> [<a href="Netcgi_jserv.html">Netcgi_jserv</a>]</td>
<td><div class="info">
Authentication record
</div>
</td></tr>
<tr><td align="left"><br>C</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_types.html#TYPEcache_control">cache_control</a> [<a href="Netcgi1_compat.Netcgi_types.html">Netcgi1_compat.Netcgi_types</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_types.html#TYPEcache_control">cache_control</a> [<a href="Netcgi_types.html">Netcgi_types</a>]</td>
<td><div class="info">
This is only a small subset of the HTTP 1.1 cache control features,
 but they are usually sufficient, and they work for HTTP/1.0 as well.
</div>
</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_env.html#TYPEcgi_config">cgi_config</a> [<a href="Netcgi1_compat.Netcgi_env.html">Netcgi1_compat.Netcgi_env</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_env.html#TYPEcgi_config">cgi_config</a> [<a href="Netcgi_env.html">Netcgi_env</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_types.html#TYPEcgi_cookie">cgi_cookie</a> [<a href="Netcgi1_compat.Netcgi_types.html">Netcgi1_compat.Netcgi_types</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_types.html#TYPEcgi_cookie">cgi_cookie</a> [<a href="Netcgi_types.html">Netcgi_types</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_jserv.html#TYPEcontrolpipe">controlpipe</a> [<a href="Netcgi_jserv.html">Netcgi_jserv</a>]</td>
<td><div class="info">
The type of the control pipe
</div>
</td></tr>
<tr><td align="left"><br>F</td></tr>
<tr><td><a href="Netcgi_fcgi_10.html#TYPEfcgiBeginRequestBody">fcgiBeginRequestBody</a> [<a href="Netcgi_fcgi_10.html">Netcgi_fcgi_10</a>]</td>
<td><div class="info">
begin request
</div>
</td></tr>
<tr><td><a href="Netcgi_fcgi_10.html#TYPEfcgiEndRequestBody">fcgiEndRequestBody</a> [<a href="Netcgi_fcgi_10.html">Netcgi_fcgi_10</a>]</td>
<td><div class="info">
end request
</div>
</td></tr>
<tr><td><a href="Netcgi_fcgi_10.html#TYPEfcgiHeader">fcgiHeader</a> [<a href="Netcgi_fcgi_10.html">Netcgi_fcgi_10</a>]</td>
<td><div class="info">
protocal header
</div>
</td></tr>
<tr><td><a href="Netcgi_fcgi_10.html#TYPEfcgiRequest">fcgiRequest</a> [<a href="Netcgi_fcgi_10.html">Netcgi_fcgi_10</a>]</td>
<td><div class="info">
fcgi params will return an asociation list fcgi stdin will return
    a string a full request record, what you get when you call
    fcgi_accept
</div>
</td></tr>
<tr><td align="left"><br>I</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_env.html#TYPEinput_mode">input_mode</a> [<a href="Netcgi1_compat.Netcgi_env.html">Netcgi1_compat.Netcgi_env</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_env.html#TYPEinput_mode">input_mode</a> [<a href="Netcgi_env.html">Netcgi_env</a>]</td>
<td><div class="info">
Determines how to read the request: <code class="code">`Standard</code>: Only the request body is read from the input
    channel (CGI standard), Not yet implemented: <code class="code">`Direct</code>: Both header and body of the
   request are read from the input channel
</div>
</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_env.html#TYPEinput_state">input_state</a> [<a href="Netcgi1_compat.Netcgi_env.html">Netcgi1_compat.Netcgi_env</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_env.html#TYPEinput_state">input_state</a> [<a href="Netcgi_env.html">Netcgi_env</a>]</td>
<td><div class="info">
The input processing state: <code class="code">`Start</code>: Input data have not yet been received, <code class="code">`Receiving_header</code>: The request header is currently being 
   received, <code class="code">`Received_header</code>: The request header has been completely
   received, and nothing of the request body has yet been
   received, <code class="code">`Receiving_body</code>: The request body is currently being 
   received, <code class="code">`Received_body</code>: The request body has been completely
   received
 Transition diagram:
 <pre><code class="code"> 
 `Start -&gt; 
 `Receiving_header -&gt; 
 `Received_header -&gt;
 `Receiving_body -&gt; 
 `Received_body </code></pre>
</div>
</td></tr>
<tr><td align="left"><br>J</td></tr>
<tr><td><a href="Netcgi_jserv_app.html#TYPEjserv_config">jserv_config</a> [<a href="Netcgi_jserv_app.html">Netcgi_jserv_app</a>]</td>
<td><div class="info">
Server configuration: <code class="code">js_backlog</code> is the maximum length of the backlog queue (containing
   client connections that are not yet accepted by the application
   server), <code class="code">js_reuseaddr</code>: Whether to reuse the port immediately, <code class="code">js_cgiconfig</code>: The CGI-level configuration, <code class="code">js_init_process</code>: This hook is called when a new process is
   initialized. For <code class="code">`Sequential</code> servers it is called once before
   the server begins to accept connections. For <code class="code">`Forking</code> and
   <code class="code">`Process_pool</code> servers it is called when new processes are
   forking., <code class="code">js_fini_process</code>: The reverse hook of <code class="code">js_init_process</code>: Called
   after a process receives the shutdown notification. 
   For <code class="code">`Sequential</code> servers it is called once after
   the server stops to accept connections. For <code class="code">`Forking</code> and
   <code class="code">`Process_pool</code> servers it is called before sub processes exit., <code class="code">js_idle_master</code>: This hook is called every second by the
   master process that accepts new connections. When it raises
   an exception, the master socket is closed, and the exception
   falls through to the caller., <code class="code">js_idle_worker</code>: This hook is called every second by the
   worker process that processes connections. Exceptions are logged.
 Examples: <code class="code">js_init_process</code>: Open a new database connection for every process, <code class="code">js_fini_process</code>: Close the database connection, <code class="code">js_idle_master</code>: Check whether the server should shut down, and
   if so, raise an exception to exit, <code class="code">js_idle_worker</code>: Close database connections after a period
   of inactivity
</div>
</td></tr>
<tr><td align="left"><br>O</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi.html#TYPEoperating_type">operating_type</a> [<a href="Netcgi1_compat.Netcgi.html">Netcgi1_compat.Netcgi</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi.html#TYPEoperating_type">operating_type</a> [<a href="Netcgi.html">Netcgi</a>]</td>
<td><div class="info">
The operating type determines how generated data are buffered.
</div>
</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_types.html#TYPEother_url_spec">other_url_spec</a> [<a href="Netcgi1_compat.Netcgi_types.html">Netcgi1_compat.Netcgi_types</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_types.html#TYPEother_url_spec">other_url_spec</a> [<a href="Netcgi_types.html">Netcgi_types</a>]</td>
<td><div class="info">
Determines how an URL part is generated:
</div>
</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_env.html#TYPEoutput_mode">output_mode</a> [<a href="Netcgi1_compat.Netcgi_env.html">Netcgi1_compat.Netcgi_env</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_env.html#TYPEoutput_mode">output_mode</a> [<a href="Netcgi_env.html">Netcgi_env</a>]</td>
<td><div class="info">
Determines how to deliver the response: <code class="code">`Standard</code>: The format of the response header has CGI format,
   followed by the response body, Not yet implemented: <code class="code">`Direct</code>: The format of the response
   header has HTTP format, followed by the response body. This
   is also known as "non-parsed header" format.
</div>
</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_env.html#TYPEoutput_state">output_state</a> [<a href="Netcgi1_compat.Netcgi_env.html">Netcgi1_compat.Netcgi_env</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_env.html#TYPEoutput_state">output_state</a> [<a href="Netcgi_env.html">Netcgi_env</a>]</td>
<td><div class="info">
The output processing state: <code class="code">`Start</code>: Output has not yet been sent, <code class="code">`Sending_header</code>: The response header is currently being sent, <code class="code">`Sent_header</code>: The response header has been completely sent,
   and nothing of the body has yet been sent, <code class="code">`Sending_body</code>: The response body is currently being sent, <code class="code">`Sent_body</code>: The response body has been sent up to a
   check point, <code class="code">`End</code>: The response has been completely sent
 Transition diagram:
 <pre><code class="code">              `Start -&gt;
              `Sending_header -&gt;
              `Sent_header -&gt;
          +-&gt; `Sending_body 
          |      |
          |      V
          +-- `Sent_body 
                 |
                 V
              `End </code></pre>
</div>
</td></tr>
<tr><td align="left"><br>P</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_env.html#TYPEprotocol">protocol</a> [<a href="Netcgi1_compat.Netcgi_env.html">Netcgi1_compat.Netcgi_env</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_env.html#TYPEprotocol">protocol</a> [<a href="Netcgi_env.html">Netcgi_env</a>]</td>
<td><div class="info">
Now defined in <code class="code">Nethttp</code>
</div>
</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_env.html#TYPEprotocol_attribute">protocol_attribute</a> [<a href="Netcgi1_compat.Netcgi_env.html">Netcgi1_compat.Netcgi_env</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_env.html#TYPEprotocol_attribute">protocol_attribute</a> [<a href="Netcgi_env.html">Netcgi_env</a>]</td>
<td><div class="info">
Now defined in <code class="code">Nethttp</code>
</div>
</td></tr>
<tr><td><a href="Netcgi_jserv_app.html#TYPEprotocol_type">protocol_type</a> [<a href="Netcgi_jserv_app.html">Netcgi_jserv_app</a>]</td>
<td><div class="info">
Selects the protocol.
</div>
</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_env.html#TYPEprotocol_version">protocol_version</a> [<a href="Netcgi1_compat.Netcgi_env.html">Netcgi1_compat.Netcgi_env</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_env.html#TYPEprotocol_version">protocol_version</a> [<a href="Netcgi_env.html">Netcgi_env</a>]</td>
<td><div class="info">
Now defined in <code class="code">Nethttp</code>
</div>
</td></tr>
<tr><td align="left"><br>Q</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_types.html#TYPEquery_string_spec">query_string_spec</a> [<a href="Netcgi1_compat.Netcgi_types.html">Netcgi1_compat.Netcgi_types</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_types.html#TYPEquery_string_spec">query_string_spec</a> [<a href="Netcgi_types.html">Netcgi_types</a>]</td>
<td><div class="info">
Determines how the query part of URLs is generated:
</div>
</td></tr>
<tr><td align="left"><br>R</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_types.html#TYPErepresentation">representation</a> [<a href="Netcgi1_compat.Netcgi_types.html">Netcgi1_compat.Netcgi_types</a>]</td>
<td><div class="info">
Embedded in the single place of use.
</div>
</td></tr>
<tr><td><a href="Netcgi_types.html#TYPErepresentation">representation</a> [<a href="Netcgi_types.html">Netcgi_types</a>]</td>
<td><div class="info">
Representations of CGI arguments: <code class="code">`Simple msg</code>: The argument is unstructured, <code class="code">`MIME msg</code>: The argument has a MIME header in addition to the value
</div>
</td></tr>
<tr><td><a href="Netcgi_jserv_app.html#TYPErequest_handler">request_handler</a> [<a href="Netcgi_jserv_app.html">Netcgi_jserv_app</a>]</td>
<td><div class="info">
The request handler consists of: <code class="code">req_activate</code>: A function to process requests and to generate
   responses. The function gets a fully initialized <code class="code">cgi_activation</code>
   object, and is expected to write the response., <code class="code">req_processing</code>: Style of CGI argument processing. Same meaning as in
   <a href="Netcgi.html"><code class="code">Netcgi</code></a>., <code class="code">req_operating_type</code>: Style of CGI response buffering. Same meaning as in
   <a href="Netcgi.html"><code class="code">Netcgi</code></a>.
</div>
</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_types.html#TYPErequest_method">request_method</a> [<a href="Netcgi1_compat.Netcgi_types.html">Netcgi1_compat.Netcgi_types</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_types.html#TYPErequest_method">request_method</a> [<a href="Netcgi_types.html">Netcgi_types</a>]</td>
<td><div class="info">
The supported request methods: <code class="code">`GET</code>: Side effect-free request of a web resource, <code class="code">`POST</code>: Request with side effects, <code class="code">`HEAD</code>: Only the header of the corresponding <code class="code">`GET</code> are requested, <code class="code">`DELETE</code>: Request to delete the web resource, <code class="code">`PUT arg</code>: Request to upload the web resource
</div>
</td></tr>
<tr><td align="left"><br>S</td></tr>
<tr><td><a href="Netcgi_jserv_app.html#TYPEserver_type">server_type</a> [<a href="Netcgi_jserv_app.html">Netcgi_jserv_app</a>]</td>
<td><div class="info">
Server type: <code class="code">`Sequential servlets</code>: The server processes the requests sequentially., <code class="code">`Forking(n,servlets)</code>: The server forks for every request, and processes it in the
    child process. The integer <code class="code">n</code> is the maximum number of children 
    processes; if it is exceeded, an error message is displayed immediately
    without forking., <code class="code">`Process_pool(n,servlets)</code>: The server forks a fixed number of times (the integer <code class="code">n</code>).
    The children will process the requests concurrently. If more requests
    arrive than children are available, the requests must wait until
    a child becomes free again.
 In <code class="code">servlets</code> the list of available servlets is passed.
</div>
</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_types.html#TYPEstatus">status</a> [<a href="Netcgi1_compat.Netcgi_types.html">Netcgi1_compat.Netcgi_types</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_types.html#TYPEstatus">status</a> [<a href="Netcgi_types.html">Netcgi_types</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_types.html#TYPEstore">store</a> [<a href="Netcgi1_compat.Netcgi_types.html">Netcgi1_compat.Netcgi_types</a>]</td>
<td><div class="info">
Embedded in the single place of use.
</div>
</td></tr>
<tr><td><a href="Netcgi_types.html#TYPEstore">store</a> [<a href="Netcgi_types.html">Netcgi_types</a>]</td>
<td><div class="info">
Determines where the data of the CGI argument are actually stored.
</div>
</td></tr>
<tr><td align="left"><br>T</td></tr>
<tr><td><a href="Netcgi_jserv.html#TYPEt">t</a> [<a href="Netcgi_jserv.html">Netcgi_jserv</a>]</td>
<td><div class="info">
The type of an AJP server
</div>
</td></tr>
<tr><td align="left"><br>W</td></tr>
<tr><td><a href="Netcgi1_compat.Netcgi_env.html#TYPEworkaround">workaround</a> [<a href="Netcgi1_compat.Netcgi_env.html">Netcgi1_compat.Netcgi_env</a>]</td>
<td></td></tr>
<tr><td><a href="Netcgi_env.html#TYPEworkaround">workaround</a> [<a href="Netcgi_env.html">Netcgi_env</a>]</td>
<td><div class="info">
Indicates special behaviour: <code class="code">`Work_around_MSIE_Content_type_bug</code>: Versions of the Internet
   Explorer send illegal content types. This workaround extracts
   the right data from the malformed data field, <code class="code">`Work_around_backslash_bug</code>: Almost all browsers send illegal
   backslash sequences when backslashes occur in filenames.
   This workaround accepts such sequences.
</div>
</td></tr>
</table><br>
</body>
</html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Netulex_tut.html">
<link rel="next" href="Netsys.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Https_client" rel="Chapter" href="Https_client.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Ftp_fs" rel="Chapter" href="Ftp_fs.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgssapi" rel="Chapter" href="Netgssapi.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html"><link title="Neturl Tutorial" rel="Section" href="#tutorial">
<link title="Generic Parsing" rel="Subsection" href="#2_GenericParsing">
<link title="Parsing For a Certain Syntax" rel="Subsection" href="#2_ParsingForaCertainSyntax">
<link title="Printing URLs" rel="Subsection" href="#2_PrintingURLs">
<link title="URL Components" rel="Subsection" href="#2_URLComponents">
<link title="URL Escaping" rel="Subsection" href="#2_URLEscaping">
<link title="Representation of URL Components" rel="Subsection" href="#2_RepresentationofURLComponents">
<link title="Hint: Getting Query Arguments" rel="Subsection" href="#2_HintGettingQueryArguments">
<link title="Creating and Modifying URLs" rel="Subsection" href="#2_CreatingandModifyingURLs">
<link title="Relative URLs" rel="Subsection" href="#2_RelativeURLs">
<title>Ocamlnet 3 Reference Manual : Neturl_tut</title>
</head>
<body>
<div class="navbar"><a href="Netulex_tut.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Netsys.html">Next</a>
</div>
<center><h1>Neturl_tut</h1></center>
<br>
<br>
<span id="tutorial"><h1>Neturl Tutorial</h1></span> 
<p>

This module is a quite flexible parser for various kinds of URLs
occuring in practice. The syntax is configurable such that one
URL module can handle a lot of URL types in a generic way.
<p>

<span id="2_GenericParsing"><h2>Generic Parsing</h2></span>
<p>

In order to parse an absolute URL (beginning with a scheme identifier 
like "http:...") of unknown type just call
<pre><code class="code"> 
let url = parse_url "http://me@server/directory"
</code></pre>
<p>

By default, this function can parse all URL types listed
at <a href="Neturl.html#VALcommon_url_syntax"><code class="code">Neturl.common_url_syntax</code></a>. However, the default configuration
implies also that<ul>
<li>relative URLs cannot be parsed</li>
<li>fragment identifiers are rejected (i.e. the part after the hash
  mark like in "http://server/document#location")</li>
<li>characters are rejected when the most significant bit (MSB) is set</li>
</ul>

The latter two features can be simply enabled by passing the
arguments <code class="code">~enable_fragment:true</code> and <code class="code">~accept_8bits:true</code>, 
respectively.
<p>

The restriction that relative URLs are rejected has to do with
the problem that context information is missing. Because the scheme
identifier (like "http") is not available, the function does not
know which syntax the relative URL should have.  For example,
the relative URL <code class="code">dir/file?x=1</code> is differently parsed when
it is taken relative to an <code class="code">http</code> URL and when it is interpreted
relative to an <code class="code">ftp</code> URL. In the first case, the path component
of the URL is <code class="code">"dir/file"</code> and the query component is <code class="code">"?x=1"</code>,
but in the latter case the path component is <code class="code">"dir/file?x=1"</code>,
and a query component is not allowed.
<p>

The solution is that the syntax of the base URL, relative to which
the URL is seen, must be passed as additional argument. Under the
assumption that <code class="code">base_url</code> is the base URL, use
<pre><code class="code">let url = parse_url 
            ~base_syntax:(url_syntax_of_url base_url) 
            "/dir/file?x=1"
</code></pre>
Of course, this assumes that the base URL is known when the url
is parsed.
<p>

<span id="2_ParsingForaCertainSyntax"><h2>Parsing For a Certain Syntax</h2></span>
<p>

The function <code class="code">url_of_string</code> is also a parser, but you must pass
the URL syntax as argument, e.g.
<pre><code class="code">let url = url_of_string syntax "ipp://server/printer"
</code></pre>
Pass as <code class="code">syntax</code> one of the elements of <a href="Neturl.html#VALcommon_url_syntax"><code class="code">Neturl.common_url_syntax</code></a>,
e.g.
<pre><code class="code"> let syntax = Hashtbl.find common_url_syntax "ipp" </code></pre>
or a self-defined syntax.
<p>

<span id="2_PrintingURLs"><h2>Printing URLs</h2></span>
<p>

This is much easier, just call <code class="code">string_of_url</code> to convert an URL
to a string. It is ensured that every URL always has an
unambiguous representation as string.
<p>

<span id="2_URLComponents"><h2>URL Components</h2></span>
<p>

Internally, the parsed URL is decomposed into its components. This
module supports two ways of decomposition:<OL>
<li><code class="code">scheme://user;userparams:password@host:port/path;params?query#fragment</code></li>
<li><code class="code">scheme:other;params?query#fragment</code></li>
</OL>

The first form is used for services that directly connect to a
certain service running on a certain host. The second form can
be used for everything else not falling under this category.
<p>

Examples:
<ul>
<li><code class="code">http://me:abrakadabra@server/dir?x=5#section1</code>
<p>

   scheme=<code class="code">"http"</code>, user=<code class="code">"me"</code>, password=<code class="code">"abrakadabra"</code>, host=<code class="code">"server"</code>,
   path=<code class="code">"/dir"</code>, query=<code class="code">"x=5"</code>, fragment=<code class="code">"section1"</code> </li>
<li><code class="code">pop://you;auth=digest-md5@mail</code>
<p>

   scheme=<code class="code">"pop"</code>, user=<code class="code">"you"</code>, user_params=<code class="code">["auth=digest-md5"]</code>, host=<code class="code">"mail"</code> </li>
<li><code class="code">mailto:gerd@gerd-stolpmann.de?cc=you@domain.com</code>
<p>

   scheme=<code class="code">"mailto"</code>, other=<code class="code">"gerd@gerd-stolpmann.de"</code>,
   query=<code class="code">"cc=you@domain.com"</code> </li>
</ul>

<p>

It is important to mention that the decomposition is not fully
performed, but only down to a certain level. For example, the
query <code class="code">"x=5"</code> could be further analysed and be split into
the syntactic parts <code class="code">"x"</code> and <code class="code">"5"</code>. However, this is not done,
just because the author seeked a compromise between the depth
of analysis and the genericy of application.
<p>

<span id="2_URLEscaping"><h2>URL Escaping</h2></span>
<p>

In order to represent the so-called unsafe characters, one can
use <code class="code">%</code>-escaping in URLs. For example, this URL contains a 
password with <code class="code">@</code>, an unsafe character encoded as <code class="code">%40</code>:
<pre><code class="code"> http://user:!$%40?@server </code></pre>
The question is how this module handles such escapings.
<p>

It is surprising that the URL parser does not decode these
escaped forms (it checks, however, whether they are syntactically
correct). Internally, the components are stored as parsed,
and one can even retrieve them in their original form.
The function <code class="code">url_password</code> returns the password component.
Applied to the above URL, one can get the password in
its original, "encoded" form, or as decoded string:<ul>
<li><code class="code">url_password ~encoded:true url</code> returns <code class="code">"!$%40?"</code></li>
<li><code class="code">url_password url</code> returns <code class="code">"!$@?"</code></li>
</ul>

<span id="2_RepresentationofURLComponents"><h2>Representation of URL Components</h2></span>
<p>

The URL components can be retrieved with the functions<ul>
<li><code class="code">url_scheme</code></li>
<li><code class="code">url_user</code></li>
<li><code class="code">url_user_param</code></li>
<li><code class="code">url_password</code></li>
<li><code class="code">url_host</code></li>
<li><code class="code">url_port</code></li>
<li><code class="code">url_path</code></li>
<li><code class="code">url_param</code></li>
<li><code class="code">url_query</code></li>
<li><code class="code">url_fragment</code></li>
<li><code class="code">url_other</code></li>
</ul>

Most components are just strings. Of course, the port number is an
integer.
<p>

The path component (<code class="code">url_path</code>) has a non-obvious representation. The path
is represented as string list, e.g. "a/b/c" is represented
as <code class="code"> ["a";"b";"c"] </code>. Note, however, that absolute paths have
an empty string at the beginning of the list, e.g.
"/a/b/" is <code class="code"> [""; "a"; "b"; "" ] </code>. In most cases, the paths
found in URLs are absolute, and because of this it is quite
common to find this empty string at the beginning of the
path list. The corner cases are:<ul>
<li><code class="code"> [] </code> is used when the path is missing in the URL</li>
<li><code class="code"> [ "" ] </code> is "/"</li>
<li><code class="code"> [ ""; "" ] </code> is considered as illegal</li>
</ul>

The last two cases are somewhat arbitrary.
<p>

There is the helper function <code class="code">split_path</code> to convert the string
representation of paths into the list representation.
<p>

The parameters (<code class="code">url_user_param</code> and <code class="code">url_param</code>) are lists, too.
A parameter starts with a semicolon as delimiter and runs until
the next component, which can be another parameter. The contents,
i.e. the values after the semicolons are put into the list. For example,
the parameter ";auth=unix;type=i" is represented as
<code class="code"> ["auth=unix"; "type=i"] </code>.
<p>

<span id="2_HintGettingQueryArguments"><h2>Hint: Getting Query Arguments</h2></span>
<p>

The query component is represented as a single string. When queries
use the standard syntax "name1=value1&amp;name2=value2&amp;...", one can
parse this string using
<pre><code class="code">let args = Netencoding.Url.dest_url_encoded_parameters
             (url_query ~encoded:true url)
</code></pre>
Note that <code class="code">encoded:true</code> is needed.
<p>

<span id="2_CreatingandModifyingURLs"><h2>Creating and Modifying URLs</h2></span>
<p>

In order to create a URL for a certain syntax, call <code class="code">make_url</code>:
<pre><code class="code">let url = make_url 
            ~scheme:"http"
            ~user:"user"
            ~password:"!$@?"
            ~host:"server"
            syntax
</code></pre>
It is checked whether the URL conforms to the passed syntax. By default,
the components are passed in decoded form, and <code class="code">make_url</code> automatically
encodes them if necessary (here, for example, the at sign in the
password). Alternatively, one can set <code class="code">~encoded:true</code>, and pass the
already escaped components. In this case, <code class="code">make_url</code> checks whether
the encoding is sufficient to represent the URL as string.
<p>

The functions <code class="code">modify_url</code>, <code class="code">default_url</code>, <code class="code">undefault_url</code>, and
<code class="code">remove_from_url</code> can be used to modify an existing URL.
<p>

<span id="2_RelativeURLs"><h2>Relative URLs</h2></span>
<p>

A URL is relative when the scheme identifier at the beginning is
omitted. In this case, the URL can be transformed to an absolute
URL when the base URL is known. The algorithm for this is defined
in RFC 1808, and quite complicated. It is implemented in
<code class="code">apply_relative_url</code>, but usually <a href="Neturl.html#VALensure_absolute_url"><code class="code">Neturl.ensure_absolute_url</code></a>
is the more convenient function. Just call
<pre><code class="code"> let url' = ensure_absolute_url ~base url </code></pre>
to convert <code class="code">url</code> to its absolute counterpart <code class="code">url'</code> when it is
relative, and to pass the URL unchanged when it is already
absolute.
<p>

<br>
</body></html>
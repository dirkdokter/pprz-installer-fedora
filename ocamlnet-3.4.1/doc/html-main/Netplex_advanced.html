<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Netplex_intro.html">
<link rel="next" href="Netplex_admin.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Https_client" rel="Chapter" href="Https_client.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Ftp_fs" rel="Chapter" href="Ftp_fs.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgssapi" rel="Chapter" href="Netgssapi.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html"><link title="Advanced features of Netplex" rel="Section" href="#1_AdvancedfeaturesofNetplex">
<link title="Running timers in containers" rel="Subsection" href="#timers">
<link title="Container variables" rel="Subsection" href="#contvars">
<link title="Sending messages to individual containers" rel="Subsection" href="#contsocks">
<link title="One-time initialization code" rel="Subsection" href="#initonce">
<link title="Storing global state" rel="Subsection" href="#sharedvars">
<link title="Hooks, and how to pass values down" rel="Subsection" href="#passdown">
<link title="Levers - calling controller functions from containers" rel="Subsection" href="#levers">
<title>Ocamlnet 3 Reference Manual : Netplex_advanced</title>
</head>
<body>
<div class="navbar"><a href="Netplex_intro.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Netplex_admin.html">Next</a>
</div>
<center><h1>Netplex_advanced</h1></center>
<br>
<br>
<span id="1_AdvancedfeaturesofNetplex"><h1>Advanced features of Netplex</h1></span>
<p>

Some information about advanced techniques.
<p>

<b>Contents</b>
<p>
<ul>
<li><a href="Netplex_advanced.html#timers"><i>Running timers in containers</i></a></li>
<li><a href="Netplex_advanced.html#contvars"><i>Container variables</i></a></li>
<li><a href="Netplex_advanced.html#contsocks"><i>Sending messages to individual containers</i></a></li>
<li><a href="Netplex_advanced.html#initonce"><i>One-time initialization code</i></a></li>
<li><a href="Netplex_advanced.html#sharedvars"><i>Storing global state</i></a></li>
<li><a href="Netplex_advanced.html#passdown"><i>Hooks, and how to pass values down</i></a></li>
<li><a href="Netplex_advanced.html#levers"><i>Levers - calling controller functions from containers</i></a></li>
</ul>

<span id="timers"><h2>Running timers in containers</h2></span>
<p>

With <a href="Netplex_cenv.html#VALcreate_timer"><code class="code">Netplex_cenv.create_timer</code></a> one can start a timer that runs directly
in the container event loop. This event loop is normally used for accepting
new connections, and for exchanging control messages with the master
process. If the processor supports it (like the RPC processor), the
event loop is also used by the processor itself for 
protocol interpretation. Running a timer in this loop means that the
expiration of the timer is first detected when the control flow of the
container returns to the event loop. In the worst case, this happens only
when the current connection is finished, and it is waited for the next
connection.
<p>

So, this is not the kind of high-precision timer one would use for the
exact control of latencies. However, these timers are still useful for
things that run only infrequently, like
<p>
<ul>
<li>processing statistical information</li>
<li>checking whether configuration updates have arrived</li>
<li>checking whether resources have "timed out" and can be released
  (e.g. whether a connection to a database system can be closed)</li>
</ul>

Timers can be cancelled by called <a href="Netplex_cenv.html#VALcancel_timer"><code class="code">Netplex_cenv.cancel_timer</code></a>. Timers
are automatically cancelled at container shutdown time.
<p>

Example: Start a timer at container startup: We have to do this in the
<code class="code">post_start_hook</code> of the processor. It depends on the kind of
processor how the hooks are set. For example, the processor factories
<a href="Rpc_netplex.html#VALrpc_factory"><code class="code">Rpc_netplex.rpc_factory</code></a> and <a href="Nethttpd_plex.html#VALnethttpd_factory"><code class="code">Nethttpd_plex.nethttpd_factory</code></a> have
an argument <code class="code">hooks</code>, and one can create it like:
<p>

<pre><code class="code">  let hooks =
    ( object
        inherit Netplex_kit.empty_processor_hooks()
        method post_start_hook cont =
          let timer =
            Netplex_cenv.create_timer
              (fun timer -&gt; ...)
              tmo in
          ...
      end
    )
</code></pre>
<p>

<span id="contvars"><h2>Container variables</h2></span>
<p>

If multi-processing is used, one can simply store per-container values
in global variables. This works because for every new container the
whole program is forked, and thus a new instance of the variable is
created.
<p>

For multi-threaded programs this is a lot more difficult. For this
reason there is built-in support for per-container variables.
<p>

Example: We want to implement a statistics how often the functions
<code class="code">foo</code> and <code class="code">bar</code> are called, per-container. We define a record
<p>

<pre><code class="code">type stats =
  { mutable foo_count : int;
    mutable bar_count : int
  }
</code></pre>
<p>

Furthermore, we need an access module that looks for the current value
of the variable (get), or overwrites the value (set). We can simply
create this module by using the functor <a href="Netplex_cenv.Make_var_type.html"><code class="code">Netplex_cenv.Make_var_type</code></a>:
<p>

<pre><code class="code">module Stats_var =
  Netplex_cenv.Make_var_type(struct type t = stats end)
</code></pre>
<p>

Now, one can get the value of a <code class="code">stats</code>-typed variable "count" by
calling
<p>

<pre><code class="code">let stats =
  Stats_var.get "count"
</code></pre>
<p>

(which will raise <a href="Netplex_cenv.html#EXCEPTIONContainer_variable_not_found"><code class="code">Netplex_cenv.Container_variable_not_found</code></a> if the
value of "count" never has been set before), and one can set the value
by
<p>

<pre><code class="code">Stats_var.set "count" stats
</code></pre>
<p>

As mentioned, the variable "count" exists once per container. One
can access it only from the scope of a Netplex container (e.g. from a 
callback function that is invoked by a Netplex processor). It is a 
good idea to initialize "count" in the <code class="code">post_start_hook</code> of the
processor (see the timer example above).
<p>

See also below on "Storing global state" for another kind of variable that
can be accessed from all containers.
<p>

<span id="contsocks"><h2>Sending messages to individual containers</h2></span>
<p>

Sometimes it is useful when a container can directly communicate with 
another container, and the latter can be addressed by a unique name
within the Netplex system. A normal Netplex socket is not useful here
because Netplex determines which container will accept new connections
on the socket, i.e. from the perspective of the message sender it is
random which container receives the message.
<p>

In Ocamlnet 3, a special kind of socket, called "container socket" has
been added to solve this problem. This type of socket is not created by
the master process, but by the container process (hence the name). The
socket is a Unix Domain socket for Unix, and a named pipe for Win32.
It has a unique name, and if the message sender knows the name, it can
send the message to a specific container.
<p>

One creates such sockets by adding an <code class="code">address</code> section to the config
file that looks like
<p>

<pre><code class="code">  address {
    type = "container"
  }
</code></pre>
<p>

If this <code class="code">address</code> section is simply added to an existing <code class="code">protocol</code>
section, the network protocol of the container socket is the same as
that of the main socket of the container. If a different network protocol
is going to be used for the container socket, one can also add a second
<code class="code">protocol</code> section. For example, here is a main HTTP service, and a
separate service <code class="code">control</code> that is run over the container sockets:
<p>

<pre><code class="code">  service {
    name = "sample"
    protocol {
      name = "http"
      address {
        type = "internet"
        bind = "0.0.0.0:80"
      }
    }
    protocol {
      name = "control"
      address {
        type = "container"
      }
    }
    processor { 
      type = "myproc";
      http { ... webserver config ... }
      control { ... rpc config ... }
    }
  }
</code></pre>
<p>

One can now employ <code class="code">Netplex_kit.protocol_switch_factory</code> to route
incoming TCP connections arriving at "http" sockets to web server
code, and to route incoming TCP connections arriving at "control"
sockets to a e.g. an RPC server:
<p>

<pre><code class="code">  let compound_factory =
    new Netplex_kit.protocol_switch_factory
      "myproc"
      [ "http", Nethttpd_plex.nethttpd_factory ...;
        "control", Rpc_netplex.rpc_factory ...;
      ]
</code></pre>
<p>

The implementation of "control" would be a normal RPC server.
<p>

The remaining question is now how to get the unique names of the
container sockets. There is the function 
<a href="Netplex_cenv.html#VALlookup_container_sockets"><code class="code">Netplex_cenv.lookup_container_sockets</code></a> helping here. The function
is called with the service name and the protocol name as arguments:
<p>

<pre><code class="code">  let cs_paths =
    Netplex_cenv.lookup_container_sockets "sample" "control"
</code></pre>
<p>

It returns an array of Unix Domain paths, each corresponding to the
container socket of one container. It is recommended to use
<a href="Netplex_sockserv.html#VALany_file_client_connector"><code class="code">Netplex_sockserv.any_file_client_connector</code></a> for creating RPC
clients:
<p>

<pre><code class="code">  let clients =
    List.map
      (fun cs_path -&gt;
        let connector = Netplex_sockserv.any_file_client_connector cs_path in
        create_client ... connector ...
      )
      cs_paths
</code></pre>
<p>

There is no way to get more information about the <code class="code">cs_paths</code>, e.g.
in order to find a special container. (Of course, except by calling RPC
functions and asking the containers directly.)
<p>

A container can also find out the address of its own container socket.
Use the method <code class="code">owned_container_sockets</code> to get a list of pairs
<code class="code">(protocol_name, path)</code>, e.g.
<p>

<pre><code class="code">  let cont = Netplex_cenv.self_cont() in
  let path = List.assoc "control" cont#owned_container_sockets
</code></pre>
<p>

<span id="initonce"><h2>One-time initialization code</h2></span>
<p>

It is sometimes necessary to run some initialization code only once
for all containers of a certain service. Of course, there is always
the option of doing this at program startup. However, this might be
too early, e.g. because some information is not yet known.
<p>

Another option is to do such initialization in the <code class="code">pre_start_hook</code> of
the container. The <code class="code">pre_start_hook</code> is run before the container process
is forked off, and executes in the master process. Because of this it is
easy to have a global variable that checks whether <code class="code">pre_start_hook</code> is
called the first time:
<p>

<pre><code class="code">  let first_time = ref true

  let pre_start_hook _ _ _ =
    if !first_time then (* do initialization *) ... ;
    first_time := false

  let hooks =
    ( object
        inherit Netplex_kit.empty_processor_hooks()
        method pre_start_hook socksrv ctrl cid =
          pre_start_hook socksrv ctrl cid
      end
    )
</code></pre>
<p>

Last but not least there is also the possibility to run such
initialization code in the <code class="code">post_start_hook</code>. This is different as
this hook is called from the container, i.e. from the forked-off child
process. This might be convenient if the initialization routine is
written for container context.
<p>

There is some additional complexity, though. One can no longer simply
use a global variable to catch the first time <code class="code">post_start_hook</code> is
called. Instead, one has to use a storage medium that is shared by all
containers, and that is accessible from all containers. There are
plenty of possibilities, e.g. a file. In this example, however, we use
a Netplex semaphore:
<p>

<pre><code class="code">  let hooks =
    ( object
        inherit Netplex_kit.empty_processor_hooks()

        method post_add_hook socksrv ctrl =
          ctrl # add_plugin Netplex_semaphore.plugin

        method post_start_hook cont =
          let first_time =
            Netplex_semaphore.create "myinit" 0L in
          if first_time then (* do initialization *) ... ;
      end
    )
</code></pre>
<p>

The semaphore is visible in the whole Netplex system. We use here the
fact that <a href="Netplex_semaphore.html#VALcreate"><code class="code">Netplex_semaphore.create</code></a> returns <code class="code">true</code> when the semaphore
is created at the first call of <code class="code">create</code>. The semaphore is then never
increased or decreased.
<p>

<span id="sharedvars"><h2>Storing global state</h2></span>
<p>

Sometimes global state is unavoidable. We mean here state variables
that are accessed by all processes of the Netplex system.
<p>

Since Ocamlnet 3 there is <a href="Netplex_sharedvar.html"><code class="code">Netplex_sharedvar</code></a>. This modules provides
Netplex-global string variables that are identified by a user-chosen
name.
<p>

For example, to make a variable of <code class="code">type stats</code> globally accessible
<p>

<pre><code class="code">type stats =
  { mutable foo_count : int;
    mutable bar_count : int
  }
</code></pre>
<p>

(see also above, "Container variables"), we can accomplish this as
follows.
<p>

<pre><code class="code">module Stats_var =
  Netplex_sharedvar.Make_var_type(struct type t = stats end)
</code></pre>
<p>

Now, this defines functions <code class="code">Stats_var.get</code> and <code class="code">Stats_var.set</code> to 
get and set the value, respectively. Note that this is type-safe
although <a href="Netplex_sharedvar.Make_var_type.html"><code class="code">Netplex_sharedvar.Make_var_type</code></a> uses the <code class="code">Marshal</code> module
internally. If a get/set function is applied to a variable of the
wrong type we will get the exception
<a href="Netplex_sharedvar.html#EXCEPTIONSharedvar_type_mismatch"><code class="code">Netplex_sharedvar.Sharedvar_type_mismatch</code></a>.
<p>

Before one can get/set values, one has to create the variable with
<p>

<pre><code class="code">let ok =
  Netplex_sharedvar.create ~enc:true name
</code></pre>
<p>

The parameter <code class="code">enc:true</code> is required for variables accessed via
<a href="Netplex_sharedvar.Make_var_type.html"><code class="code">Netplex_sharedvar.Make_var_type</code></a>.
<p>

In order to use <a href="Netplex_sharedvar.html"><code class="code">Netplex_sharedvar</code></a> we have to add this plugin:
<p>

<pre><code class="code">  let hooks =
    ( object
        inherit Netplex_kit.empty_processor_hooks()

        method post_add_hook socksrv ctrl =
          ctrl # add_plugin Netplex_sharedvar.plugin
      end
    )
</code></pre>
<p>

Now, imagine that we want to increase the counters in a <code class="code">stats</code>
variable. As we have now truly parallel accesses, we have to
ensure that these accesses do not overlap. We use a Netplex
mutex to ensure this like in:
<p>

<pre><code class="code">  let mutex = Netplex_mutex.access "mymutex" in
   Netplex_mutex.lock mutex;
   try 
     let v = Stats_var.get "mystats" in
     v.foo_count &lt;- v.foo_count + foo_delta;
     v.bar_count &lt;- v.bar_count + bar_delta;
     Stats_var.set "mystats" v;
     Netplex_mutex.unlock mutex;
   with
     error -&gt; Netplex_mutex.unlock mutex; raise error
</code></pre>
<p>

As Netplex mutexes are also plugins, we have to add them in the 
<code class="code">post_add_hook</code>, too. Also see <a href="Netplex_mutex.html"><code class="code">Netplex_mutex</code></a> for more information.
<p>

Generally, shared variables should not be used to store large
quantities of data. A few megabytes are probably ok. The reason is
that these variables exist in the Netplex master process, and each
time a child is forked off the variables are also copied although this
is not necessary. (It is possible and likely that a future version of
Ocamnet improves this.)
<p>

For bigger amounts of data, it is advised to store them in an external
file, a shared memory segment (<a href="Netshm.html"><code class="code">Netshm</code></a> might help here), or even in
a database system. Shared variables should then only be used to
pass around the name of this file/segment/database.
<p>

<span id="passdown"><h2>Hooks, and how to pass values down</h2></span>
<p>

Usually, the user configures processor factories by creating hook
objects.  We have shown this already several times in previous
sections of this chapter. Sometimes the question arises how to pass
values from one hook to another.
<p>

The hooks are called in a certain order. Unfortunately, there is
no easy way to pass values from one hook to another. As workaround,
it is suggested to store the values in the hooks object.
<p>

For example, consider we need to allocate a database ID for each
container. We do this in the <code class="code">pre_start_hook</code>, so we know the ID
early. Of course, the code started from the <code class="code">post_start_hook</code> also
needs the ID, and in the <code class="code">post_finish_hook</code> we would like to delete
everything in the database referenced by this ID.
<p>

This could be done in a hook object like
<p>

<pre><code class="code">  let hooks =
    ( object
        inherit Netplex_kit.empty_processor_hooks()

        val db_id_tbl = Hashtbl.create 11

        method pre_start_hook _ _ cid =
          let db_id = allocate_db_id() in       (* create db ID *)
          Hashtbl.add db_id_tbl cid db_id       (* remember it for later *)

        method post_start_hook cont =
          let cid = cont # container_id in           (* the container ID *)
          let db_id = Hashtbl.find db_id_tbl cid in  (* look up the db ID *)
          ...

        method post_finish_hook _ _ cid =
          let db_id = Hashtbl.find db_id_tbl cid in  (* look up the db ID *)
          delete_db_id db_id;                        (* clean up db *)
          Hashtbl.remove db_id_tbl cid
      end
    )
</code></pre>
<p>

We use here the container ID to identify the container. This works in
all used hooks - either the container ID is passed directly, or we can
get it from the container object itself.
<p>

Normally there is only one controller per program. It is imaginable that
a multi-threaded program has several controllers, though. In this case
one has to be careful with this technique, because it should be avoided
that values from the Netplex system driven by one controller are visible
in the system driven by the other controller. Often, this can be easily
achieved by creating separate hook objects, one per controller.
<p>

<span id="levers"><h2>Levers - calling controller functions from containers</h2></span>
<p>

In a multi-process setup, the controller runs in the master process,
and the containers run in child processes. Because of this, container
code cannot directly invoke functions of the controller.
<p>

For multi-threaded programs, this is quite easy to solve. With the
function <a href="Netplex_cenv.html#VALrun_in_controller_context"><code class="code">Netplex_cenv.run_in_controller_context</code></a> it can be
temporarily switched to the controller thread to run code there.
<p>

For example, to start a helper container one can do
<p>

<pre><code class="code">  Netplex_cenv.run_in_controller_context ctrl
    (fun () -&gt;
       Netplex_kit.add_helper_service ctrl "helper1" hooks
    )
</code></pre>
<p>

which starts a new container with an empty processor that only consists
of the <code class="code">hooks</code> object. The <code class="code">post_start_hook</code> can be considered as the
"body" of the new thread. The advantage of this is (compared to
<code class="code">Thread.start</code>) that this thread counts as a regular container, and
can e.g. use logging functions.
<p>

There is no such easy way in the multi-processing case. As a
workaround, a special mechanism has been added to Netplex, the
so-called <b>levers</b>. Levers are registered functions that are known
to the controller and which can be invoked from container context.
Levers have an argument and can deliver a result. The types of
argument and result can be arbitrary (but must be monomorphic, and
must not contain functions). (The name, lever, was chosen because
it reminds of additional operating handles, as we add such handles
to the controller.)
<p>

Levers are usually registered in the <code class="code">post_add</code> hook of the processor.
For example, let us define a lever that can start a helper container.
As arguments we pass a tuple of a string and an int <code class="code">(s,i)</code>. The
arguments do not have any meaning here, we only do this to demonstrate
how to pass arguments. As result, we pass a boolean value back that
says whether the helper container was started successfully.
<p>

First we need to create a type module:
<p>

<pre><code class="code">module T = struct
  type s = string * int    (* argument type *)
  type r = bool            (* result type *)
end
</code></pre>
<p>

As second step, we need to create the lever module. This means only to
apply the functor <a href="Netplex_cenv.Make_lever.html"><code class="code">Netplex_cenv.Make_lever</code></a>:
<p>

<pre><code class="code">module L = Netplex_cenv.Make_lever(T)
</code></pre>
<p>

What happens behind the scene is that a function <code class="code">L.register</code> is
created that can marshal the argument and result values from the
container process to the master process and back. This is invisible
to the user, and type-safe.
<p>

Now, we have to call <code class="code">L.register</code> from the <code class="code">post_add_hook</code>. The result
of <code class="code">L.register</code> is another function that represents the lever. By
calling it, the lever is activated:
<p>

<pre><code class="code">  let hooks =
    ( object
        inherit Netplex_kit.empty_processor_hooks()

        method post_add_hook socksrv ctrl =
          let lever = 
            L.register ctrl
              (fun (s,i) -&gt;
                 try
                   Netplex_kit.add_helper_service ctrl "helper1" ...;
                   true   (* successful *)
                 with error -&gt;
                   false  (* not successful *)
              ) in
           ...
      end
    )
</code></pre>
<p>

So, when we call <code class="code">lever ("X",42)</code> from the container, the lever
mechanism routes this call to the controller process, and calls there
the function <code class="code">(fun (s,i) -&gt; ...)</code> that is the argument of
<code class="code">L.register</code>.
<p>

Finally, the question is how can we make the function <code class="code">lever</code> known to
containers. The hackish way to do this is to store <code class="code">lever</code> in a global
variable. The clean way is to store <code class="code">lever</code> in a container variable,
e.g.
<p>

<pre><code class="code">  module LV = Netplex_cenv.Make_var_type(L)
    (* This works because L.t is the type of the lever *)

  let hooks =
    ( object
        inherit Netplex_kit.empty_processor_hooks()

        val mutable helper1_lever = (fun _ -&gt; assert false)

        method post_add_hook socksrv ctrl =
          let lever = 
            L.register ctrl
              (fun (s,i) -&gt;
                 try
                   Netplex_kit.add_helper_service ctrl "helper1" ...;
                   true   (* successful *)
                 with error -&gt;
                   false  (* not successful *)
              ) in
           helper1_lever &lt;- lever

        method post_start_hook cont =
          LV.set "helper1_lever" helper1_lever
      end
    )
</code></pre>
<p>

and later in container code:
<p>

<pre><code class="code">  let helper1_lever = LV.get "helper1_lever" in
  let success = helper1_lever ("X",42) in
  if success then
    print_endline "OK, started the new helper"
  else
    print_endline "There was an error"
</code></pre>
<br>
</body></html>
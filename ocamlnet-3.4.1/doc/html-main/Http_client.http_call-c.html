<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Http_client.transport_channel_type-c.html">
<link rel="Up" href="Http_client.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Https_client" rel="Chapter" href="Https_client.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Ftp_fs" rel="Chapter" href="Ftp_fs.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgssapi" rel="Chapter" href="Netgssapi.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html"><link title="Call State" rel="Section" href="#2_CallState">
<link title="Accessing the request message (new style) " rel="Section" href="#2_Accessingtherequestmessagenewstyle">
<link title="Accessing the response message (new style) " rel="Section" href="#2_Accessingtheresponsemessagenewstyle">
<link title="Options" rel="Section" href="#2_Options">
<link title="Method characteristics" rel="Section" href="#2_Methodcharacteristics">
<link title="Channel bindings" rel="Section" href="#2_Channelbindings">
<link title="Repeating calls" rel="Section" href="#2_Repeatingcalls">
<link title="Old style access methods" rel="Section" href="#2_Oldstyleaccessmethods">
<link title="Private" rel="Section" href="#2_Private">
<title>Ocamlnet 3 Reference Manual : Http_client.http_call</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="Http_client.html">Up</a>
&nbsp;<a href="Http_client.transport_channel_type-c.html">Next</a>
</div>
<center><h1>Class type <a href="type_Http_client.http_call.html">Http_client.http_call</a></h1></center>
<br>
<pre><span id="TYPEhttp_call"><span class="keyword">class type</span> http_call</span> = <code class="code">object</code> <a href="Http_client.http_call-c.html">..</a> <code class="code">end</code></pre>The container for HTTP calls<br>
<hr width="100%">
<code class="code">http_call</code> is the runtime container for HTTP method calls. It contains
 the request message, the response message, and the current transmission
 status.
<p>

 In previous versions of netclient, this class type was called 
 <code class="code">message</code>. This was quite inexact because this class embraces both
 messages that are part of a call.
<p>

 <b>Incompatible changes</b>:<ul>
<li><code class="code">using_proxy</code> has been removed. This simply isn't a property of
   an individual call.</li>
<li><code class="code">get_req_uri</code> has been removed from the public interface for similar
   reasons.</li>
<li>The request and response messages are now primarily stored as
   <code class="code">Netmime.mime_header</code> and <code class="code">Netmime.mime_body</code> objects. The old
   style access methods remain in the API for now. The advantage is
   that it is possible to use external files as body containers.</li>
<li>There are two request headers, <code class="code">`Base</code> and <code class="code">`Effective</code>.</li>
</ul>
<span id="2_CallState"><h2>Call State</h2></span><pre><span id="METHODis_served"><span class="keyword">method</span> is_served</span> : <code class="type">bool</code></pre><div class="info">
<code class="code">true</code> if request/response cycle(s) have been finished, i.e. the
 call was successful, or a final error state has been reached.<br>
</div>
<pre><span id="METHODstatus"><span class="keyword">method</span> status</span> : <code class="type"><a href="Http_client.html#TYPEstatus">status</a></code></pre><div class="info">
The condensed status<br>
</div>
<span id="2_Accessingtherequestmessagenewstyle"><h2>Accessing the request message (new style) </h2></span><pre><span id="METHODrequest_method"><span class="keyword">method</span> request_method</span> : <code class="type">string</code></pre><div class="info">
The HTTP method as string<br>
</div>
<pre><span id="METHODrequest_uri"><span class="keyword">method</span> request_uri</span> : <code class="type">string</code></pre><div class="info">
The request URI as string. This is always an absolute URI in the
 form "http://server/path" or "https://server/path".<br>
</div>
<pre><span id="METHODset_request_uri"><span class="keyword">method</span> set_request_uri</span> : <code class="type">string -> unit</code></pre><div class="info">
Sets the request URI. This implicitly also sets the channel binding
	ID (see below).	
<p>

	<b>Changed in Ocamlnet-3.3:</b> The URI is no longer immediately parsed,
	but first when the call is submitted to a pipeline. This means that
	parsing errors will first be reported by the <code class="code">add</code> method. The
	background is that parsing now depends on pipeline options.<br>
</div>
<pre><span id="METHODrequest_header"><span class="keyword">method</span> request_header</span> : <code class="type"><a href="Http_client.html#TYPEheader_kind">header_kind</a> -> <a href="Netmime.mime_header-c.html">Netmime.mime_header</a></code></pre><div class="info">
The whole header of the request. Users of this class should only
 modify the <code class="code">`Base</code> header. After the call has been processed,
 the <code class="code">`Effective</code> header contains the version of the header that has
 actually been transmitted.
<p>

 The user should set the following headers:<ul>
<li><code class="code">Content-length</code>: Set this to the length of the request body
   if known. (The client falls back to HTTP 1.0 if not set!)</li>
<li><code class="code">Content-type</code>: Set this to the media type of the request body</li>
<li><code class="code">Expect</code>: Set this to "100-continue" to enable a handshake before
   the body is sent. Recommended for large bodies. (See also
   <code class="code">set_expect_handshake</code> below.)</li>
</ul>

 The following headers may be set, but there are reasonable defaults:<ul>
<li><code class="code">Date</code></li>
<li><code class="code">User-agent</code></li>
</ul>

 The following headers must not be set:<ul>
<li><code class="code">Connection</code></li>
</ul>
<br>
</div>
<pre><span id="METHODset_request_header"><span class="keyword">method</span> set_request_header</span> : <code class="type"><a href="Netmime.mime_header-c.html">Netmime.mime_header</a> -> unit</code></pre><div class="info">
Replaces the whole <code class="code">`Base</code> header object<br>
</div>
<pre><span id="METHODset_expect_handshake"><span class="keyword">method</span> set_expect_handshake</span> : <code class="type">unit -> unit</code></pre><div class="info">
Configures that a handshake is done before sending the request body.
	This is useful when the request body can be large, and
	authentication or response indirections are possible.
	<b>New since Ocamlnet-3.3.</b><br>
</div>
<pre><span id="METHODset_chunked_request"><span class="keyword">method</span> set_chunked_request</span> : <code class="type">unit -> unit</code></pre><div class="info">
Configures that the request is transmitted using chunked encoding.
	This has advantages when the size of the request is not known
	in advance. However, this works only for true HTTP/1.1 servers.
	<b>New since Ocamlnet-3.3.</b><br>
</div>
<pre><span id="METHODeffective_request_uri"><span class="keyword">method</span> effective_request_uri</span> : <code class="type">string</code></pre><div class="info">
The URI actually sent to the server in the request line of the
 protocol.<br>
</div>
<pre><span id="METHODrequest_body"><span class="keyword">method</span> request_body</span> : <code class="type"><a href="Netmime.mime_body-c.html">Netmime.mime_body</a></code></pre><div class="info">
The whole body of the request. This method fails after
	<code class="code">set_request_device</code> has been called (no body then).<br>
</div>
<pre><span id="METHODset_request_body"><span class="keyword">method</span> set_request_body</span> : <code class="type"><a href="Netmime.mime_body-c.html">Netmime.mime_body</a> -> unit</code></pre><div class="info">
Replaces the whole body object<br>
</div>
<pre><span id="METHODset_request_device"><span class="keyword">method</span> set_request_device</span> : <code class="type">(unit -> <a href="Uq_io.html#TYPEin_device">Uq_io.in_device</a>) -> unit</code></pre><div class="info">
Sets that the request data is read from the passed device instead
	of taking it from a body object.  The device must be connected with
	the same event loop as the HTTP client.<br>
</div>
<pre><span id="METHODset_accept_encoding"><span class="keyword">method</span> set_accept_encoding</span> : <code class="type">unit -> unit</code></pre><div class="info">
Sets the <code class="code">Accept-Encoding</code> field in the request header, and 
	includes all decompression algorithms registered in
	<a href="Netcompression.html"><code class="code">Netcompression</code></a>. Additionally, the automatic decompression of
	the response body is enabled.
<p>

	Note that you need to ensure that the algorithms are really
	registered at <a href="Netcompression.html"><code class="code">Netcompression</code></a>. For example, to get <code class="code">gzip</code>
	support, run <pre><code class="code"> Netgzip.init() </code></pre>, and include <code class="code">netzip</code> as
	library.<br>
</div>
<span id="2_Accessingtheresponsemessagenewstyle"><h2>Accessing the response message (new style) </h2></span>
<p>

 These methods will fail if the call has not yet been served! 
 If the call has been finished, but a hard error (e.g. socket error)
 occurred, the
 exception <code class="code">Http_protocol</code> is raised. When the server only
 sent an error code, no exception is raised - but the user can
 manually test for such codes (e.g. with <code class="code">repsonse_status</code> or
 <code class="code">status</code>).<pre><span id="METHODresponse_status_code"><span class="keyword">method</span> response_status_code</span> : <code class="type">int</code></pre><div class="info">
The three-digit status code<br>
</div>
<pre><span id="METHODresponse_status_text"><span class="keyword">method</span> response_status_text</span> : <code class="type">string</code></pre><div class="info">
The text transmitted along with the code<br>
</div>
<pre><span id="METHODresponse_status"><span class="keyword">method</span> response_status</span> : <code class="type"><a href="Nethttp.html#TYPEhttp_status">Nethttp.http_status</a></code></pre><div class="info">
The decoded code. Unknown codes are mapped to the generic status
 values <code class="code">`Ok</code>, <code class="code">`Multiple_choices</code>, <code class="code">`Bad_request</code>, and 
 <code class="code">`Internal_server_error</code>.<br>
</div>
<pre><span id="METHODresponse_protocol"><span class="keyword">method</span> response_protocol</span> : <code class="type">string</code></pre><div class="info">
The HTTP version indicated in the response<br>
</div>
<pre><span id="METHODresponse_header"><span class="keyword">method</span> response_header</span> : <code class="type"><a href="Netmime.mime_header-c.html">Netmime.mime_header</a></code></pre><div class="info">
The whole header of the response. If the call has not succeeded, 
 <code class="code">Http_protocol</code> will be raised.<br>
</div>
<pre><span id="METHODresponse_body"><span class="keyword">method</span> response_body</span> : <code class="type"><a href="Netmime.mime_body-c.html">Netmime.mime_body</a></code></pre><div class="info">
The whole body of the response. If the call has not succeeded, 
 <code class="code">Http_protocol</code> will be raised. If the call has succeeded, 
 but no body has been transmitted, the empty body is substituted.
<p>

 If the response is directly forwarded to a device (after
 calling <code class="code">set_response_body_storage (`Device d)</code>), there is
 no accessible response body, and this method will fail.<br>
</div>
<span id="2_Options"><h2>Options</h2></span><pre><span id="METHODresponse_body_storage"><span class="keyword">method</span> response_body_storage</span> : <code class="type"><a href="Http_client.html#TYPEresponse_body_storage">response_body_storage</a></code></pre><div class="info">
How to create the response body. Defaults to <code class="code">`Memory</code>.<br>
</div>
<pre><span id="METHODset_response_body_storage"><span class="keyword">method</span> set_response_body_storage</span> : <code class="type"><a href="Http_client.html#TYPEresponse_body_storage">response_body_storage</a> -> unit</code></pre><div class="info">
Sets how to create the response body<br>
</div>
<pre><span id="METHODmax_response_body_length"><span class="keyword">method</span> max_response_body_length</span> : <code class="type">int64</code></pre><div class="info">
Returns the current maximum length (initially <code class="code">Int64.max_int</code>)<br>
</div>
<pre><span id="METHODset_max_response_body_length"><span class="keyword">method</span> set_max_response_body_length</span> : <code class="type">int64 -> unit</code></pre><div class="info">
Sets a new maximum length. When the body exceeds this maximum
	by more than the size of the internal buffer, the reception of
	the response is interrupted, and the error is set to
	<code class="code">Response_too_large</code>.<br>
</div>
<pre><span id="METHODget_reconnect_mode"><span class="keyword">method</span> get_reconnect_mode</span> : <code class="type"><a href="Http_client.http_call-c.html">http_call</a> <a href="Http_client.html#TYPEhow_to_reconnect">how_to_reconnect</a></code></pre><div class="info">
Get what to do if the server needs to be reconnected, i.e.
 if the request must be sent repeatedly.
 By default, this is <code class="code">Send_again_if_idem</code>.<br>
</div>
<pre><span id="METHODset_reconnect_mode"><span class="keyword">method</span> set_reconnect_mode</span> : <code class="type"><a href="Http_client.http_call-c.html">http_call</a> <a href="Http_client.html#TYPEhow_to_reconnect">how_to_reconnect</a> -> unit</code></pre><div class="info">
Sets the reconnect mode<br>
</div>
<pre><span id="METHODget_redirect_mode"><span class="keyword">method</span> get_redirect_mode</span> : <code class="type"><a href="Http_client.http_call-c.html">http_call</a> <a href="Http_client.html#TYPEhow_to_redirect">how_to_redirect</a></code></pre><div class="info">
By default, the redirect mode is <code class="code">Redirect_if_idem</code>.<br>
</div>
<pre><span id="METHODset_redirect_mode"><span class="keyword">method</span> set_redirect_mode</span> : <code class="type"><a href="Http_client.http_call-c.html">http_call</a> <a href="Http_client.html#TYPEhow_to_redirect">how_to_redirect</a> -> unit</code></pre><div class="info">
Sets the redirect mode<br>
</div>
<pre><span id="METHODproxy_enabled"><span class="keyword">method</span> proxy_enabled</span> : <code class="type">bool</code></pre><div class="info">
Returns the proxy mode<br>
</div>
<pre><span id="METHODset_proxy_enabled"><span class="keyword">method</span> set_proxy_enabled</span> : <code class="type">bool -> unit</code></pre><div class="info">
Sets the proxy mode<br>
</div>
<pre><span id="METHODno_proxy"><span class="keyword">method</span> no_proxy</span> : <code class="type">unit -> unit</code></pre><div class="info">
Same as <code class="code">set_proxy_enabled false</code><br>
</div>
<pre><span id="METHODis_proxy_allowed"><span class="keyword">method</span> is_proxy_allowed</span> : <code class="type">unit -> bool</code></pre><div class="info">
<b>Deprecated.</b> Same as <code class="code">proxy_enabled</code><br>
</div>
<span id="2_Methodcharacteristics"><h2>Method characteristics</h2></span>
<p>

 These properties describe the HTTP method<pre><span id="METHODproxy_use_connect"><span class="keyword">method</span> proxy_use_connect</span> : <code class="type">bool</code></pre><div class="info">
Whether to use the CONNECT method if the connection is made via a
	web proxy. This is normally true if the channel binding is
	<a href="Http_client.html#VALhttps_cb_id"><code class="code">Http_client.https_cb_id</code></a><br>
</div>
<pre><span id="METHODempty_path_replacement"><span class="keyword">method</span> empty_path_replacement</span> : <code class="type">string</code></pre><div class="info">
The string to substitute in the request line for the empty
 path. This is usually "/", and for OPTIONS it is "*".<br>
</div>
<pre><span id="METHODis_idempotent"><span class="keyword">method</span> is_idempotent</span> : <code class="type">bool</code></pre><div class="info">
Whether the method is to be considered as idempotent ( = repeated
 invocations have the same result and no side effect). This is
 true for GET and HEAD.<br>
</div>
<pre><span id="METHODhas_req_body"><span class="keyword">method</span> has_req_body</span> : <code class="type">bool</code></pre><div class="info">
Whether the method allows to send a request body<br>
</div>
<pre><span id="METHODhas_resp_body"><span class="keyword">method</span> has_resp_body</span> : <code class="type">bool</code></pre><div class="info">
Whether the method allows to reply with a body. This is true
 except for HEAD.<br>
</div>
<span id="2_Channelbindings"><h2>Channel bindings</h2></span> 
<p>

      Channel bindings are used to distinguish between security requirements.
      There are normally only two types of requirements:
<p>
<ul>
<li>The ID <a href="Http_client.html#VALhttp_cb_id"><code class="code">Http_client.http_cb_id</code></a> is used for messages that can only
        be sent over HTTP connections, i.e. unencrypted TCP. It is automatically
        set when the URL of the message starts with "http://".</li>
<li>The ID <a href="Http_client.html#VALhttps_cb_id"><code class="code">Http_client.https_cb_id</code></a> describes the requirement that the
        message can only be sent over HTTPS connections, i.e. TLS-protected
        TCP. It is automatically  set when the URL of the message starts with
        "https://".</li>
</ul>

      It is possible to change the channel binding to establish further
      types of security requirements (e.g. that certain client certificates
      are used), or even other details of the transport connection.
<p>

      The method <code class="code">channel_binding</code> is gone from this object type.
      It is now available as part of <code class="code">pipeline</code>.<pre><span id="METHODset_channel_binding"><span class="keyword">method</span> set_channel_binding</span> : <code class="type"><a href="Http_client.html#TYPEchannel_binding_id">channel_binding_id</a> -> unit</code></pre><div class="info">
Sets the channel binding. Note that <code class="code">set_request_uri</code> also sets
	the channel binding, but always to the default for the type of URL.<br>
</div>
<span id="2_Repeatingcalls"><h2>Repeating calls</h2></span><pre><span id="METHODsame_call"><span class="keyword">method</span> same_call</span> : <code class="type">unit -> <a href="Http_client.http_call-c.html">http_call</a></code></pre><div class="info">
This method returns a new object that will perform the same call
 as this object (this function is called "reload" in browsers).
 The new object is initialized as follows:<ul>
<li>The state is set to <code class="code">`Unserved</code></li>
<li>The request method remains the same (the class of the returned
   object remains the same)</li>
<li>The request URI is the same string as the original URI</li>
<li>The channel binding ID is the same</li>
<li>The base request header is the same object</li>
<li>The request body is the same object</li>
<li>Options like reconnect, redirect mode, and proxy mode are
   copied.</li>
</ul>
<br>
</div>
<span id="2_Oldstyleaccessmethods"><h2>Old style access methods</h2></span>
<p>

 These method were introduced in previous versions of netclient,
 but are quite limited. Some questionable methods are now deprecated
 and will be removed in future versions of netclient.<pre><span id="METHODget_req_method"><span class="keyword">method</span> get_req_method</span> : <code class="type">unit -> string</code></pre><div class="info">
Get the name of the request method. Same as <code class="code">request_method</code>.<br>
</div>
<pre><span id="METHODget_host"><span class="keyword">method</span> get_host</span> : <code class="type">unit -> string</code></pre><div class="info">
The host name of the content server, extracted from the URI.
<p>

	<b>Changed in Ocamlnet-3.3:</b> The host can first be extracted after
	the call is submitted to a pipeline.<br>
</div>
<pre><span id="METHODget_port"><span class="keyword">method</span> get_port</span> : <code class="type">unit -> int</code></pre><div class="info">
The port number of the content server, extracted from the URI.
<p>

	<b>Changed in Ocamlnet-3.3:</b> The port can first be extracted after
	the call is submitted to a pipeline.<br>
</div>
<pre><span id="METHODget_path"><span class="keyword">method</span> get_path</span> : <code class="type">unit -> string</code></pre><div class="info">
The path (incl. query, if any) extracted from the URI.
<p>

	<b>Changed in Ocamlnet-3.3:</b> The path can first be extracted after
	the call is submitted to a pipeline.<br>
</div>
<pre><span id="METHODget_uri"><span class="keyword">method</span> get_uri</span> : <code class="type">unit -> string</code></pre><div class="info">
the full URI of this message: http://server:port/path. If the
 path is empty, it is omitted. - Same as <code class="code">request_uri</code>.<br>
</div>
<pre><span id="METHODget_req_body"><span class="keyword">method</span> get_req_body</span> : <code class="type">unit -> string</code></pre><div class="info">
What has been sent as body in the (last) request. Same as
 <code class="code">request_body # value</code>.<br>
</div>
<pre><span id="METHODget_req_header"><span class="keyword">method</span> get_req_header</span> : <code class="type">unit -> (string * string) list</code></pre><div class="info">
<b>Deprecated.</b>
 What has been sent as header in the (last) request. Returns
 (key, value) pairs, where the keys are all in lowercase.
<p>

 In new code, the <code class="code">request_header</code> object should be accessed instead.<br>
</div>
<pre><span id="METHODassoc_req_header"><span class="keyword">method</span> assoc_req_header</span> : <code class="type">string -> string</code></pre><div class="info">
Query a specific header entry, or raise <code class="code">Not_found</code><br>
</div>
<pre><span id="METHODassoc_multi_req_header"><span class="keyword">method</span> assoc_multi_req_header</span> : <code class="type">string -> string list</code></pre><div class="info">
Return all header values for a given field name (header entries
 which allow several values separated by commas can also be 
 transmitted by several header lines with the same name).<br>
</div>
<pre><span id="METHODset_req_header"><span class="keyword">method</span> set_req_header</span> : <code class="type">string -> string -> unit</code></pre><pre><span id="METHODget_resp_header"><span class="keyword">method</span> get_resp_header</span> : <code class="type">unit -> (string * string) list</code></pre><div class="info">
<b>Deprecated.</b>
 Get the header of the last response. The keys are in lowercase 
 characters again.<br>
</div>
<pre><span id="METHODassoc_resp_header"><span class="keyword">method</span> assoc_resp_header</span> : <code class="type">string -> string</code></pre><div class="info">
Query a specific header entry of the response.<br>
</div>
<pre><span id="METHODassoc_multi_resp_header"><span class="keyword">method</span> assoc_multi_resp_header</span> : <code class="type">string -> string list</code></pre><div class="info">
Return all response header values for a given field name (header 
 entries which allow several values separated by commas can also be 
 transmitted by several header lines with the same name).<br>
</div>
<pre><span id="METHODget_resp_body"><span class="keyword">method</span> get_resp_body</span> : <code class="type">unit -> string</code></pre><div class="info">
<b>Deprecated.</b>
 Returns the body of the last response if the response status
 is OK (i.e. the code is in the range 200 to 299).
<p>

 Otherwise, Http_error (code, body) is raised where 'code' is
 the response code and 'body' is the body of the (errorneous)
 response.<br>
</div>
<pre><span id="METHODdest_status"><span class="keyword">method</span> dest_status</span> : <code class="type">unit -> string * int * string</code></pre><div class="info">
Returns the status line of the last response (but status lines
 with code 100 are ignored).
 The returned triple is (http_string, code, text)<br>
</div>
<span id="2_Private"><h2>Private</h2></span><pre><span id="METHODprivate_api"><span class="keyword">method</span> private_api</span> : <code class="type"><a href="Http_client.html#TYPEprivate_api">private_api</a></code></pre></body></html>
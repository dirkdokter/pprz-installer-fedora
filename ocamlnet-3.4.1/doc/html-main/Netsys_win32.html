<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Netexn.html">
<link rel="next" href="Netsys_pollset_posix.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Https_client" rel="Chapter" href="Https_client.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Ftp_fs" rel="Chapter" href="Ftp_fs.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgssapi" rel="Chapter" href="Netgssapi.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html"><link title="Event objects" rel="Section" href="#1_Eventobjects">
<link title="Primitives for sockets" rel="Section" href="#1_Primitivesforsockets">
<link title="Support for named pipes" rel="Section" href="#1_Supportfornamedpipes">
<link title="I/O threads" rel="Section" href="#1_IOthreads">
<link title="Processes" rel="Section" href="#1_Processes">
<link title="Consoles" rel="Section" href="#1_Consoles">
<link title="Miscelleneous" rel="Section" href="#1_Miscelleneous">
<link title="Proxy Descriptors" rel="Section" href="#1_ProxyDescriptors">
<link title="Miscelleneous" rel="Section" href="#1_Miscelleneous">
<link title="Debugging" rel="Section" href="#1_Debugging">
<title>Ocamlnet 3 Reference Manual : Netsys_win32</title>
</head>
<body>
<div class="navbar"><a href="Netexn.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Netsys_pollset_posix.html">Next</a>
</div>
<center><h1>Module <a href="type_Netsys_win32.html">Netsys_win32</a></h1></center>
<br>
<pre><span class="keyword">module</span> Netsys_win32: <code class="code">sig</code> <a href="Netsys_win32.html">..</a> <code class="code">end</code></pre>Primitives for Win32<br>
<hr width="100%">
<br>
<span id="1_Eventobjects"><h1>Event objects</h1></span><br>
<pre><span id="TYPEw32_event"><span class="keyword">type</span> <code class="type"></code>w32_event</span> </pre>

<pre><span id="VALcreate_event"><span class="keyword">val</span> create_event</span> : <code class="type">unit -> <a href="Netsys_win32.html#TYPEw32_event">w32_event</a></code></pre><div class="info">
Create an event object<br>
</div>
<pre><span id="VALset_event"><span class="keyword">val</span> set_event</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_event">w32_event</a> -> unit</code></pre><div class="info">
Set the object to "signaled" state<br>
</div>
<pre><span id="VALreset_event"><span class="keyword">val</span> reset_event</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_event">w32_event</a> -> unit</code></pre><div class="info">
Set the object to "non-signaled" state<br>
</div>
<pre><span id="VALtest_event"><span class="keyword">val</span> test_event</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_event">w32_event</a> -> bool</code></pre><div class="info">
Test whether the object is in signaled state<br>
</div>
<pre><span id="VALevent_wait"><span class="keyword">val</span> event_wait</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_event">w32_event</a> -> float -> bool</code></pre><div class="info">
Wait until the event is set to signaled state. The float argument
      is the timeout in seconds. The function returns whether the object
      is in signaled state.<br>
</div>
<pre><span id="VALevent_descr"><span class="keyword">val</span> event_descr</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_event">w32_event</a> -> Unix.file_descr</code></pre><div class="info">
Returns the proxy descriptor for the event. See <code class="code">lookup</code> below for
      more on proxy descriptors. This function always returns the same
      descriptor. The user has to close this descriptor if this function
      is called.<br>
</div>
<br>
<span id="1_Primitivesforsockets"><h1>Primitives for sockets</h1></span><br>
<pre><span id="VALwsa_event_select"><span class="keyword">val</span> wsa_event_select</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_event">w32_event</a> -><br>       Unix.file_descr -> <a href="Netsys_posix.html#TYPEpoll_req_events">Netsys_posix.poll_req_events</a> -> unit</code></pre><div class="info">
associate event objects with socket conditions<br>
</div>
<pre><span id="VALwsa_maximum_wait_events"><span class="keyword">val</span> wsa_maximum_wait_events</span> : <code class="type">unit -> int</code></pre><div class="info">
max size of the array passed to <code class="code">wsa_wait_for_multiple_events</code><br>
</div>
<pre><span id="VALwsa_wait_for_multiple_events"><span class="keyword">val</span> wsa_wait_for_multiple_events</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_event">w32_event</a> array -> int -> int option</code></pre><div class="info">
Waits until one of the events in the array is in signaled state,
        or until a timeout happens. The int is the timeout in milliseconds.
        A negative timeout means infinity.
<p>

        The function returns the first index in the array that is signaled.
<p>

        On timeout, <code class="code">None</code> is returned.
<p>

        The return value <code class="code">WSA_WAIT_IO_COMPLETION</code> is mapped to the
        Unix error <code class="code">EINTR</code>.<br>
</div>
<pre><span id="VALwsa_enum_network_events"><span class="keyword">val</span> wsa_enum_network_events</span> : <code class="type">Unix.file_descr -> <a href="Netsys_win32.html#TYPEw32_event">w32_event</a> -> <a href="Netsys_posix.html#TYPEpoll_act_events">Netsys_posix.poll_act_events</a></code></pre><div class="info">
Checks whether an event has been recorded<br>
</div>
<pre><span id="VALreal_select"><span class="keyword">val</span> real_select</span> : <code class="type">Unix.file_descr list -><br>       Unix.file_descr list -><br>       Unix.file_descr list -><br>       float -> Unix.file_descr list * Unix.file_descr list * Unix.file_descr list</code></pre><div class="info">
Up to Ocaml 3.10, this function is identical to <code class="code">Unix.select</code>. In
        3.11, the latter was changed to a smart implementation that promises
        to handle other types of handles in addition to sockets. As we do
        the same in <code class="code">Netsys</code>, this would be a duplication of work. Also,
        the older implementation is more mature.<br>
</div>
<br>
<span id="1_Supportfornamedpipes"><h1>Support for named pipes</h1></span><br>
<br>
Win32 named pipes work very much like Unix Domain sockets, only
    that the Win32 interface is different. This wrapper, however,
    mimicks socket behaviour as far as possible (and we also use
    an socket-like API with <code class="code">listen</code> and <code class="code">accept</code>). There is a 
    <code class="code">w32_pipe_server</code> representing pipe servers. An individual pipe
    is wrapped into a <code class="code">w32_pipe</code>.
<p>

    Win32 named pipes do not allow to check whether an operation would block
    before starting the operation. There is so-called overlapped I/O,
    but it works differently than Unix-style multiplexing.
<p>

    The following functions add a layer to the Win32 primitives that
    helps using pipes in a way similar to multiplexing. We allocate
    buffers for input and output, and the functions <code class="code">pipe_read</code> and
    <code class="code">pipe_write</code> access these buffers in the first place. When reading,
    but the read buffer is empty, we start an  overlapped read operation  
    from the pipe handle. The arriving data refills the read buffer, and
    a <code class="code">w32_event</code> is signaled to wake up any pending event loop.
    During the pending read from the pipe handle, the read buffer is
    locked, and <code class="code">pipe_read</code> will return <code class="code">EWOULDBLOCK</code>.
<p>

    Writing is slightly more difficult. The first <code class="code">pipe_write</code> puts
    the data into the write buffer, and immediately starts an overlapped
    I/O operation to write the data to the pipe handle. During this
    operation the write buffer is locked, and cannot be further used
    to accumulate data, even if there is space. So <code class="code">pipe_write</code> will
    return <code class="code">EWOULDBLOCK</code> while the operation takes place. A <code class="code">w32_event</code> is
    signaled when the write operation is over.
<p>

    The only downside of this approach is that the caller has to use
    <code class="code">pipe_read</code> and <code class="code">pipe_write</code> to access pipes, instead of
    <code class="code">Unix.read</code> and <code class="code">Unix.write</code>. If generic r/w functions are
    required that work for numerous kinds of descriptors, there are
    <a href="Netsys.html#VALgread"><code class="code">Netsys.gread</code></a> and <a href="Netsys.html#VALgwrite"><code class="code">Netsys.gwrite</code></a> which support named
    pipes.<br>
<pre><span id="TYPEw32_pipe_server"><span class="keyword">type</span> <code class="type"></code>w32_pipe_server</span> </pre>
<div class="info">
A pipe server. Note that there is no such thing in the Win32 API.
      Actually, a <code class="code">w32_pipe_server</code> contains the server endpoints of 
      a number of pipes, and a few helper objects.<br>
</div>

<pre><span id="TYPEw32_pipe"><span class="keyword">type</span> <code class="type"></code>w32_pipe</span> </pre>
<div class="info">
A pipe endpoint<br>
</div>

<br><code><span id="TYPEpipe_mode"><span class="keyword">type</span> <code class="type"></code>pipe_mode</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Pipe_in</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Pipe_out</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Pipe_duplex</span></code></td>

</tr></table>


<pre><span id="VALrev_mode"><span class="keyword">val</span> rev_mode</span> : <code class="type"><a href="Netsys_win32.html#TYPEpipe_mode">pipe_mode</a> -> <a href="Netsys_win32.html#TYPEpipe_mode">pipe_mode</a></code></pre><div class="info">
Reverses the direction<br>
</div>
<pre><span id="VALcreate_local_pipe_server"><span class="keyword">val</span> create_local_pipe_server</span> : <code class="type">string -> <a href="Netsys_win32.html#TYPEpipe_mode">pipe_mode</a> -> int -> <a href="Netsys_win32.html#TYPEw32_pipe_server">w32_pipe_server</a></code></pre><br>
<code class="code">create_local_named_pipe name mode n</code>: Create a pipe server.
      The <code class="code">name</code> must have the format "\\.\pipe\&lt;name&gt;".
      In <code class="code">n</code> the maximum number of instances is passed. The server is
      set up with a security descriptor so only clients on the same system
      can connect.<br>
<br>
In the following, a terminology has been chosen that is similar to
    those of the socket API. The terms are different from those Microsoft
    prefers, however.<br>
<pre><span id="VALpipe_listen"><span class="keyword">val</span> pipe_listen</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe_server">w32_pipe_server</a> -> int -> unit</code></pre><div class="info">
Creates the backlog queue with <code class="code">n</code> prepared server endpoints.
<p>

      One can check for new client connections by looking at the
      <code class="code">pipe_connect_event</code>.<br>
</div>
<pre><span id="VALpipe_accept"><span class="keyword">val</span> pipe_accept</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe_server">w32_pipe_server</a> -> <a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a></code></pre><div class="info">
Waits until the connect event is signaled (usually meaning that
      a new client connection is available), and returns the new
      pipe.<br>
</div>
<pre><span id="VALpipe_connect"><span class="keyword">val</span> pipe_connect</span> : <code class="type">string -> <a href="Netsys_win32.html#TYPEpipe_mode">pipe_mode</a> -> <a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a></code></pre><div class="info">
<code class="code">pipe_connect name mode</code>: Creates a client pipe handle, and tries
      to connect to the pipe server <code class="code">name</code>. The function fails with the
      Unix error <code class="code">EAGAIN</code> if there are currently no listening instances of the
      pipe at the server.
<p>

      The name must be of the form "\\.\pipe\&lt;name&gt;" (excluding connects
      to pipes on remote systems). This function allows only connects to
      local pipe servers, and enforces anonymous impersonation.
<p>

      Note that you also can connect to named pipes using <code class="code">open_in</code> and
      <code class="code">Unix.openfile</code>, and that these functions do not protect against
      malicious servers that impersonate as the caller.<br>
</div>
<pre><span id="VALpipe_pair"><span class="keyword">val</span> pipe_pair</span> : <code class="type"><a href="Netsys_win32.html#TYPEpipe_mode">pipe_mode</a> -> <a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a> * <a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a></code></pre><div class="info">
Returns a pair of connected pipes (using automatically generated
      names). The left pipe is in the passed <code class="code">pipe_mode</code>, and the
      right pipe is in the matching complementaty mode.<br>
</div>
<pre><span id="VALpipe_read"><span class="keyword">val</span> pipe_read</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a> -> string -> int -> int -> int</code></pre><div class="info">
<code class="code">pipe_read p s pos len</code>: Tries to read data from the pipe. If data
      is available, it is put into the <code class="code">len</code> bytes at position <code class="code">pos</code> of
      the string <code class="code">s</code>, and the actual number of read bytes is returned.
<p>

      If no data is available, the function fails with a Unix error of
      <code class="code">EAGAIN</code>.
<p>

      If the end of the pipe is reached, the function returns 0.<br>
</div>
<pre><span id="VALpipe_write"><span class="keyword">val</span> pipe_write</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a> -> string -> int -> int -> int</code></pre><div class="info">
<code class="code">pipe_write p s pos len</code>: Tries to write data to the pipe. If space
      is available, the data is taken from the <code class="code">len</code> bytes at position <code class="code">pos</code> of
      the string <code class="code">s</code>, and the actual number of written bytes is returned.
<p>

      If no space is available, the function fails with a Unix error of
      <code class="code">EAGAIN</code>.<br>
</div>
<pre><span id="VALpipe_shutdown"><span class="keyword">val</span> pipe_shutdown</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a> -> unit</code></pre><div class="info">
Cancels all pending I/O operations and closes the pipe handle.
<p>

      Note that there is no way to close only one direction of bidirectional
      pipes.
<p>

      See the comments on closing pipes below.<br>
</div>
<pre><span id="VALpipe_shutdown_server"><span class="keyword">val</span> pipe_shutdown_server</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe_server">w32_pipe_server</a> -> unit</code></pre><div class="info">
Closes the pipe server: All endpoints in the backlog queue are
      shutdown. Note that this can result in crashed connections -
      if the kernel establishes a connection but it is not yet
      <code class="code">pipe_accept</code>ed, it is simply destroyed by this function.<br>
</div>
<pre><span id="VALpipe_connect_event"><span class="keyword">val</span> pipe_connect_event</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe_server">w32_pipe_server</a> -> <a href="Netsys_win32.html#TYPEw32_event">w32_event</a></code></pre><div class="info">
The event object signals when a new client connection is available<br>
</div>
<pre><span id="VALpipe_rd_event"><span class="keyword">val</span> pipe_rd_event</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a> -> <a href="Netsys_win32.html#TYPEw32_event">w32_event</a></code></pre><pre><span id="VALpipe_wr_event"><span class="keyword">val</span> pipe_wr_event</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a> -> <a href="Netsys_win32.html#TYPEw32_event">w32_event</a></code></pre><div class="info">
The event objects signaling that read and write operations are possible.
      The read event is in signaled state when the read buffer is non-empty
      (even for write-only pipes). The write event is in signaled state when
      the pipe is connected and the write buffer is empty (even for 
      read-only pipes).<br>
</div>
<pre><span id="VALpipe_wait_connect"><span class="keyword">val</span> pipe_wait_connect</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe_server">w32_pipe_server</a> -> float -> bool</code></pre><div class="info">
Wait until a client connects to this server. The float argument
      is the timeout in seconds. The function returns whether there is
      data to read or write. If not, a timeout has occurred.<br>
</div>
<pre><span id="VALpipe_wait_rd"><span class="keyword">val</span> pipe_wait_rd</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a> -> float -> bool</code></pre><pre><span id="VALpipe_wait_wr"><span class="keyword">val</span> pipe_wait_wr</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a> -> float -> bool</code></pre><div class="info">
Wait until the pipe becomes readable or writable. The float argument
      is the timeout in seconds. The function returns whether there is
      data to read or write. If not, a timeout has occurred.<br>
</div>
<pre><span id="VALpipe_server_descr"><span class="keyword">val</span> pipe_server_descr</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe_server">w32_pipe_server</a> -> Unix.file_descr</code></pre><div class="info">
Returns the proxy descriptor for the pipe server. See <code class="code">lookup</code> below for
      more on proxy descriptors. This function always returns the same
      descriptor. The user has to close this descriptor if this function
      is called.<br>
</div>
<pre><span id="VALpipe_descr"><span class="keyword">val</span> pipe_descr</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a> -> Unix.file_descr</code></pre><div class="info">
Returns the proxy descriptor for the pipe. See <code class="code">lookup</code> below for
      more on proxy descriptors. This function always returns the same
      descriptor. The user has to close this descriptor if this function
      is called.<br>
</div>
<pre><span id="VALpipe_name"><span class="keyword">val</span> pipe_name</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a> -> string</code></pre><pre><span id="VALpipe_server_name"><span class="keyword">val</span> pipe_server_name</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe_server">w32_pipe_server</a> -> string</code></pre><div class="info">
Returns the name of the pipe<br>
</div>
<pre><span id="VALpipe_mode"><span class="keyword">val</span> pipe_mode</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a> -> <a href="Netsys_win32.html#TYPEpipe_mode">pipe_mode</a></code></pre><pre><span id="VALpipe_server_mode"><span class="keyword">val</span> pipe_server_mode</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe_server">w32_pipe_server</a> -> <a href="Netsys_win32.html#TYPEpipe_mode">pipe_mode</a></code></pre><div class="info">
Returns the pipe/server mode<br>
</div>
<pre><span id="VALunpredictable_pipe_name"><span class="keyword">val</span> unpredictable_pipe_name</span> : <code class="type">unit -> string</code></pre><div class="info">
Returns a valid pipe name that can practically not be predicted<br>
</div>
<br>
<b>Shutting down pipes.</b> The suggested model is that the client shuts
    down the pipe first. A pipe client ensures that all data are transmitted
    by waiting until the pipe becomes writable again, and then calling
    <code class="code">pipe_shutdown</code>. The server then sees EOF when reading from the pipe,
    or gets an <code class="code">EPIPE</code> error when writing to the pipe. The server should
    then also <code class="code">pipe_shutdown</code> the endpoint.
<p>

    When servers start the closure of connections, there is no clean way
    of ensuring that all written data are transmitted. There is the
    <code class="code">FlushFileBuffers</code> Win32 function, but it is blocking.<br>
<br>
<span id="1_IOthreads"><h1>I/O threads</h1></span><br>
<br>
I/O threads can be used to do read/write-based I/O in an asynchronous
    way for file handles that do not support asynchronous I/O by themselves,
    e.g. anonymous pipes.
<p>

    I/O threads are only available if the application is compiled as
    multi-threaded program.<br>
<pre><span id="TYPEw32_input_thread"><span class="keyword">type</span> <code class="type"></code>w32_input_thread</span> </pre>

<pre><span id="VALcreate_input_thread"><span class="keyword">val</span> create_input_thread</span> : <code class="type">Unix.file_descr -> <a href="Netsys_win32.html#TYPEw32_input_thread">w32_input_thread</a></code></pre><div class="info">
Creates the input thread for this file descriptor. Data is being
     pumped from this handle to an internal buffer, and can be read from
     there by <code class="code">input_thread_read</code>.
<p>

     The thread continues to run until EOF is reached, an I/O error
     occurs, or until the
     thread is cancelled (<code class="code">cancel_input_thread</code>).
<p>

     After starting the input thread, the file descriptor must not
     be used anymore. It is now owned by the input thread.<br>
</div>
<pre><span id="VALinput_thread_event"><span class="keyword">val</span> input_thread_event</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_input_thread">w32_input_thread</a> -> <a href="Netsys_win32.html#TYPEw32_event">w32_event</a></code></pre><div class="info">
This event is signaled when there is data to read, or the EOF
     is reached, or there is an error condition<br>
</div>
<pre><span id="VALinput_thread_read"><span class="keyword">val</span> input_thread_read</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_input_thread">w32_input_thread</a> -> string -> int -> int -> int</code></pre><div class="info">
<code class="code">input_thread_read t s pos len</code>: Tries to read data from the buffer. 
      If data
      is available, it is put into the <code class="code">len</code> bytes at position <code class="code">pos</code> of
      the string <code class="code">s</code>, and the actual number of read bytes is returned.
<p>

      If no data is available, the function fails with a Unix error of
      <code class="code">EAGAIN</code> (non-blocking).
<p>

      If the end of the data is reached, the function returns 0.
<p>

      For cancelled requests, the function raises <code class="code">EPERM</code>.<br>
</div>
<pre><span id="VALcancel_input_thread"><span class="keyword">val</span> cancel_input_thread</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_input_thread">w32_input_thread</a> -> unit</code></pre><div class="info">
Stops the input thread. No more data will be pumped from the handle
      to the internal buffer. It is no error to cancel a thread that is
      already cancelled. There is no way to restart the thread later.
<p>

      The thread is automatically cancelled by the GC finaliser. However,
      users are encouraged to call <code class="code">cancel_input_thread</code> as soon as
      the thread is no longer needed, because a thread is an expensive
      resource.
<p>

      Implementation note: Actually, cancellation is only fully implemented
      on Windows Vista. On XP the actual cancellation may be delayed
      indefinetely.<br>
</div>
<pre><span id="VALinput_thread_proxy_descr"><span class="keyword">val</span> input_thread_proxy_descr</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_input_thread">w32_input_thread</a> -> Unix.file_descr</code></pre><div class="info">
Returns the proxy descriptor<br>
</div>
<pre><span id="TYPEw32_output_thread"><span class="keyword">type</span> <code class="type"></code>w32_output_thread</span> </pre>

<pre><span id="VALcreate_output_thread"><span class="keyword">val</span> create_output_thread</span> : <code class="type">Unix.file_descr -> <a href="Netsys_win32.html#TYPEw32_output_thread">w32_output_thread</a></code></pre><div class="info">
Creates the output thread for this file descriptor. Data is being
     pumped an internal buffer to this descriptor, and can be written
     there by <code class="code">output_thread_read</code>.
<p>

     The thread continues to run until it is explicitly closed, or 
     an I/O error occurs, or until the
     thread is cancelled (<code class="code">cancel_output_thread</code>).
<p>

     After starting the output thread, the file descriptor must not
     be used anymore. It is now owned by the output thread.<br>
</div>
<pre><span id="VALoutput_thread_event"><span class="keyword">val</span> output_thread_event</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_output_thread">w32_output_thread</a> -> <a href="Netsys_win32.html#TYPEw32_event">w32_event</a></code></pre><div class="info">
This event is signaled when there is space in the buffer,
      or when there is an error condition<br>
</div>
<pre><span id="VALoutput_thread_write"><span class="keyword">val</span> output_thread_write</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_output_thread">w32_output_thread</a> -> string -> int -> int -> int</code></pre><div class="info">
<code class="code">output_thread_write t s pos len</code>: Tries to write data to the buffer. 
      If this
      is possible, the substring starting at position <code class="code">pos</code> of the string <code class="code">s</code>
      with a length of <code class="code">len</code> is appended to the buffer. The actual number
      of written bytes is returned.
<p>

      If no space is available in the buffer, the function fails with a
      Unix error of <code class="code">EAGAIN</code> (non-blocking).
<p>

      For cancelled requests, the function raises <code class="code">EPERM</code>.<br>
</div>
<pre><span id="VALclose_output_thread"><span class="keyword">val</span> close_output_thread</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_output_thread">w32_output_thread</a> -> unit</code></pre><div class="info">
Adds the EOF condition to the buffer. When the buffer is written
      to the descriptor, the descriptor will be closed.
<p>

      Note that this is also an asynchronous operation, like
      <code class="code">output_thread_write</code>. If closing is not possible at a certain
      moment, the Unix error <code class="code">EGAIN</code> is raised. This ensures that all
      errors of previous writes can be reported.
<p>

      The output thread terminates after a successful close.
<p>

      For cancelled requests, the function raises <code class="code">EPERM</code>.<br>
</div>
<pre><span id="VALcancel_output_thread"><span class="keyword">val</span> cancel_output_thread</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_output_thread">w32_output_thread</a> -> unit</code></pre><div class="info">
Stops the output thread. This is different from closing as the
      data that is still in the buffer but not yet written may be
      dropped (if possible). Also, there is no error reporting.
<p>

      It is no error to cancel a thread that is
      already cancelled or closed. 
      There is no way to restart the thread later.
<p>

      The thread is automatically cancelled by the GC finaliser. However,
      users are encouraged to call <code class="code">cancel_output_thread</code> or
      <code class="code">close_output_thread</code> as soon as
      the thread is no longer needed, because a thread is an expensive
      resource.
<p>

      Implementation note: Actually, cancellation is only fully implemented
      on Windows Vista. On XP the actual cancellation may be delayed
      indefinetely.<br>
</div>
<pre><span id="VALoutput_thread_proxy_descr"><span class="keyword">val</span> output_thread_proxy_descr</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_output_thread">w32_output_thread</a> -> Unix.file_descr</code></pre><div class="info">
Returns the proxy descriptor<br>
</div>
<br>
<span id="1_Processes"><h1>Processes</h1></span><br>
<br>
Keep in mind that Win32 distinguishes between two kinds of
    executables: console applications, and GUI applications. The kind
    is set at link time, and stored in the executable file. 
    Years ago, these kinds meant different worlds,
    and a GUI application could not act like a console application,
    and vice versa. Nowaways, however, the distinction is mostly gone,
    and the application kind only affects defaults at program startup:
<p>
<ul>
<li>Console: A GUI application starts without console. However, it is 
      possible to allocate a console later. A console application always
      starts with a console which is created by the OS if missing.</li>
<li>Standard handles: For a GUI application, stdin/stdout/stderr are
      initially set to the invalid file handle. Nevertheless, this
      feature of standard handles exists, and one can set these handles
      later. Also, the handles can be inherited by the parent process.
      For console applications, the standard handles are normally set
      to the console, and applications can redirect them.</li>
<li>Main program: Of course, there is also the difference which C
      function is called at program startup - hey, but this is O'Caml!</li>
<li>Waiting for completion: It is uncommon to wait for the completion
      of GUI applications. The command interpreter seems to implement
      a magic so that it is not waited until the program is finished
      when a GUI application is started. For console applications this
      is of course done. (Note that this feature is the main reason
      why programmers still have to link applications as console
      applications, and cannot simply get the same effect from a
      application that is linked as GUI and then opens a console.)</li>
</ul>
<br>
<br><code><span id="TYPEcreate_process_option"><span class="keyword">type</span> <code class="type"></code>create_process_option</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CP_change_directory</span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The initial working directory is set to this path. By default
          the new process starts with the current working directory of
          the caller.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CP_set_env</span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The process environment is set to this encoded array of environment
          variables. By default the current environment is passed down
          to the new process.
<p>

          The string is created from an array of "name=value" settings
          by separating all elements by null bytes, and by putting two
          null bytes at the end.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CP_std_handles</span> <span class="keyword">of</span> <code class="type">Unix.file_descr * Unix.file_descr * Unix.file_descr</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Sets the standard handles of the new console process.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CP_create_console</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Creates a new console window. The standard handles of the new
          process may also be modified - however, the exact effect is not
          well documented by Microsoft. I have the impression that the logic
          is this: handles pointing to the parent console are replaced by
          handles pointing to the new console. Also, invalid handles
          are replaced by handles of the new console. It does not matter how
          the standard handles are passed down - either implicitly or by
          <code class="code">CP_std_handles</code>. So you cannot create a new console, and
          keep standard handles that are connected to the old console.
          Best practice is to avoid the combination of <code class="code">CP_std_handles</code> and
          <code class="code">CP_create_console</code> when there is already a console.
<p>

          This flag does not have any effect when the started app is
          a GUI app.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CP_detach_from_console</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The new process detaches from the console at startup, even if it is
          a console application. Unless <code class="code">CP_std_handles</code> is specified,
          the new process will initially not have standard handles (i.e.
          the standard handles are invalid handles)!
          GUI apps detach from the console anyway.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CP_inherit_console</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The new console process inherits the console from the caller, if
          present. Otherwise the new console process starts without console.
          For GUI apps there is not any effect: They do not have a console
          anyway.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CP_inherit_or_create_console</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >If present, the console is inherited from the caller. If not
          present, a new console is created for console applications. 
          This mode is the default.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CP_unicode_environment</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Indicates that the environment is a Unicode environment</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CP_ansi_environment</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Indicates that the environment is an ANSI environment. This
          is the default.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CP_new_process_group</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The new process is run in a new process group</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CP_inherit_process_group</span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The new process is run in the same process group as the caller.
          This is the default</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>


<pre><span id="VALcp_set_env"><span class="keyword">val</span> cp_set_env</span> : <code class="type">string array -> <a href="Netsys_win32.html#TYPEcreate_process_option">create_process_option</a></code></pre><div class="info">
Returns the <code class="code">CP_set_env</code> option for this array of environment
      variables (in the <code class="code">Unix.environment</code> format)<br>
</div>
<pre><span id="VALsearch_path"><span class="keyword">val</span> search_path</span> : <code class="type">string option -> string -> string option -> string</code></pre><div class="info">
<code class="code">search_path path_opt name ext_opt</code>: Uses the SearchPath function
      to locate a file. If <code class="code">name</code> does not end with <code class="code">ext_opt</code>, this
      extension is added during the search. If <code class="code">path_opt</code> is <code class="code">None</code>,
      the default search path is used.<br>
</div>
<pre><span id="TYPEw32_process"><span class="keyword">type</span> <code class="type"></code>w32_process</span> </pre>
<div class="info">
A handle to spawned processes<br>
</div>

<pre><span id="VALcreate_process"><span class="keyword">val</span> create_process</span> : <code class="type">string -><br>       string -> <a href="Netsys_win32.html#TYPEcreate_process_option">create_process_option</a> list -> <a href="Netsys_win32.html#TYPEw32_process">w32_process</a></code></pre><div class="info">
<code class="code">create_process cmd cmdline options</code>: Spawns a new process that runs
      concurrently with the calling process. <code class="code">cmd</code> is the command
      to execute (it is not searched by path, and the file suffix must be
      given). <code class="code">cmdline</code> is the full command-line.
<p>

      If the exit code of the new process does not play any role, it is
      ok to just ignore the returned process handle (which will be
      automatically closed by a GC finalizer).<br>
</div>
<pre><span id="VALclose_process"><span class="keyword">val</span> close_process</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_process">w32_process</a> -> unit</code></pre><div class="info">
Closes the handle in the <code class="code">w32_process</code> value, if it is still open<br>
</div>
<pre><span id="VALget_process_status"><span class="keyword">val</span> get_process_status</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_process">w32_process</a> -> Unix.process_status option</code></pre><div class="info">
Returns the process result if the process is finished, and <code class="code">None</code>
      otherwise<br>
</div>
<pre><span id="VALas_process_event"><span class="keyword">val</span> as_process_event</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_process">w32_process</a> -> <a href="Netsys_win32.html#TYPEw32_event">w32_event</a></code></pre><div class="info">
Casts the process handle to an event handle. The process handle
      is in signaled state as soon as the spawned process is terminated.
      The event handle can be used in <code class="code">event_wait</code> (above) and 
      <code class="code">wsa_wait_for_multiple_events</code> to wait for the termination of the
      process.<br>
</div>
<pre><span id="VALemulated_pid"><span class="keyword">val</span> emulated_pid</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_process">w32_process</a> -> int</code></pre><div class="info">
Returns the MSVCRT.DLL notion of the process identifier (pid).
      This kind of pid is used in the <code class="code">Unix</code> library to refer to
      processes, especially in <code class="code">waitpid</code>. Note that the pid is actually
      a handle, and it must be closed by calling <code class="code">Unix.waitpid</code>.
<p>

      Each call of <code class="code">emulated_pid</code> returns a new handle.<br>
</div>
<pre><span id="VALwin_pid"><span class="keyword">val</span> win_pid</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_process">w32_process</a> -> int</code></pre><div class="info">
Returns the Windows notion of the process identifier (pid)<br>
</div>
<pre><span id="VALprocess_descr"><span class="keyword">val</span> process_descr</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_process">w32_process</a> -> Unix.file_descr</code></pre><div class="info">
Returns the proxy descriptor of the process<br>
</div>
<pre><span id="VALterminate_process"><span class="keyword">val</span> terminate_process</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_process">w32_process</a> -> unit</code></pre><div class="info">
Terminates the process<br>
</div>
<br>
<span id="1_Consoles"><h1>Consoles</h1></span><br>
<pre><span id="VALhas_console"><span class="keyword">val</span> has_console</span> : <code class="type">unit -> bool</code></pre><div class="info">
True if there is a console<br>
</div>
<pre><span id="VALis_console"><span class="keyword">val</span> is_console</span> : <code class="type">Unix.file_descr -> bool</code></pre><div class="info">
Tests whether the descriptor is the input or the output stream of the
      console.<br>
</div>
<pre><span id="VALget_console_input"><span class="keyword">val</span> get_console_input</span> : <code class="type">unit -> Unix.file_descr</code></pre><div class="info">
Get the input stream of the console. If there is no console yet,
      a new one is opened.
<p>

      The returned descriptor needs to be closed by the caller when done
      with it.<br>
</div>
<pre><span id="VALget_console_output"><span class="keyword">val</span> get_console_output</span> : <code class="type">unit -> Unix.file_descr</code></pre><div class="info">
Get the output stream of the console. If there is no console yet,
      a new one is opened
<p>

      The returned descriptor needs to be closed by the caller when done
      with it.<br>
</div>
<br>
We use a simplified model of the console where only the visible part
    of the buffer is represented. All coordinates are relative to the
    visible part of the buffer.<br>
<br><code><span id="TYPEw32_console_attr"><span class="keyword">type</span> <code class="type"></code>w32_console_attr</span> = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>cursor_x&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >from 0 (leftmost) to <code class="code">width-1</code> (rightmost)</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>cursor_y&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >from 0 (topmost) to <code class="code">height-1</code> (bottommost)</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>cursor_size&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >from 1 to 100</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>cursor_visible&nbsp;: <code class="type">bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>text_attr&nbsp;: <code class="type">int</code>;</code></td>

</tr></table>
}


<br><code><span id="TYPEw32_console_info"><span class="keyword">type</span> <code class="type"></code>w32_console_info</span> = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>width&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >screen width of the console in chars</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>height&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >screen height in lines</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}


<pre><span id="VALget_console_attr"><span class="keyword">val</span> get_console_attr</span> : <code class="type">unit -> <a href="Netsys_win32.html#TYPEw32_console_attr">w32_console_attr</a></code></pre><pre><span id="VALset_console_attr"><span class="keyword">val</span> set_console_attr</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_console_attr">w32_console_attr</a> -> unit</code></pre><div class="info">
Get/set console attributes.<br>
</div>
<pre><span id="VALget_console_info"><span class="keyword">val</span> get_console_info</span> : <code class="type">unit -> <a href="Netsys_win32.html#TYPEw32_console_info">w32_console_info</a></code></pre><div class="info">
Get r/o console info.<br>
</div>
<pre><span id="VALfg_blue"><span class="keyword">val</span> fg_blue</span> : <code class="type">int</code></pre><pre><span id="VALfg_green"><span class="keyword">val</span> fg_green</span> : <code class="type">int</code></pre><pre><span id="VALfg_red"><span class="keyword">val</span> fg_red</span> : <code class="type">int</code></pre><pre><span id="VALfg_intensity"><span class="keyword">val</span> fg_intensity</span> : <code class="type">int</code></pre><pre><span id="VALbg_blue"><span class="keyword">val</span> bg_blue</span> : <code class="type">int</code></pre><pre><span id="VALbg_green"><span class="keyword">val</span> bg_green</span> : <code class="type">int</code></pre><pre><span id="VALbg_red"><span class="keyword">val</span> bg_red</span> : <code class="type">int</code></pre><pre><span id="VALbg_intensity"><span class="keyword">val</span> bg_intensity</span> : <code class="type">int</code></pre><div class="info">
Bits of <code class="code">text_attr</code><br>
</div>
<br><code><span id="TYPEw32_console_mode"><span class="keyword">type</span> <code class="type"></code>w32_console_mode</span> = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>enable_echo_input&nbsp;: <code class="type">bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>enable_insert_mode&nbsp;: <code class="type">bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>enable_line_input&nbsp;: <code class="type">bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>enable_processed_input&nbsp;: <code class="type">bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>enable_quick_edit_mode&nbsp;: <code class="type">bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>enable_processed_output&nbsp;: <code class="type">bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>enable_wrap_at_eol_output&nbsp;: <code class="type">bool</code>;</code></td>

</tr></table>
}

<div class="info">
See the msdn docs for GetConsoleMode for details<br>
</div>

<pre><span id="VALget_console_mode"><span class="keyword">val</span> get_console_mode</span> : <code class="type">unit -> <a href="Netsys_win32.html#TYPEw32_console_mode">w32_console_mode</a></code></pre><pre><span id="VALset_console_mode"><span class="keyword">val</span> set_console_mode</span> : <code class="type"><a href="Netsys_win32.html#TYPEw32_console_mode">w32_console_mode</a> -> unit</code></pre><div class="info">
Get/set the console mode.<br>
</div>
<pre><span id="VALinit_console_codepage"><span class="keyword">val</span> init_console_codepage</span> : <code class="type">unit -> unit</code></pre><div class="info">
Sets the code page of the console to the ANSI code page of the
      system. Unfortunately, the console uses the OEM code page by default
      (e.g. code page 437 instead of 1252). This function changes the
      code page back to the ANSI version.
<p>

      Note, however, that the docs say: "If the current font is a
      raster font, SetConsoleOutputCP does not affect how extended characters
      are displayed." (grrmmpf) So you should also switch to a different
      font - otherwise you get input in the ANSI code page, and do output
      in the OEM code page.
<p>

      For Windows novices: Historically, there were two types of 8 bit
      character sets. The older type is an IBM code page, and predates
      the ISO-8859 series of character sets. This code page was used
      at MS-DOS times.  Microsoft calls this code page the "OEM" code
      page. Later, when ISO-8859 was created, Microsoft switched to
      code pages that are similar to this standard, but also do not
      fully match them. These newer code pages have names like
      "Windows-1252", and are now called ANSI code pages by Microsoft.
      The 8-bit versions of the Win32 calls (which are used by the
      Ocaml runtime)normally use the ANSI code page.<br>
</div>
<pre><span id="VALclear_until_end_of_line"><span class="keyword">val</span> clear_until_end_of_line</span> : <code class="type">unit -> unit</code></pre><div class="info">
Writes a space character from the current cursor position to the
      end of the line<br>
</div>
<pre><span id="VALclear_until_end_of_screen"><span class="keyword">val</span> clear_until_end_of_screen</span> : <code class="type">unit -> unit</code></pre><div class="info">
Writes a space character from the current cursor position to the
      end of the screen<br>
</div>
<pre><span id="VALclear_console"><span class="keyword">val</span> clear_console</span> : <code class="type">unit -> unit</code></pre><div class="info">
Clears the screen and the buffer, and sets the cursor to (0,0).<br>
</div>
<br>
<span id="1_Miscelleneous"><h1>Miscelleneous</h1></span><br>
<pre><span id="VALget_active_code_page"><span class="keyword">val</span> get_active_code_page</span> : <code class="type">unit -> int</code></pre><div class="info">
Get the active code page. See 
      http://msdn.microsoft.com/en-us/library/dd317756%28v=VS.85%29.aspx
      for a list of codes. Also see <a href="Netconversion.html#VALwin32_code_pages"><code class="code">Netconversion.win32_code_pages</code></a>.<br>
</div>
<br>
<span id="1_ProxyDescriptors"><h1>Proxy Descriptors</h1></span><br>
<br>
For a number of objects (<code class="code">w32_event</code>, <code class="code">w32_pipe</code>, and <code class="code">w32_pipe_server</code>) 
    it is possible
    to obtain proxy descriptors. These have type <code class="code">Unix.file_descr</code> and they
    contain a real file handle. The purpose of these descriptors is to
    be used as proxy objects that can be passed to functions expecting
    file descriptors as input. However, you cannot do anything with the
    proxies except looking the corresponding real objects up. Proxy
    descriptors are used in interfaces that only allow to pass
    <code class="code">Unix.file_descr</code> values in and out.
<p>

    Proxy descriptors have to be closed by the caller once they have
    been handed out to the caller. Closing the proxy descriptor does not
    make the descriptor unusable (lookups still work), and the referenced 
    object is also 
    unaffected. It is up to the user when <code class="code">Unix.close</code> is best called -
    it is even allowed to do it immediately after requesting the proxy
    descriptor, e.g. via <code class="code">pipe_descr</code>. After closing the proxy, however,
    it is possible that the system generates another file descriptor
    that looks equal to the closed proxy. It is often best to close at the
    moment when one is really done with the proxy.<br>
<br><code><span id="TYPEw32_object"><span class="keyword">type</span> <code class="type"></code>w32_object</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">W32_event</span> <span class="keyword">of</span> <code class="type"><a href="Netsys_win32.html#TYPEw32_event">w32_event</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">W32_pipe</span> <span class="keyword">of</span> <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">W32_pipe_server</span> <span class="keyword">of</span> <code class="type"><a href="Netsys_win32.html#TYPEw32_pipe_server">w32_pipe_server</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">W32_process</span> <span class="keyword">of</span> <code class="type"><a href="Netsys_win32.html#TYPEw32_process">w32_process</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">W32_input_thread</span> <span class="keyword">of</span> <code class="type"><a href="Netsys_win32.html#TYPEw32_input_thread">w32_input_thread</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">W32_output_thread</span> <span class="keyword">of</span> <code class="type"><a href="Netsys_win32.html#TYPEw32_output_thread">w32_output_thread</a></code></code></td>

</tr></table>


<pre><span id="VALlookup"><span class="keyword">val</span> lookup</span> : <code class="type">Unix.file_descr -> <a href="Netsys_win32.html#TYPEw32_object">w32_object</a></code></pre><div class="info">
Returns the real object behind a proxy descriptor, or raises
      <code class="code">Not_found</code>. Note that the returned object needs not to be physically
      identical to the original object. It behaves, however, exactly the
      same way.<br>
</div>
<pre><span id="VALlookup_event"><span class="keyword">val</span> lookup_event</span> : <code class="type">Unix.file_descr -> <a href="Netsys_win32.html#TYPEw32_event">w32_event</a></code></pre><pre><span id="VALlookup_pipe"><span class="keyword">val</span> lookup_pipe</span> : <code class="type">Unix.file_descr -> <a href="Netsys_win32.html#TYPEw32_pipe">w32_pipe</a></code></pre><pre><span id="VALlookup_pipe_server"><span class="keyword">val</span> lookup_pipe_server</span> : <code class="type">Unix.file_descr -> <a href="Netsys_win32.html#TYPEw32_pipe_server">w32_pipe_server</a></code></pre><pre><span id="VALlookup_process"><span class="keyword">val</span> lookup_process</span> : <code class="type">Unix.file_descr -> <a href="Netsys_win32.html#TYPEw32_process">w32_process</a></code></pre><pre><span id="VALlookup_input_thread"><span class="keyword">val</span> lookup_input_thread</span> : <code class="type">Unix.file_descr -> <a href="Netsys_win32.html#TYPEw32_input_thread">w32_input_thread</a></code></pre><pre><span id="VALlookup_output_thread"><span class="keyword">val</span> lookup_output_thread</span> : <code class="type">Unix.file_descr -> <a href="Netsys_win32.html#TYPEw32_output_thread">w32_output_thread</a></code></pre><div class="info">
Returns the real object. If not found, or if the object is of unexpected
      type, <code class="code">Failure</code> is raised.<br>
</div>
<pre><span id="VALunregister"><span class="keyword">val</span> unregister</span> : <code class="type">Unix.file_descr -> unit</code></pre><div class="info">
Removes this descriptor from the lookup table. This should only be done
      after it is closed. Calling <code class="code">unregister</code> is optional, and the removal
      will take place anyway when the descriptor is collected by the GC.<br>
</div>
<br>
<span id="1_Miscelleneous"><h1>Miscelleneous</h1></span><br>
<pre><span id="VALtest_close_on_exec"><span class="keyword">val</span> test_close_on_exec</span> : <code class="type">Unix.file_descr -> bool</code></pre><div class="info">
Tests whether the handle is not inheritable<br>
</div>
<pre><span id="VALmodify_close_on_exec"><span class="keyword">val</span> modify_close_on_exec</span> : <code class="type">Unix.file_descr -> bool -> unit</code></pre><div class="info">
Sets the close-on-exec flag, i.e. whether the handle is not inheritable.
      Note that <code class="code">Unix.set_close_on_exec</code> and <code class="code">Unix.clear_close_on_exec</code>
      have a serious problem, and do not always work.<br>
</div>
<pre><span id="VALis_crt_fd"><span class="keyword">val</span> is_crt_fd</span> : <code class="type">Unix.file_descr -> int -> bool</code></pre><div class="info">
Tests whether the descriptor has a certain CRT counterpart.
      E.g. use <code class="code">is_crt_fd 0</code> to check whether <code class="code">fd</code> is <code class="code">Unix.stdin</code>
      (physically)<br>
</div>
<pre><span id="VALfill_random"><span class="keyword">val</span> fill_random</span> : <code class="type">string -> unit</code></pre><div class="info">
Fills the string with random bytes. A cryptographically secure RNG
      is used<br>
</div>
<br>
<span id="1_Debugging"><h1>Debugging</h1></span><br>
<pre><span class="keyword">module</span> <a href="Netsys_win32.Debug.html">Debug</a>: <code class="code">sig</code> <a href="Netsys_win32.Debug.html">..</a> <code class="code">end</code></pre></body></html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Netmech_scram_gssapi.html">
<link rel="next" href="Netmcore_camlbox.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Https_client" rel="Chapter" href="Https_client.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Ftp_fs" rel="Chapter" href="Ftp_fs.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgssapi" rel="Chapter" href="Netgssapi.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html"><link title="Types and exceptions" rel="Section" href="#2_Typesandexceptions">
<link title="Defining processes" rel="Section" href="#2_Definingprocesses">
<link title="Managing resources from worker processes" rel="Section" href="#2_Managingresourcesfromworkerprocesses">
<link title="Initialization and system start" rel="Section" href="#2_Initializationandsystemstart">
<title>Ocamlnet 3 Reference Manual : Netmcore</title>
</head>
<body>
<div class="navbar"><a href="Netmech_scram_gssapi.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Netmcore_camlbox.html">Next</a>
</div>
<center><h1>Module <a href="type_Netmcore.html">Netmcore</a></h1></center>
<br>
<pre><span class="keyword">module</span> Netmcore: <code class="code">sig</code> <a href="Netmcore.html">..</a> <code class="code">end</code></pre>Multi-processing for compute jobs
<p>

    This library allows it to develop parallel algorithms that can take
    advantage of multiple CPU cores. It does not use Ocaml's multi-threading
    feature because this would implicitly serialize all computations.
    Instead, independent processes are created, and the communication
    between processes is made as cheap and unproblematic as possible.
<p>

    Before using this library, it is required to call <a href="Netmcore.html#VALstartup"><code class="code">Netmcore.startup</code></a>.
    This turns the current process into the master process. The master
    process has only a supervising function, and is responsible for
    managing global resources, and for starting further worker processes.
<p>

    The worker processes can start more workers. This is different from
    creating a new thread, though: The new worker does not share memory
    with its creator. It is also different from calling <code class="code">Unix.fork</code>,
    because new workers are always subprocesses of the master process.
    This means it is not initialized with a copy of the state of the
    logical creator, but with its real parent process which is always
    the master.
<p>

    Compatibility with multi-threading: You may run into big trouble
    when the master process starts further threads (after forking 
    thread-related resources are in an uncontrolled state). There is
    no such problem in the worker processes. In this library,
    however, nothing is done to ease the multi-threaded life, so you
    should carefully check the compatibility first.<br>
<hr width="100%">
<br>
<span id="2_Typesandexceptions"><h2>Types and exceptions</h2></span><br>
<pre><span id="TYPEres_id"><span class="keyword">type</span> <code class="type"></code>res_id</span> = <code class="type">[ `Resource of int ]</code> </pre>
<div class="info">
This tagged integer identifies resources. This variant type will never
      be extended.<br>
</div>

<pre><span id="TYPEprocess_id"><span class="keyword">type</span> <code class="type"></code>process_id</span> = <code class="type">[ `Process of int ]</code> </pre>
<div class="info">
This tagged integer identifies processes. This variant type will never
      be extended.<br>
</div>

<pre><span id="TYPEcompute_resource_type"><span class="keyword">type</span> <code class="type"></code>compute_resource_type</span> = <code class="type">[ `File<br>       | `Fork_point<br>       | `Join_point<br>       | `Posix_sem<br>       | `Posix_shm<br>       | `Posix_shm_preallocated ]</code> </pre>

<pre><span id="TYPEinherit_request"><span class="keyword">type</span> <code class="type"></code>inherit_request</span> = <code class="type">[ `All | `Resources of <a href="Netmcore.html#TYPEres_id">res_id</a> list ]</code> </pre>

<pre><span id="TYPEcompute_resource_repr"><span class="keyword">type</span> <code class="type"></code>compute_resource_repr</span> = <code class="type">[ `File of string<br>       | `Fork_point of<br>           <a href="Netmcore.html#TYPEinherit_request">inherit_request</a> * <a href="Netplex_encap.html#TYPEencap">Netplex_encap.encap</a> -> <a href="Netmcore.html#TYPEprocess_id">process_id</a><br>       | `Join_point of <a href="Netmcore.html#TYPEprocess_id">process_id</a> -> <a href="Netplex_encap.html#TYPEencap">Netplex_encap.encap</a> option<br>       | `Posix_sem of string<br>       | `Posix_shm of string<br>       | `Posix_shm_preallocated of string * <a href="Netsys_mem.html#TYPEmemory">Netsys_mem.memory</a> ]</code> </pre>
<div class="info">
Centrally managed resources include:<ul>
<li><code class="code">`File name</code>: Files <code class="code">name</code> (absolute name)</li>
<li><code class="code">`Posix_shm name</code>: Shared memory objects with <code class="code">name</code></li>
<li><code class="code">`Posix_shm_preallocated(name,m)</code>: Shared memory objects already
        allocated by the master process. These objects are passed over
        to the worker processes by inheritance, and are always mapped at
        the same address. <code class="code">m</code> is the bigarray mapping the object.</li>
<li><code class="code">`Posix_sem name</code>: Semaphores with <code class="code">name</code></li>
<li><code class="code">`Fork_point(inh,f)</code>: Fork points where <code class="code">let pid=f arg</code> fork a new process
        with argument <code class="code">arg</code>. <code class="code">pid</code> is the process identifier. The list <code class="code">inh</code>
        are resources inherited from the master.</li>
<li><code class="code">`Joint_point f</code>: Joint points where <code class="code">let res=f pid</code> wait until
        the process <code class="code">pid</code> terminates. If <code class="code">res</code> is non-<code class="code">None</code> it is the
        result value. If it is <code class="code">None</code>, no result was passed back
        (including all pathological cases like crashes)</li>
</ul>
<br>
</div>

<pre><span id="EXCEPTIONNo_resource"><span class="keyword">exception</span> No_resource</span> <span class="keyword">of</span> <code class="type"><a href="Netmcore.html#TYPEres_id">res_id</a></code></pre>
<div class="info">
No such resource, or no resource of the expected type<br>
</div>
<pre><span id="TYPEcompute_resource"><span class="keyword">class type</span> <a href="Netmcore.compute_resource-c.html">compute_resource</a></span> = <code class="code">object</code> <a href="Netmcore.compute_resource-c.html">..</a> <code class="code">end</code></pre><br>
<span id="2_Definingprocesses"><h2>Defining processes</h2></span><br>
<br>
This is the lower-level version of the process API where arguments
    and results of processes are dynamically typed. It may have some
    uses when writing generic process managers, but for the
    normal application the statically typed API in <a href="Netmcore_process.html"><code class="code">Netmcore_process</code></a>
    is easier to use (and less verbose).<br>
<pre><span id="VALdef_process"><span class="keyword">val</span> def_process</span> : <code class="type">(<a href="Netplex_encap.html#TYPEencap">Netplex_encap.encap</a> -> <a href="Netplex_encap.html#TYPEencap">Netplex_encap.encap</a>) -><br>       <a href="Netmcore.html#TYPEres_id">res_id</a> * <a href="Netmcore.html#TYPEres_id">res_id</a></code></pre><div class="info">
<code class="code">let fork_point, join_point = def_process f</code>:
      Defines process types, i.e. ways of starting and finishing processes. 
      The definition must be done in the master process, e.g. before the first
      worker is started. 
<p>

      Once the process type is defined, new processes can be started,
      and these processes will run the function <code class="code">f</code>. When <code class="code">f</code> is 
      finished, the process will terminate. Starting processes is possible
      from other worker processes.
<p>

      <code class="code">f</code> is supplied with its argument by the process starter <code class="code">start</code>.
      The result value of <code class="code">f</code> can be retrieved with <code class="code">join</code> (by any
      process, but only the first <code class="code">join</code> for this process will be successful).
<p>

      If <code class="code">f</code> throws exceptions, these will be caught and logged, but not
      be passed back to the caller (which just gets <code class="code">None</code> as result
      of <code class="code">join</code>). The same happens for any unplanned termination of the
      process.
<p>

      It is allowed to immediately release the <code class="code">join_point</code> if there is
      no interest in catching the termination of started processes.
<p>

      Here is an example how to define a process that takes a <code class="code">string</code>
      argument and returns an <code class="code">int</code>:
<p>

      <pre><code class="code">      module String_encap = Netplex_encap.Make_encap(struct type t=string end)
      module Int_encap = Netplex_encap.Make_encap(struct type t=int end)

      let my_process_fork, my_process_join =
        Netmcore.def_process
          (fun s_encap -&gt;
            let (s:string) = String_encap.unwrap s_encap in
            let (r:int) = ... in
            Int_encap.wrap r
          )
      </code></pre>
<p>

      The wrapping and unwrapping is required for ensuring type-safety
      (see <a href="Netplex_encap.html"><code class="code">Netplex_encap</code></a> for the details of the idea).
<p>

      Calling this process is done with (also see below):
<p>

      <pre><code class="code">      let pid = Netmcore.start my_process_fork (String_encap.wrap s) in
      let r_encap_opt = Netmcore.join my_process_join pid in
      match r_encap_opt with
        | None -&gt; failwith "Something went wrong"
        | Some r_encap -&gt; Int_encap.unwrap r_encap
      </code></pre><br>
</div>
<br>
The following functions can also be called from worker processes
    (i.e. Netplex containers)<br>
<pre><span id="VALstart"><span class="keyword">val</span> start</span> : <code class="type">?inherit_resources:<a href="Netmcore.html#TYPEinherit_request">inherit_request</a> -><br>       <a href="Netmcore.html#TYPEres_id">res_id</a> -> <a href="Netplex_encap.html#TYPEencap">Netplex_encap.encap</a> -> <a href="Netmcore.html#TYPEprocess_id">process_id</a></code></pre><div class="info">
<code class="code">let pid = start fork_point arg</code>: Starts the process with the
      given <code class="code">fork_point</code> and the argument <code class="code">arg</code>.
<p>

      Raises <code class="code">No_resource</code> if there is no such resource.
<p>

      The function returns a process identifier. This is not the Unix
      PID, but a sequentially generated number that is unique for a
      running program.
<p>

      Option <code class="code">inherit_resources</code>: Certain resources are only accessible by
      the process when they are inherited to it. This is the case for
      <code class="code">`Posix_shm_preallocated</code>. This can be set to <code class="code">`All</code> to inherit
      all inheritable resources, or to <code class="code">`Resources l</code> to only inherit
      the resources of <code class="code">l</code>. By default, no resources are inherited.<br>
</div>
<pre><span id="VALjoin"><span class="keyword">val</span> join</span> : <code class="type"><a href="Netmcore.html#TYPEres_id">res_id</a> -> <a href="Netmcore.html#TYPEprocess_id">process_id</a> -> <a href="Netplex_encap.html#TYPEencap">Netplex_encap.encap</a> option</code></pre><div class="info">
<code class="code">let res_opt = join join_point pid</code>: Waits until the process <code class="code">pid</code>
      is done, and returns the result value if any.
<p>

      Raises <code class="code">No_resource</code> if there is no such resource.<br>
</div>
<br>
<span id="2_Managingresourcesfromworkerprocesses"><h2>Managing resources from worker processes</h2></span><br>
<br>
The following functions can also be called from worker processes
    (i.e. Netplex containers)<br>
<pre><span id="VALget_resource"><span class="keyword">val</span> get_resource</span> : <code class="type"><a href="Netmcore.html#TYPEres_id">res_id</a> -> <a href="Netmcore.compute_resource-c.html">compute_resource</a></code></pre><div class="info">
Retrieves the resource by ID. This implicitly also marks this resource
      as being used by this process. Don't forget to call <code class="code">release</code> when
      your are done with the resource.
<p>

      Raises <code class="code">No_resource</code> if there is no such resource.<br>
</div>
<pre><span id="VALrelease"><span class="keyword">val</span> release</span> : <code class="type"><a href="Netmcore.html#TYPEres_id">res_id</a> -> unit</code></pre><div class="info">
Release the resource with this ID. (Same as calling the <code class="code">release</code>
      method on the object.)<br>
</div>
<pre><span id="VALmanage_file"><span class="keyword">val</span> manage_file</span> : <code class="type">string -> <a href="Netmcore.compute_resource-c.html">compute_resource</a></code></pre><div class="info">
hands over a file to the manager<br>
</div>
<pre><span id="VALget_file"><span class="keyword">val</span> get_file</span> : <code class="type"><a href="Netmcore.html#TYPEres_id">res_id</a> -> string</code></pre><div class="info">
Gets the file with this ID (or raises <code class="code">No_resource</code>). As for
      <code class="code">get_resource</code> the file is marked as being used by the process.<br>
</div>
<pre><span id="VALmanage_shm"><span class="keyword">val</span> manage_shm</span> : <code class="type">string -> <a href="Netmcore.compute_resource-c.html">compute_resource</a></code></pre><div class="info">
hands over a named shm object to the manager<br>
</div>
<pre><span id="VALget_shm"><span class="keyword">val</span> get_shm</span> : <code class="type"><a href="Netmcore.html#TYPEres_id">res_id</a> -> string</code></pre><div class="info">
Gets the shm object with this ID (or raises <code class="code">No_resource</code>). As
      for <code class="code">get_resource</code> the shm object is marked as being used by the process.<br>
</div>
<br>
Shared memory objects can be created with <a href="Netsys_posix.html#VALshm_create"><code class="code">Netsys_posix.shm_create</code></a>,
    and opened with <a href="Netsys_posix.html#VALshm_open"><code class="code">Netsys_posix.shm_open</code></a>.<br>
<pre><span id="VALcreate_preallocated_shm"><span class="keyword">val</span> create_preallocated_shm</span> : <code class="type">?value_area:bool -> string -> int -> <a href="Netmcore.html#TYPEres_id">res_id</a> * string</code></pre><div class="info">
<code class="code">create_preallocated_shm prefix size</code>: Creates a new preallocated
      shm object with a unique name based on <code class="code">prefix</code>, and a length of
      <code class="code">size</code> bytes. The object is created and mapped into the master
      process, and will be available to any newly started process when
      the resource ID is inherited to the process.
<p>

      Returns <code class="code">(res_id,shm_name)</code> where <code class="code">res_id</code> identifies the new
      resource, and <code class="code">shm_name</code> is the name of the POSIX shared memory
      object.
<p>

      Note that the process calling this function cannot look up this
      resource (using <code class="code">get_shm</code> or <code class="code">get_resource</code>) because the shm
      block cannot be mapped at the right address. Nevertheless, the calling
      process counts as a user of the object, and needs to release
      the object.
<p>

      Option <code class="code">value_area</code>: if set, the new memory is marked as value
      area, so the ocaml runtime allows value comparisons in this
      memory area.<br>
</div>
<pre><span id="VALmanage_sem"><span class="keyword">val</span> manage_sem</span> : <code class="type">string -> <a href="Netmcore.compute_resource-c.html">compute_resource</a></code></pre><div class="info">
hands over a named semaphore to the manager<br>
</div>
<pre><span id="VALget_sem"><span class="keyword">val</span> get_sem</span> : <code class="type"><a href="Netmcore.html#TYPEres_id">res_id</a> -> string</code></pre><div class="info">
gets the semaphore with this ID (or raises <code class="code">No_resource</code>). As
      for <code class="code">get_resource</code> the semaphore is marked as being used by the process.<br>
</div>
<br>
Semaphores can be opened with <a href="Netsys_posix.html#VALsem_open"><code class="code">Netsys_posix.sem_open</code></a>, and
    created with <a href="Netsys_posix.html#VALsem_create"><code class="code">Netsys_posix.sem_create</code></a>.<br>
<pre><span id="VALself_process_id"><span class="keyword">val</span> self_process_id</span> : <code class="type">unit -> <a href="Netmcore.html#TYPEprocess_id">process_id</a></code></pre><div class="info">
Returns the process ID of a worker<br>
</div>
<br>
<span id="2_Initializationandsystemstart"><h2>Initialization and system start</h2></span><br>
<br>
This module can either be used as Netplex plugin and integrated into
    any existing Netplex program, or it can be started in stand-alone mode<br>
<pre><span id="VALadd_plugins"><span class="keyword">val</span> add_plugins</span> : <code class="type"><a href="Netplex_types.controller-c.html">Netplex_types.controller</a> -> unit</code></pre><div class="info">
To enable compute processes for any Netplex program, call this
      function with the controller object as argument. This can e.g. 
      be done in the <code class="code">post_add_hook</code> of the processor.<br>
</div>
<pre><span id="VALstartup"><span class="keyword">val</span> startup</span> : <code class="type">socket_directory:string -><br>       ?pidfile:string -><br>       ?init_ctrl:(<a href="Netplex_types.controller-c.html">Netplex_types.controller</a> -> unit) -><br>       first_process:(unit -> <a href="Netmcore.html#TYPEprocess_id">process_id</a>) -> unit -> unit</code></pre><div class="info">
This function makes the current process the master process.
      It starts immediately a new worker process, called the 
      first process. The <code class="code">startup</code> function returns first when this
      process is finished, in which case the whole Netplex system is
      shut down (which may lead to killing the remaining processes,
      following the usual shutdown procedure).
<p>

      The first process is created by calling <code class="code">first_process()</code> at the
      right moment. This function normally just invokes <code class="code">start</code>.
<p>

      Passing a <code class="code">socket_directory</code> is mandatory. This directory will
      contain helper files. The must be a separate <code class="code">socket_directory</code>
      for each running Computeplex instance.
<p>

      <code class="code">pidfile</code>: If passed, the PID of the master process is written
      to this file.<br>
</div>
<pre><span id="VALdestroy_resources"><span class="keyword">val</span> destroy_resources</span> : <code class="type">unit -> unit</code></pre><div class="info">
Destroys all resources that may be left<br>
</div>
<pre><span class="keyword">module</span> <a href="Netmcore.Debug.html">Debug</a>: <code class="code">sig</code> <a href="Netmcore.Debug.html">..</a> <code class="code">end</code></pre></body></html>
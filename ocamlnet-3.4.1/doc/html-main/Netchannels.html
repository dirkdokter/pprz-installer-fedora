<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Netconversion.html">
<link rel="next" href="Netstream.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Https_client" rel="Chapter" href="Https_client.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Ftp_fs" rel="Chapter" href="Ftp_fs.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgssapi" rel="Chapter" href="Netgssapi.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html"><link title="Types" rel="Section" href="#types">
<link title="Input channels" rel="Section" href="#input">
<link title="Output channels" rel="Section" href="#output">
<link title="Delegation classes" rel="Section" href="#delegation">
<link title="Lifting channels" rel="Section" href="#lifting">
<link title="Channels over descriptors" rel="Section" href="#descriptors">
<link title="Transactional channels" rel="Section" href="#transactional">
<link title="Pipes and Filters" rel="Section" href="#filters">
<link title="Notes, Examples" rel="Subsection" href="#filters_notes">
<title>Ocamlnet 3 Reference Manual : Netchannels</title>
</head>
<body>
<div class="navbar"><a href="Netconversion.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Netstream.html">Next</a>
</div>
<center><h1>Module <a href="type_Netchannels.html">Netchannels</a></h1></center>
<br>
<pre><span class="keyword">module</span> Netchannels: <code class="code">sig</code> <a href="Netchannels.html">..</a> <code class="code">end</code></pre>Object-oriented I/O: Basic types and classes 
<p>

 <b>Contents</b>
<p>
<ul>
<li><a href="Netchannels.html#types"><i>Types</i></a></li>
<li><a href="Netchannels.html#input"><i>Input channels</i></a></li>
<li><a href="Netchannels.html#output"><i>Output channels</i></a></li>
<li><a href="Netchannels.html#delegation"><i>Delegation classes</i></a></li>
<li><a href="Netchannels.html#lifting"><i>Lifting channels</i></a></li>
<li><a href="Netchannels.html#descriptors"><i>Channels over descriptors</i></a></li>
<li><a href="Netchannels.html#transactional"><i>Transactional channels</i></a></li>
<li><a href="Netchannels.html#filters"><i>Pipes and Filters</i></a>
   <ul>
<li><a href="Netchannels.html#filters_notes"><i>Notes, Examples</i></a></li>
</ul>
</li>
</ul>

 The tutorial has been moved to <a href="Netchannels_tut.html"><code class="code">Netchannels_tut</code></a>.<br>
<hr width="100%">
<br>
<span id="types"><h1>Types</h1></span><br>
<br>
There are three levels of class types for channels:<ul>
<li><code class="code">rec_in_channel</code> and <code class="code">rec_out_channel</code>: Primitive, but standardized level</li>
<li><code class="code">raw_in_channel</code> and <code class="code">raw_out_channel</code>: Unix level</li>
<li><code class="code">in_obj_channel</code> and <code class="code">out_obj_channel</code>: Application level</li>
</ul>

 The "rec" level has been recently introduced to improve interoperability
 with other libraries (e.g. camomile). The idea is to standardize the
 real core methods of I/O, so they have the same meaning in all libraries.
 Read
 "<a href="http://www.ocaml-programming.de/rec/IO-Classes.html">Basic I/O class types</a>"
 for more.
<p>

 The "raw" level represents the level of Unix file descriptors.
<p>

 The application level is what should be used in programs. In addition
 to the "raw" level one can find a number of convenience methods,
 e.g. <code class="code">input_line</code> to read a line from the channel. The downside is that
 these methods usually work only for blocking I/O.
<p>

 One can lower the level by coercion, e.g. to turn an <code class="code">in_obj_channel</code>
 into a <code class="code">rec_in_channel</code>, apply the function
<p>

 <code class="code">(fun ch -&gt; (ch : in_obj_channel :&gt; rec_in_channel))</code>
<p>

 To higher the level, apply <code class="code">lift_in</code> or <code class="code">lift_out</code>, defined below.<br>
<br>
<b>Interface changes:</b> Since ocamlnet-0.98, the semantics of
 the methods <code class="code">input</code> and <code class="code">output</code> has slightly changed. When the end
 of the channel is reached, <code class="code">input</code> raises now <code class="code">End_of_file</code>. In previous
 releases of ocamlnet, the value 0 was returned. When the channel cannot
 process data, but is in non-blocking mode, both methods now return the
 value 0. In previous releases of ocamlnet, the behaviour was not
 defined.
<p>

 <b>Ocamlnet-3.0</b> changed the behavior of <code class="code">close_out</code>. Errors are no longer
 reported - instead, the exception is logged to <a href="Netlog.html"><code class="code">Netlog</code></a>. For a stricter
 error handling, it is suggested to call <code class="code">flush</code> first. Also, <code class="code">close_in</code>
 and <code class="code">close_out</code> no longer raise <code class="code">Closed_channel</code> when the channel is
 already closed. Read more about this in the section
 <a href="Netchannels.rec_out_channel-c.html#close_error"><i>How to close channels in case of errors</i></a>.<br>
<pre><span id="EXCEPTIONClosed_channel"><span class="keyword">exception</span> Closed_channel</span></pre>
<div class="info">
Raised when channel operations are called when the channel is closed<br>
</div>
<pre><span id="EXCEPTIONBuffer_underrun"><span class="keyword">exception</span> Buffer_underrun</span></pre>
<div class="info">
Raised by input methods if the internal buffer of the channel is too
 empty to read even one byte of data.
 This exception is only used by certain implementations of channel
 classes.<br>
</div>
<pre><span id="EXCEPTIONCommand_failure"><span class="keyword">exception</span> Command_failure</span> <span class="keyword">of</span> <code class="type">Unix.process_status</code></pre>
<div class="info">
Raised by <code class="code">close_in</code> or <code class="code">close_out</code> if the channel is connected with
 another process, and the execution of that process fails.<br>
</div>
<pre><span id="TYPErec_in_channel"><span class="keyword">class type</span> <a href="Netchannels.rec_in_channel-c.html">rec_in_channel</a></span> = <code class="code">object</code> <a href="Netchannels.rec_in_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
Recommended input class type for library interoperability.
</div>
<pre><span id="TYPEraw_in_channel"><span class="keyword">class type</span> <a href="Netchannels.raw_in_channel-c.html">raw_in_channel</a></span> = <code class="code">object</code> <a href="Netchannels.raw_in_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
Basic Unix-level class type for input channels as used by ocamlnet.
</div>
<pre><span id="TYPErec_out_channel"><span class="keyword">class type</span> <a href="Netchannels.rec_out_channel-c.html">rec_out_channel</a></span> = <code class="code">object</code> <a href="Netchannels.rec_out_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
Recommended output class type for library interoperability.
</div>
<pre><span id="TYPEraw_out_channel"><span class="keyword">class type</span> <a href="Netchannels.raw_out_channel-c.html">raw_out_channel</a></span> = <code class="code">object</code> <a href="Netchannels.raw_out_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
Basic Unix-level class type for output channels as used by ocamlnet.
</div>
<pre><span id="TYPEraw_io_channel"><span class="keyword">class type</span> <a href="Netchannels.raw_io_channel-c.html">raw_io_channel</a></span> = <code class="code">object</code> <a href="Netchannels.raw_io_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
A channel supporting both input and output.
</div>
<pre><span id="TYPEcompl_in_channel"><span class="keyword">class type</span> <a href="Netchannels.compl_in_channel-c.html">compl_in_channel</a></span> = <code class="code">object</code> <a href="Netchannels.compl_in_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
Further methods usually supported by ocamlnet channel implementations.
</div>
<pre><span id="TYPEin_obj_channel"><span class="keyword">class type</span> <a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a></span> = <code class="code">object</code> <a href="Netchannels.in_obj_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
The application-level input channel supports raw and complemented methods
</div>
<pre><span id="TYPEcompl_out_channel"><span class="keyword">class type</span> <a href="Netchannels.compl_out_channel-c.html">compl_out_channel</a></span> = <code class="code">object</code> <a href="Netchannels.compl_out_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
Further methods usually supported by ocamlnet channel implementations.
</div>
<pre><span id="TYPEout_obj_channel"><span class="keyword">class type</span> <a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a></span> = <code class="code">object</code> <a href="Netchannels.out_obj_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
The application-level output channel supports raw and complemented methods
</div>
<pre><span id="TYPEio_obj_channel"><span class="keyword">class type</span> <a href="Netchannels.io_obj_channel-c.html">io_obj_channel</a></span> = <code class="code">object</code> <a href="Netchannels.io_obj_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
A channel supporting both input and output.
</div>
<pre><span id="TYPEtrans_out_obj_channel"><span class="keyword">class type</span> <a href="Netchannels.trans_out_obj_channel-c.html">trans_out_obj_channel</a></span> = <code class="code">object</code> <a href="Netchannels.trans_out_obj_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
A transactional output channel has a buffer for uncommitted data.
</div>
<br>
<span id="input"><h1>Input channels</h1></span><br>
<pre><span name="TYPEinput_channel"><span class="keyword">class</span> <a href="Netchannels.input_channel-c.html">input_channel</a></span> : <code class="type">?onclose:unit -> unit -> Pervasives.in_channel -> </code><code class="type"><a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a></code></pre><div class="info">
Creates an input channel from an <code class="code">in_channel</code>, which must be open.
</div>
<pre><span name="TYPEinput_command"><span class="keyword">class</span> <a href="Netchannels.input_command-c.html">input_command</a></span> : <code class="type">string -> </code><code class="type"><a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a></code></pre><div class="info">
Runs the command with <code class="code">/bin/sh</code>, and reads the data the command prints
 to stdout.
</div>
<pre><span name="TYPEinput_string"><span class="keyword">class</span> <a href="Netchannels.input_string-c.html">input_string</a></span> : <code class="type">?pos:int -> ?len:int -> string -> </code><code class="type"><a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a></code></pre><div class="info">
Creates an input channel from a (constant) string.
</div>
<pre><span id="VALcreate_input_netbuffer"><span class="keyword">val</span> create_input_netbuffer</span> : <code class="type"><a href="Netbuffer.html#TYPEt">Netbuffer.t</a> -> <a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a> * (unit -> unit)</code></pre><div class="info">
Creates an input channel and a shutdown function for a netbuffer. 
 This is a destructive
 implementation: Every time data is read, the octets are taken from the
 beginning of the netbuffer, and they are deleted from the netbuffer
 (recall that a netbuffer works like a queue of characters).
<p>

 Conversely, the user of this class may add new data to the netbuffer 
 at any time. When the shutdown function is called, the EOF condition
 is recorded, and no further data must be added.
<p>

 If the netbuffer becomes empty, the input methods raise <code class="code">Buffer_underrun</code>
 when the EOF condition has not yet been set, and they raise
 <code class="code">End_of_file</code> when the EOF condition has been recorded.<br>
</div>
<pre><span id="VALlexbuf_of_in_obj_channel"><span class="keyword">val</span> lexbuf_of_in_obj_channel</span> : <code class="type"><a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a> -> Lexing.lexbuf</code></pre><div class="info">
Creates a lexical buffer from an input channel. The input channel
 is not closed when the end is reached
<p>

 This function does not work for non-blocking channels.<br>
</div>
<pre><span id="VALstring_of_in_obj_channel"><span class="keyword">val</span> string_of_in_obj_channel</span> : <code class="type"><a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a> -> string</code></pre><div class="info">
Reads from the input channel until EOF and returns the characters
 as string. The input channel is not closed.
<p>

 This function does not work for non-blocking channels.<br>
</div>
<pre><span id="VALlines_of_in_obj_channel"><span class="keyword">val</span> lines_of_in_obj_channel</span> : <code class="type"><a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a> -> string list</code></pre><div class="info">
Reads from the input channel until EOF and returns the lines
 as string list. The input channel is not closed.
<p>

 This function does not work for non-blocking channels.<br>
</div>
<pre><span id="VALwith_in_obj_channel"><span class="keyword">val</span> with_in_obj_channel</span> : <code class="type">(#<a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a> as 'a) -> ('a -> 'b) -> 'b</code></pre><div class="info">
<code class="code">with_in_obj_channel ch f</code>:
 Computes <code class="code">f ch</code> and closes <code class="code">ch</code>. If an exception happens, the channel is
 closed, too.<br>
</div>
<br>
<span id="output"><h1>Output channels</h1></span><br>
<pre><span name="TYPEoutput_channel"><span class="keyword">class</span> <a href="Netchannels.output_channel-c.html">output_channel</a></span> : <code class="type">?onclose:unit -> unit -> Pervasives.out_channel -> </code><code class="type"><a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a></code></pre><div class="info">
Creates an output channel writing into an <code class="code">out_channel</code>.
</div>
<pre><span name="TYPEoutput_command"><span class="keyword">class</span> <a href="Netchannels.output_command-c.html">output_command</a></span> : <code class="type">?onclose:unit -> unit -> string -> </code><code class="type"><a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a></code></pre><div class="info">
Runs the command with <code class="code">/bin/sh</code>, and data written to the channel is
 piped to stdin of the command.
</div>
<pre><span name="TYPEoutput_buffer"><span class="keyword">class</span> <a href="Netchannels.output_buffer-c.html">output_buffer</a></span> : <code class="type">?onclose:unit -> unit -> Buffer.t -> </code><code class="type"><a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a></code></pre><div class="info">
This output channel writes the data into the passed buffer.
</div>
<pre><span name="TYPEoutput_netbuffer"><span class="keyword">class</span> <a href="Netchannels.output_netbuffer-c.html">output_netbuffer</a></span> : <code class="type">?onclose:unit -> unit -> <a href="Netbuffer.html#TYPEt">Netbuffer.t</a> -> </code><code class="type"><a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a></code></pre><div class="info">
This output channel writes the data into the passed netbuffer.
</div>
<pre><span name="TYPEoutput_null"><span class="keyword">class</span> <a href="Netchannels.output_null-c.html">output_null</a></span> : <code class="type">?onclose:unit -> unit -> unit -> </code><code class="type"><a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a></code></pre><div class="info">
This output channel discards all written data.
</div>
<pre><span id="VALwith_out_obj_channel"><span class="keyword">val</span> with_out_obj_channel</span> : <code class="type">(#<a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a> as 'a) -> ('a -> 'b) -> 'b</code></pre><div class="info">
<code class="code">with_out_obj_channel ch f</code>:
 Computes <code class="code">f ch</code> and closes <code class="code">ch</code>. If an exception happens, the channel is
 closed, too.<br>
</div>
<br>
<span id="delegation"><h1>Delegation classes</h1></span><br>
<br>
Delegation classes just forward method calls to an parameter
 object, i.e. when method <code class="code">m</code> of the delegation class is called,
 the definition of <code class="code">m</code> is just to call the method with the same
 name <code class="code">m</code> of the parameter object. This is very useful in order
 to redefine methods individually.
<p>

 For example, to redefine the method <code class="code">pos_in</code> of an <code class="code">in_obj_channel</code>,
 use
 <pre><code class="code"> class my_channel = object(self)
   inherit in_obj_channel_delegation ...
   method pos_in = ...
 end
 </code></pre>
<p>

 As a special feature, the following delegation classes can suppress
 the delegation of <code class="code">close_in</code> or <code class="code">close_out</code>, whatever applies.
 Just pass <code class="code">close:false</code> to get this effect, e.g.
 <pre><code class="code"> class input_channel_don't_close c =
   in_obj_channel_delegation ~close:false (new input_channel c)
 </code></pre>
 This class does not close <code class="code">c : in_channel</code> when the <code class="code">close_in</code>
 method is called.<br>
<pre><span name="TYPErec_in_channel_delegation"><span class="keyword">class</span> <a href="Netchannels.rec_in_channel_delegation-c.html">rec_in_channel_delegation</a></span> : <code class="type">?close:bool -> <a href="Netchannels.rec_in_channel-c.html">rec_in_channel</a> -> </code><code class="type"><a href="Netchannels.rec_in_channel-c.html">rec_in_channel</a></code></pre><pre><span name="TYPEraw_in_channel_delegation"><span class="keyword">class</span> <a href="Netchannels.raw_in_channel_delegation-c.html">raw_in_channel_delegation</a></span> : <code class="type">?close:bool -> <a href="Netchannels.raw_in_channel-c.html">raw_in_channel</a> -> </code><code class="type"><a href="Netchannels.raw_in_channel-c.html">raw_in_channel</a></code></pre><pre><span name="TYPEin_obj_channel_delegation"><span class="keyword">class</span> <a href="Netchannels.in_obj_channel_delegation-c.html">in_obj_channel_delegation</a></span> : <code class="type">?close:bool -> <a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a> -> </code><code class="type"><a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a></code></pre><pre><span name="TYPErec_out_channel_delegation"><span class="keyword">class</span> <a href="Netchannels.rec_out_channel_delegation-c.html">rec_out_channel_delegation</a></span> : <code class="type">?close:bool -> <a href="Netchannels.rec_out_channel-c.html">rec_out_channel</a> -> </code><code class="type"><a href="Netchannels.rec_out_channel-c.html">rec_out_channel</a></code></pre><pre><span name="TYPEraw_out_channel_delegation"><span class="keyword">class</span> <a href="Netchannels.raw_out_channel_delegation-c.html">raw_out_channel_delegation</a></span> : <code class="type">?close:bool -> <a href="Netchannels.raw_out_channel-c.html">raw_out_channel</a> -> </code><code class="type"><a href="Netchannels.raw_out_channel-c.html">raw_out_channel</a></code></pre><pre><span name="TYPEout_obj_channel_delegation"><span class="keyword">class</span> <a href="Netchannels.out_obj_channel_delegation-c.html">out_obj_channel_delegation</a></span> : <code class="type">?close:bool -> <a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a> -> </code><code class="type"><a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a></code></pre><br>
<span id="lifting"><h1>Lifting channels</h1></span><br>
<br>
The following classes and functions add missing methods to reach
 a higher level in the hierarchy of channel class types. For most
 uses, the <code class="code">lift_in</code> and <code class="code">lift_out</code> functions work best.<br>
<pre><span id="VALlift_in"><span class="keyword">val</span> lift_in</span> : <code class="type">?eol:string list -><br>       ?buffered:bool -><br>       ?buffer_size:int -><br>       [ `Raw of <a href="Netchannels.raw_in_channel-c.html">raw_in_channel</a> | `Rec of <a href="Netchannels.rec_in_channel-c.html">rec_in_channel</a> ] -><br>       <a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a></code></pre><div class="info">
Turns a <code class="code">rec_in_channel</code> or <code class="code">raw_in_channel</code>, depending on the passed
 variant, into a full <code class="code">in_obj_channel</code> object. (This is a convenience
 function, you can also use the classes below directly.) If you
 want to define a class for the lifted object, use
 <pre><code class="code"> class lifted_ch ... =
   in_obj_channel_delegation (lift_in ...)
 </code></pre>
<p>

<br>
</div>
<div class="param_info"><code class="code">eol</code> : The accepted end-of-line delimiters. The method 
   <code class="code">input_line</code> recognizes any of the passed strings as EOL
   delimiters. When more than one delimiter matches, the longest
   is taken. Defaults to <code class="code"> ["\n"] </code>. The default cannot be
   changed when <code class="code">buffered=false</code> (would raise <code class="code">Invalid_argument</code>).
   The delimiter strings must neither be empty, nor longer than
   <code class="code">buffer_size</code>.</div>
<div class="param_info"><code class="code">buffered</code> : Whether a buffer is added, by default <b>true</b></div>
<div class="param_info"><code class="code">buffer_size</code> : The size of the buffer, if any, by default 4096</div>
<pre><span id="VALlift_out"><span class="keyword">val</span> lift_out</span> : <code class="type">?buffered:bool -><br>       ?buffer_size:int -><br>       [ `Raw of <a href="Netchannels.raw_out_channel-c.html">raw_out_channel</a> | `Rec of <a href="Netchannels.rec_out_channel-c.html">rec_out_channel</a> ] -><br>       <a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a></code></pre><div class="info">
Turns a <code class="code">rec_out_channel</code> or <code class="code">raw_out_channel</code>, depending on the passed
 variant, into a full <code class="code">out_obj_channel</code> object. (This is a convenience
 function, you can also use the classes below directly.) If you
 want to define a class for the lifted object, use
 <pre><code class="code"> class lifted_ch ... =
   out_obj_channel_delegation (lift_out ...)
 </code></pre>
<p>

<br>
</div>
<div class="param_info"><code class="code">buffered</code> : Whether a buffer is added, by default <b>true</b></div>
<div class="param_info"><code class="code">buffer_size</code> : The size of the buffer, if any, by default 4096</div>
<pre><span name="TYPEaugment_raw_in_channel"><span class="keyword">class</span> <span class="keyword">virtual</span> <a href="Netchannels.augment_raw_in_channel-c.html">augment_raw_in_channel</a></span> : <code class="type"></code><code class="code">object</code> <a href="Netchannels.augment_raw_in_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
This class implements the methods from <code class="code">compl_in_channel</code> by calling
 the methods of <code class="code">raw_in_channel</code>.
</div>
<pre><span name="TYPElift_rec_in_channel"><span class="keyword">class</span> <a href="Netchannels.lift_rec_in_channel-c.html">lift_rec_in_channel</a></span> : <code class="type">?start_pos_in:int -> <a href="Netchannels.rec_in_channel-c.html">rec_in_channel</a> -> </code><code class="type"><a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a></code></pre><div class="info">
This class implements <code class="code">pos_in</code> and the methods from <code class="code">compl_in_channel</code> 
 by calling the methods of <code class="code">rec_in_channel</code>.
</div>
<pre><span name="TYPEaugment_raw_out_channel"><span class="keyword">class</span> <span class="keyword">virtual</span> <a href="Netchannels.augment_raw_out_channel-c.html">augment_raw_out_channel</a></span> : <code class="type"></code><code class="code">object</code> <a href="Netchannels.augment_raw_out_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
This class implements the methods from <code class="code">compl_out_channel</code> by calling
 the methods of <code class="code">raw_out_channel</code>.
</div>
<pre><span name="TYPElift_raw_out_channel"><span class="keyword">class</span> <a href="Netchannels.lift_raw_out_channel-c.html">lift_raw_out_channel</a></span> : <code class="type"><a href="Netchannels.raw_out_channel-c.html">raw_out_channel</a> -> </code><code class="type"><a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a></code></pre><div class="info">
This class implements the methods from <code class="code">compl_out_channel</code> by calling
 the methods of <code class="code">raw_out_channel</code>.
</div>
<pre><span name="TYPElift_rec_out_channel"><span class="keyword">class</span> <a href="Netchannels.lift_rec_out_channel-c.html">lift_rec_out_channel</a></span> : <code class="type">?start_pos_out:int -> <a href="Netchannels.rec_out_channel-c.html">rec_out_channel</a> -> </code><code class="type"><a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a></code></pre><div class="info">
This class implements <code class="code">pos_out</code> and the methods from <code class="code">compl_out_channel</code> 
 by calling the methods of <code class="code">rec_out_channel</code>.
</div>
<pre><span id="TYPEinput_result"><span class="keyword">type</span> <code class="type"></code>input_result</span> = <code class="type">[ `Data of int | `Separator of string ]</code> </pre>
<div class="info">
This type is for the method <code class="code">enhanced_input</code> of <code class="code">enhanced_raw_in_channel</code>.<ul>
<li><code class="code">`Data n</code> means that <code class="code">n</code> bytes have been copied to the target string</li>
<li><code class="code">`Separator s</code> means that no bytes have been copied, but that an
   end-of-line separator <code class="code">s</code> has been found</li>
</ul>
<br>
</div>

<pre><span id="TYPEenhanced_raw_in_channel"><span class="keyword">class type</span> <a href="Netchannels.enhanced_raw_in_channel-c.html">enhanced_raw_in_channel</a></span> = <code class="code">object</code> <a href="Netchannels.enhanced_raw_in_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
Defines private methods reading text line by line
</div>
<pre><span name="TYPEbuffered_raw_in_channel"><span class="keyword">class</span> <a href="Netchannels.buffered_raw_in_channel-c.html">buffered_raw_in_channel</a></span> : <code class="type">?eol:string list -> ?buffer_size:int -> <a href="Netchannels.raw_in_channel-c.html">raw_in_channel</a> -> </code><code class="type"><a href="Netchannels.enhanced_raw_in_channel-c.html">enhanced_raw_in_channel</a></code></pre><div class="info">
This class adds a buffer to the underlying <code class="code">raw_in_channel</code>.
</div>
<pre><span name="TYPEbuffered_raw_out_channel"><span class="keyword">class</span> <a href="Netchannels.buffered_raw_out_channel-c.html">buffered_raw_out_channel</a></span> : <code class="type">?buffer_size:int -> <a href="Netchannels.raw_out_channel-c.html">raw_out_channel</a> -> </code><code class="type"><a href="Netchannels.raw_out_channel-c.html">raw_out_channel</a></code></pre><div class="info">
This class adds a buffer to the underlying <code class="code">raw_out_channel</code>.
</div>
<br>
<span id="descriptors"><h1>Channels over descriptors</h1></span><br>
<pre><span name="TYPEinput_descr"><span class="keyword">class</span> <a href="Netchannels.input_descr-c.html">input_descr</a></span> : <code class="type">?blocking:bool -> ?start_pos_in:int -> Unix.file_descr -> </code><code class="type"><a href="Netchannels.raw_in_channel-c.html">raw_in_channel</a></code></pre><div class="info">
Creates a <code class="code">raw_in_channel</code> for the passed file descriptor, which must
 be open for reading.
</div>
<pre><span name="TYPEoutput_descr"><span class="keyword">class</span> <a href="Netchannels.output_descr-c.html">output_descr</a></span> : <code class="type">?blocking:bool -> ?start_pos_out:int -> Unix.file_descr -> </code><code class="type"><a href="Netchannels.raw_out_channel-c.html">raw_out_channel</a></code></pre><div class="info">
Creates a <code class="code">raw_out_channel</code> for the passed file descriptor, which must
 be open for writing.
</div>
<pre><span name="TYPEsocket_descr"><span class="keyword">class</span> <a href="Netchannels.socket_descr-c.html">socket_descr</a></span> : <code class="type">?blocking:bool -> ?start_pos_in:int -> ?start_pos_out:int -> Unix.file_descr -> </code><code class="type"><a href="Netchannels.raw_io_channel-c.html">raw_io_channel</a></code></pre><div class="info">
Creates a <code class="code">raw_io_channel</code> for the passed socket descriptor, which must
 be open for reading and writing, and not yet shut down in either
 direction.
</div>
<br>
<span id="transactional"><h1>Transactional channels</h1></span><br>
<pre><span id="TYPEclose_mode"><span class="keyword">type</span> <code class="type"></code>close_mode</span> = <code class="type">[ `Commit | `Rollback ]</code> </pre>
<div class="info">
Whether a <code class="code">close_out</code> implies a commit or rollback operation<br>
</div>

<pre><span name="TYPEbuffered_trans_channel"><span class="keyword">class</span> <a href="Netchannels.buffered_trans_channel-c.html">buffered_trans_channel</a></span> : <code class="type">?close_mode:<a href="Netchannels.html#TYPEclose_mode">close_mode</a> -> <a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a> -> </code><code class="type"><a href="Netchannels.trans_out_obj_channel-c.html">trans_out_obj_channel</a></code></pre><div class="info">
A transactional output channel with a transaction buffer implemented
 in memory
</div>
<pre><span id="VALmake_temporary_file"><span class="keyword">val</span> make_temporary_file</span> : <code class="type">?mode:int -><br>       ?limit:int -><br>       ?tmp_directory:string -><br>       ?tmp_prefix:string -><br>       unit -> string * Pervasives.in_channel * Pervasives.out_channel</code></pre><div class="info">
Creates a temporary file in the directory <code class="code">tmp_directory</code> with a name
 prefix <code class="code">tmp_prefix</code> and a unique suffix. The function returns 
 the triple (name, inch, outch) containing the file <code class="code">name</code>,
 the file opened as in_channel <code class="code">inch</code> and as out_channel <code class="code">outch</code>.
<p>

<br>
</div>
<div class="param_info"><code class="code">mode</code> : The creation mask of the file; defaults to 0o600, i.e. the
   file is private for the current user</div>
<div class="param_info"><code class="code">limit</code> : Limits the number of trials to find the unique suffix.
   Defaults to 1000.</div>
<div class="param_info"><code class="code">tmp_directory</code> : Defaults to <code class="code">Netsys_tmp.tmp_directory()</code></div>
<div class="param_info"><code class="code">tmp_prefix</code> : By default <code class="code">"netstring"</code>. This needs not to be
   unique, but just descriptive.</div>
<pre><span name="TYPEtempfile_trans_channel"><span class="keyword">class</span> <a href="Netchannels.tempfile_trans_channel-c.html">tempfile_trans_channel</a></span> : <code class="type">?close_mode:<a href="Netchannels.html#TYPEclose_mode">close_mode</a> -> ?tmp_directory:string -> ?tmp_prefix:string -> <a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a> -> </code><code class="type"><a href="Netchannels.trans_out_obj_channel-c.html">trans_out_obj_channel</a></code></pre><div class="info">
A transactional output channel with a transaction buffer implemented
 as temporary file
</div>
<br>
<span id="filters"><h1>Pipes and Filters</h1></span><br>
<br>
Note that this has nothing to do with "pipes" on the Unix level.
 It is, however, the same idea: Connecting two I/O resources with an
 intermediate buffer.<br>
<pre><span name="TYPEpipe"><span class="keyword">class</span> <a href="Netchannels.pipe-c.html">pipe</a></span> : <code class="type">?conv:<a href="Netbuffer.html#TYPEt">Netbuffer.t</a> -> bool -> <a href="Netbuffer.html#TYPEt">Netbuffer.t</a> -> unit -> ?buffer_size:int -> unit -> </code><code class="type"><a href="Netchannels.io_obj_channel-c.html">io_obj_channel</a></code></pre><div class="info">
A <code class="code">pipe</code> has two internal buffers (realized by Netbuffer).
</div>
<pre><span name="TYPEoutput_filter"><span class="keyword">class</span> <a href="Netchannels.output_filter-c.html">output_filter</a></span> : <code class="type"><a href="Netchannels.io_obj_channel-c.html">io_obj_channel</a> -> <a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a> -> </code><code class="type"><a href="Netchannels.out_obj_channel-c.html">out_obj_channel</a></code></pre><div class="info">
An <code class="code">output_filter</code> filters the data written to it through the
 <code class="code">io_obj_channel</code> (usually a <code class="code">pipe</code>), and writes the filtered data
 to the passed <code class="code">out_obj_channel</code>.
</div>
<pre><span name="TYPEinput_filter"><span class="keyword">class</span> <a href="Netchannels.input_filter-c.html">input_filter</a></span> : <code class="type"><a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a> -> <a href="Netchannels.io_obj_channel-c.html">io_obj_channel</a> -> </code><code class="type"><a href="Netchannels.in_obj_channel-c.html">in_obj_channel</a></code></pre><div class="info">
An <code class="code">input_filter</code> filters the data read from it through the
 <code class="code">io_obj_channel</code> (usually a <code class="code">pipe</code> after the data have been 
 retrieved from the passed <code class="code">in_obj_channel</code>.
</div>
<br>
<span id="filters_notes"><h2>Notes, Examples</h2></span><br>
<br>
If you have the choice, prefer <code class="code">output_filter</code> over <code class="code">input_filter</code>.
 The latter is slower.
<p>

 The primary application of filters is to encode or decode a channel
 on the fly. For example, the following lines write a BASE64-encoded file:
<p>

 <pre><code class="code">let ch = new output_channel (open_out "file.b64") in
 let encoder = new Netencoding.Base64.encoding_pipe ~linelength:76 () in
 let ch' = new output_filter encoder ch in
 ... (* write to ch' *)
 ch' # close_out();
 ch  # close_out();  (* you must close both channels! *)
 </code></pre>
<p>

 All bytes written to <code class="code">ch'</code> are BASE64-encoded and the encoded bytes are
 written to <code class="code">ch</code>.
<p>

 There are also pipes to decode BASE64, and to encode and decode the
 "Quoted printable" format. Encoding and decoding work even if the
 data is delivered in disadvantageous chunks, because the data is
 "re-chunked" if needed. For example, BASE64 would require that data
 arrive in multiples of three bytes, and to cope with that, the BASE64 pipe
 only processes the prefix of the input buffer that is a multiple of three,
 and defers the encoding of the extra bytes till the next opportunity.<br>
</body></html>